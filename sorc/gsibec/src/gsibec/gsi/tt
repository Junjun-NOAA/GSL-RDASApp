diff -r ../../../../../sorc/gsibec/src/gsibec/gsi/gsimod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/gsibec/src/gsibec/gsi/gsimod.F90
36a37
>   use m_berror_stats, only: usenewgfsberror
416c417
<         simcv,bkgv_write_cv,bkgv_write_sv
---
>         simcv,bkgv_write_cv,bkgv_write_sv,usenewgfsberror
diff -r ../../../../../sorc/gsibec/src/gsibec/gsi/mod_fv3_lola.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/gsibec/src/gsibec/gsi/mod_fv3_lola.f90
263a264,265
>   if (allocated(coeffx )) deallocate(coeffx )
>   if (allocated(coeffy )) deallocate(coeffy )
829c831
<   deallocate(coeffx,coeffy)
---
>   !deallocate(coeffx,coeffy)
diff -r ../../../../../sorc/gsibec/src/gsibec/gsi/tt /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/gsibec/src/gsibec/gsi/tt
1,2c1,3593
< diff -r ../../../../../sorc/gsibec/src/gsibec/gsi/gsimod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/gsibec/src/gsibec/gsi/gsimod.F90
< 36a37
---
> diff -r ./abstract_ensmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/abstract_ensmod.f90
> 47c47
> <       use m_kinds, only: i_kind
> ---
> >       use kinds, only: i_kind
> 68,69c68,69
> <     subroutine get_user_ens(this,grd,member,nymd,nhms,tau,atm_bundle,iret)
> <       use m_kinds, only: i_kind
> ---
> >     subroutine get_user_ens(this,grd,member,ntindex,atm_bundle,iret)
> >       use kinds, only: i_kind
> 77,78c77
> <       integer(i_kind),     intent(in   ) :: nymd,nhms
> <       integer(i_kind),     intent(in   ) :: tau
> ---
> >       integer(i_kind),     intent(in   ) :: ntindex
> 85,86c84,85
> <     subroutine get_user_Nens(this,grd,members,nymd,nhms,tau,atm_bundle,iret)
> <       use m_kinds, only: i_kind
> ---
> >     subroutine get_user_Nens(this,grd,members,ntindex,atm_bundle,iret)
> >       use kinds, only: i_kind
> 94,95c93
> <       integer(i_kind),     intent(in   ) :: nymd,nhms
> <       integer(i_kind),     intent(in   ) :: tau
> ---
> >       integer(i_kind),     intent(in   ) :: ntindex
> 103c101
> <       use m_kinds, only: i_kind
> ---
> >       use kinds, only: i_kind
> 119c117
> <       use m_kinds, only: r_kind
> ---
> >       use kinds, only: r_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: adjtest.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: adjtest_obs.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: adjust_cloudobs_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: aero_guess_at_obs_locations.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: aeroinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: aircraftinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: aircraftobsqc.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: amassaeromod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: anberror.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: anbkerror.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: aniso_ens_util.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: anisofilter.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: anisofilter_glb.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: antcorr_application.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: antest_maps0.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: antest_maps0_glb.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: apply_scaledepwgts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: atms_spatial_average_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: balmod.f90
> Only in ./: balmod.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: berror.f90
> Only in ./: berror.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: bias_predictors.f90
> Only in ./: bias_predictors.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: bicg.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: bicglanczos.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: bkerror.f90
> Only in ./: bkerror.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: bkgcov.f90
> Only in ./: bkgcov.F90
> diff -r ./bkgvar.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/bkgvar.f90
> 66c66
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 86c86
> <   real(r_kind),dimension(lat2,lon2) :: sst,stl,sti
> ---
> >   real(r_kind),dimension(lat2,lon2) :: sst
> 108,110c108,112
> <   sst=zero
> <   stl=zero
> <   sti=zero
> ---
> >   if(iflg == 0)then
> >      if(i_sst > 0)sst=zero
> >      if(i_stl > 0)ptrstl=zero
> >      if(i_sti > 0)ptrsti=zero
> >   end if
> 115d116
> <      call gsi_bundlegetpointer(cvec,cvec%r2(n)%shortname,ptr2d,istatus)
> 116a118
> >         call gsi_bundlegetpointer(cvec,cvec%r2(n)%shortname,ptr2d,istatus)
> 133c135
> <                     if(isli2(j,i) == 1) stl(j,i)=ptrsst(j,i)*dssvs(j,i,n)
> ---
> >                     if(isli2(j,i) == 1) ptrstl(j,i)=ptrsst(j,i)*dssvs(j,i,n)
> 139c141
> <                     if(isli2(j,i) == 2) sti(j,i)=ptrsst(j,i)*dssvs(j,i,n)
> ---
> >                     if(isli2(j,i) == 2) ptrsti(j,i)=ptrsst(j,i)*dssvs(j,i,n)
> 147c149
> <                     if(isli2(j,i)/=1.and.isli2(j,i)/=2) sst(j,i)=ptrsst(j,i)*dssvs(j,i,n)
> ---
> >                     if(isli2(j,i)/=1.and.isli2(j,i)/=2) ptrsst(j,i)=ptrsst(j,i)*dssvs(j,i,n)
> 153c155
> <                     if(isli2(j,i) == 1) sst(j,i)=ptrstl(j,i)*dssvs(j,i,n)
> ---
> >                     if(isli2(j,i) == 1) ptrsst(j,i)=ptrstl(j,i)*dssvs(j,i,n)
> 159c161
> <                     if(isli2(j,i) == 2) sst(j,i)=ptrsti(j,i)*dssvs(j,i,n)
> ---
> >                     if(isli2(j,i) == 2) ptrsst(j,i)=ptrsti(j,i)*dssvs(j,i,n)
> 166a169
> >   if(iflg == 0 .and. i_sst>0) ptrsst=sst
> 168,175d170
> <   if(iflg==0) then
> <      if(i_sst>0) ptrsst=sst
> <      if(i_stl>0) ptrstl=stl
> <      if(i_sti>0) ptrsti=sti
> <   else
> <      if(i_sst>0) ptrsst=sst
> < !        ignore contents of ptrstl,ptrsti
> <   end if
> 209,210c204,205
> <   use m_kinds, only: r_kind,i_kind
> <   use m_mpimod, only : mype
> ---
> >   use kinds, only: r_kind,i_kind
> >   use mpimod, only : mype
> 212d206
> <   use mpeu_util, only : die
> 286,287c280
> <       call die ('bkgvar',': flow dep opt deactivated', 99)
> < !     if(do_flow_dep) call bkgvar_rewgt(cv_sf,cv_vp,cv_t,cv_ps,mype)
> ---
> >       if(do_flow_dep) call bkgvar_rewgt(cv_sf,cv_vp,cv_t,cv_ps,mype)
> diff -r ./bkgvar_rewgt.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/bkgvar_rewgt.f90
> 42c42
> <   use m_kinds, only: r_kind,i_kind,r_quad
> ---
> >   use kinds, only: r_kind,i_kind,r_quad
> 46c46
> <   use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mpi_sum,mpi_rtype,mpi_max
> ---
> >   use mpimod, only: npe,mpi_comm_world,ierror,mpi_sum,mpi_rtype,mpi_max
> 78d77
> <   real(r_kind) isend(1),irec(1)
> 103c102
> <   fcount = float(nlat)*float(nlon)
> ---
> >   fcount = real(nlat*nlon,r_kind)
> 226,228c225,227
> <            delpsi(i,j,k)=sqrt( delpsi(i,j,k)**two )
> <            delchi(i,j,k)=sqrt( delchi(i,j,k)**two )
> <            deltv (i,j,k)=sqrt( deltv (i,j,k)**two )
> ---
> >            delpsi(i,j,k)=abs( delpsi(i,j,k) )
> >            delchi(i,j,k)=abs( delchi(i,j,k) )
> >            deltv (i,j,k)=abs( deltv (i,j,k) )
> 234c233
> <         delps(i,j)=sqrt( delps(i,j)**two )
> ---
> >         delps(i,j)=abs( delps(i,j) )
> 281,291c280,288
> <   call mpi_allreduce(mean_dz0,mean_dz1,nsig*2*npe,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> <   call mpi_allreduce(mean_dd0,mean_dd1,nsig*2*npe,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> <   call mpi_allreduce(mean_dt0,mean_dt1,nsig*2*npe,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> <   call mpi_allreduce(mean_dps0,mean_dps1,2*npe,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> < 
> <   call mpi_allreduce(max_dz,max_dz0,nsig,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <   call mpi_allreduce(max_dd,max_dd0,nsig,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <   call mpi_allreduce(max_dt,max_dt0,nsig,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <   isend(1)=max_dps
> <   call mpi_allreduce(isend,irec,1,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <   max_dps0=irec(1)
> ---
> >   call mpi_allreduce(mean_dz0,mean_dz1,nsig*2*npe,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> >   call mpi_allreduce(mean_dd0,mean_dd1,nsig*2*npe,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> >   call mpi_allreduce(mean_dt0,mean_dt1,nsig*2*npe,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> >   call mpi_allreduce(mean_dps0,mean_dps1,2*npe,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> > 
> >   call mpi_allreduce(max_dz,max_dz0,nsig,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> >   call mpi_allreduce(max_dd,max_dd0,nsig,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> >   call mpi_allreduce(max_dt,max_dt0,nsig,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> >   call mpi_allreduce(max_dps,max_dps0,1,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> 397c394
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 489c486
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 669,671c666,667
> <   use m_kinds, only: r_kind,i_kind
> <   use m_mpimod, only: mpi_rtype,gsi_mpi_comm_world,ierror
> <   use m_mpimod, only: mpi_real8
> ---
> >   use kinds, only: r_kind,i_kind
> >   use mpimod, only: mpi_rtype,mpi_comm_world,ierror
> 696c692
> <                   tempa,g1%ijn,g1%displs_g,mpi_rtype,outpe,gsi_mpi_comm_world,ierror)
> ---
> >                   tempa,g1%ijn,g1%displs_g,mpi_rtype,outpe,mpi_comm_world,ierror)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: blacklist.f90
> diff -r ./blendmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/blendmod.f90
> 26c26
> <    use m_kinds, only: r_kind,i_kind
> ---
> >    use kinds, only: r_kind,i_kind
> 236c236
> <   use m_kinds, only: i_kind
> ---
> >   use kinds, only: i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: blockIO.c
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: buddycheck_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cads.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calc_fov_conical.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calc_fov_crosstrk.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calctends_ad.f90
> Only in ./: calctends_ad.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calctends.f90
> Only in ./: calctends.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calctends_no_ad.f90
> Only in ./: calctends_no_ad.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calctends_no_tl.f90
> Only in ./: calctends_no_tl.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: calctends_tl.f90
> Only in ./: calctends_tl.F90
> diff -r ./chemmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/chemmod.f90
> 21c21
> <   use m_kinds, only : i_kind, r_kind, r_single
> ---
> >   use kinds, only : i_kind, r_kind, r_single
> 53c53
> <   public :: oblat_chem,oblon_chem,obpres_chem,diag_incr
> ---
> >   public :: oblat_chem,oblon_chem,obpres_chem,diag_incr,oneobschem
> 341a342,493
> > 
> >   subroutine oneobschem(nread,ndata,nodata,gstime,&
> >         infile,obstype,lunout,sis,nobs)
> > 
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:  one obs test for in-situ chem
> > !   prgmmr: pagowski                date: 2010-11-18
> > !
> > ! program history log:
> > !   2010-11-18  pagowski
> > !   2013-01-23  parrish - change from grdcrd to grdcrd1 (to allow successful debug compile on WCOSS)
> > !
> > !   input argument list:
> > !     obstype  - observation type to process
> > !     lunout   - unit to which to write data for further processing
> > !
> > !   output argument list:
> > !     nread    - number of type "obstype" observations read
> > !     ndata    - number of type "obstype" observations retained for further processing
> > !     nodata   - number of individual "obstype" observations retained for !further processing
> > !     sis      - satellite/instrument/sensor indicator
> > !     nobs     - array of observations on each subdomain for each processor
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$
> > 
> >     use constants, only: zero,one,deg2rad,rad2deg
> >     use gridmod, only: diagnostic_reg,regional,nlon,nlat,&
> >          tll2xy,txy2ll,rlats,rlons
> >     use convinfo, only: nconvtype,icuse,ioctype
> >     use mpimod, only: npe
> >     
> >     implicit none
> >     
> > ! declare passed variables
> >     character(len=*),intent(in   ) :: obstype
> >     character(len=*),intent(out) :: infile
> >     integer(i_kind) ,intent(in   ) :: lunout
> >     integer(i_kind) ,intent(inout) :: nread,ndata,nodata
> >     real(r_kind)    ,intent(in   ) :: gstime
> >     character(len=*),intent(in   ) :: sis
> >     integer(i_kind),dimension(npe) ,intent(inout) :: nobs
> >     
> >     
> > ! declare local parameters
> >     
> >     integer(i_kind), parameter :: nsid=1,nxob=2,&
> >           nyob=3,ndhr=4,ntyp=5,ncopopm=6
> > !see headr input format below
> >     
> >     integer(i_kind), parameter:: nchanl=0,nreal=ilone
> >     
> >     real(r_kind),parameter :: r100 = 100.0_r_kind
> >     real(r_kind),parameter :: r360 = 360.0_r_kind
> >     
> > ! declare local variables
> >     logical outside
> >     
> >     integer(i_kind) i
> >     integer(i_kind) ikx
> >     
> >     real(r_kind) :: tdiff,obstime
> >     real(r_kind) :: dlat,dlon,obserror,dlat_earth,dlon_earth
> >     
> >     real(r_kind) cdist,disterr,disterrmax,rlon00,rlat00
> >     integer(i_kind) ntest
> >     
> >     integer(i_kind) k,site_char,site_id
> >     real(r_kind) :: conc,site_elev
> >     real(r_kind), dimension(nreal,1):: cdata_all
> >     
> >     site_id=123456789
> >     site_char=1 ! set unknown site character
> >     site_elev=elev_missing ! set unknown site elevation
> >     
> > !**************************************************************************
> > ! initialize variables
> >     infile='namelist'
> >     disterrmax=zero
> >     ntest=1
> >     nread=1
> >     ndata = 1
> >     nodata = 1
> >     
> >     if(oblon_chem >= r360)  oblon_chem = oblon_chem - r360
> >     if(oblon_chem <  zero)  oblon_chem = oblon_chem + r360
> >     
> >     dlon_earth=oblon_chem*deg2rad
> >     dlat_earth=oblat_chem*deg2rad
> >     obstime=gstime
> >     tdiff=zero
> >     conc=zero ! this is unimportant since only innovation counts
> >   
> >     if(regional)then
> >        
> >        call tll2xy(dlon_earth,dlat_earth,dlon,dlat,outside)    ! convert to rotated coordinate
> >        
> >        if(diagnostic_reg) then
> >           
> >           call txy2ll(dlon,dlat,rlon00,rlat00)
> >           cdist=sin(dlat_earth)*sin(rlat00)+cos(dlat_earth)*cos(rlat00)* &
> >                (sin(dlon_earth)*sin(rlon00)+cos(dlon_earth)*cos(rlon00))
> >           cdist=max(-one,min(cdist,one))
> >           disterr=acos(cdist)*rad2deg
> >           disterrmax=max(disterrmax,disterr)
> >        end if
> >        
> >        if(outside) then 
> >           write(6,*)'oneobtest_chem outside domain - stopping'
> >           call stop2(511)
> >        endif
> >        
> >     else
> >        dlat = dlat_earth
> >        dlon = dlon_earth
> >        call grdcrd1(dlat,rlats,nlat,1)
> >        call grdcrd1(dlon,rlons,nlon,1)
> >     endif
> >     
> >     do i = 1, nconvtype
> >        if (obstype == ioctype(i) .and. abs(icuse(i))== 1) ikx=i
> >     end do
> >            
> >     obserror=magoberr_chem
> >     
> >     cdata_all(iconc,ndata)  = conc                    ! pm2_5 obs    
> >     cdata_all(ierror,ndata) = obserror                ! pm2_5 obs error
> >     cdata_all(ilat,ndata)   = dlat                    ! grid relative latitude 
> >     
> >     cdata_all(ilon,ndata)   = dlon                    ! grid relative longitude 
> >     cdata_all(itime,ndata)  = obstime                 ! time of obs
> >     cdata_all(iid,ndata)    = site_id                 ! site id
> >     cdata_all(ielev,ndata)  = site_elev               ! elevation
> >     cdata_all(isite,ndata)  = site_char               ! site character
> >     cdata_all(iikx,ndata)   = ikx                     ! ordered number in convinfo table
> >     cdata_all(ilate,ndata)  = dlat_earth*rad2deg      ! earth relative latitude (degrees)
> >     cdata_all(ilone,ndata)  = dlon_earth*rad2deg      ! earth relative longitude (degrees)
> >     
> >     
> > ! write header record and data to output file for further processing
> >     call count_obs(ndata,nreal,ilat,ilon,cdata_all,nobs)
> >     write(lunout) obstype,sis,nreal,nchanl,ilat,ilon
> >     write(lunout) ((cdata_all(k,i),k=1,nreal),i=1,ndata)
> >     
> >     return
> >     
> >   end subroutine oneobschem
> > 
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_get_fv3_regional_ensperts.f90
> diff -r ./class_get_pseudo_ensperts.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/class_get_pseudo_ensperts.f90
> 11c11
> <     use m_kinds, only: i_kind
> ---
> >     use kinds, only: i_kind
> 15c15
> <     type(gsi_bundle),allocatable, intent(in   ) :: en_perts(:,:)
> ---
> >     type(gsi_bundle),allocatable, intent(in   ) :: en_perts(:,:,:)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_get_wrf_mass_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_get_wrf_nmm_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_read_wrf_mass_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_read_wrf_mass_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_read_wrf_nmm_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_read_wrf_nmm_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_regional_io.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_wrf_binary_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_wrf_netcdf_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_wrwrfmassa.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: class_wrwrfnmma.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cloud_efr_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: clw_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cmake
> diff -r ./CMakeLists.txt /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/CMakeLists.txt
> 1,2c1
> < # BClim
> < list(APPEND gsi_src_files_list
> ---
> > cmake_minimum_required(VERSION 3.19)
> 4,133c3,17
> < abstract_ensmod.f90
> < balmod.F90
> < berror.F90
> < bias_predictors.F90
> < bkerror.F90
> < bkgcov.F90
> < bkgvar.f90
> < bkgvar_rewgt.f90
> < blendmod.f90
> < calctends.F90
> < class_get_pseudo_ensperts.f90
> < compact_diffs.f90
> < compute_derived.F90
> < compute_qvar3d.F90
> < constants.f90
> < control2state_ad.F90
> < control2state.F90
> < control_vectors.f90
> < gsi_convert_cv_mod.f90
> < derivsmod.f90
> < egrid2agrid_mod.f90
> < en_perts_io.f90
> < ensctl2state.F90
> < ensctl2state_ad.F90
> < fgrid2agrid_mod.f90
> < general_commvars_mod.f90
> < general_specmod.f90
> < general_spectral_transforms.f90
> < general_sub2grid_mod.f90
> < general_transform.f90
> < genqsat.F90
> < gengrid_vars.f90
> < get_derivatives.F90
> < get_derivatives2.F90
> < get_gefs_ensperts_dualres.F90
> < getprs.f90
> < getuv.F90
> < getvvel.f90
> < gridmod.F90
> < gsi_4dvar.f90
> < gsi_bundlemod.F90
> < gsi_enscouplermod.f90
> < gsi_chemguess_mod.F90
> < gsi_io.f90
> < gsi_metguess_mod.F90
> < gsimod.F90
> < guess_grids.f90
> < hybrid_ensemble_parameters.f90
> < hybrid_ensemble_isotropic.F90
> < jfunc.f90
> < m_kinds.F90
> < looplimits.f90
> < m_berror_stats.f90
> < m_grid2sub1var.f90
> < m_gsibec.F90
> < m_nc_berror.f90
> < m_spline.f90
> < mpeu_mpif.F90
> < mpeu_util.F90
> < m_fitcons.f90
> < m_plib8mat1.f90
> < m_plib8mat2.f90
> < m_mpimod.F90
> < mpl_allreduce.F90
> < m_rerank.f90
> < m_rf.f90
> < m_set_eta.F90
> < m_stats.f90
> < normal_rh_to_q.f90
> < outgrads1.f90
> < plib8.f90
> < polcarf.f90
> < prewgt.F90
> < raflib.f90
> < rfdpar.f90
> < rsearch.F90
> < simpin1.f90
> < simpin1_init.f90
> < smooth_polcarf.f90
> < smoothrf.F90
> < smoothwwrf.f90
> < smoothzrf.f90
> < state_vectors.f90
> < stop1.f90
> < stub_bacio_mod.F90
> < stub_ensmod.f90
> < stub_get_pseudo_ensperts.f90
> < tendsmod.f90
> < tpause.f90
> < tpause_t.F90
> < tv_to_tsen.f90
> < write_bkgvars_grid.F90
> < m_gbc4saber.f90
> < xhat_vordivmod.f90
> < directDA_radaruse_mod.f90
> < m_berror_stats_reg.F90
> < rapidrefresh_cldsurf_mod.f90
> < chemmod.f90
> < radarZ_global_module.f90
> < fv3_regional_interface.f90
> < gsi_rfv3io_mod.f90
> < mod_fv3_lola.f90
> < grdcrd.f90
> < prewgt_reg.f90
> < )
> < 
> < list(APPEND gsitlnmc_src_files_list
> < calctends_ad.F90
> < calctends_tl.F90
> < calctends_no_ad.F90
> < calctends_no_tl.F90
> < get_semimp_mats.f90
> < mod_strong.f90
> < mod_vtrans.F90
> < psichi2uvt_reg.f90
> < psichi2uv_reg.f90
> < rtlnmc_version3.f90
> < strong_bal_correction.f90
> < strong_baldiag_inc.f90
> < strong_fast_global_mod.f90
> < turblmod.f90
> < turbl_ad.f90
> < turbl_tl.f90
> < zrnmi_mod.f90
> < 
> < )
> < 
> < # Stubs for sp lib if package is not found
> < if( NOT sp_FOUND )
> <   list( APPEND gsi_src_files_list stub_sp.f90 )
> ---
> > project(gsi
> >         VERSION 1.0.0
> >         LANGUAGES C Fortran)
> > 
> > list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
> > set(CMAKE_DIRECTORY_LABELS ${PROJECT_NAME})
> > 
> > include(GNUInstallDirs)
> > 
> > if(NOT CMAKE_BUILD_TYPE MATCHES "^(Debug|Release|RelWithDebInfo|MinSizeRel)$")
> >   message(STATUS "Setting build type to 'Release' as none was specified.")
> >   set(CMAKE_BUILD_TYPE
> >       "Release"
> >       CACHE STRING "Choose the type of build." FORCE)
> >   set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release" "MinSizeRel" "RelWithDebInfo")
> 136c20,199
> < set( gsi_src_files
> ---
> > if(NOT CMAKE_C_COMPILER_ID MATCHES "^(GNU|Intel|Clang|AppleClang)$")
> >   message(WARNING "${CMAKE_C_COMPILER_ID} is not supported.")
> > endif()
> > 
> > if(NOT CMAKE_Fortran_COMPILER_ID MATCHES "^(GNU|Intel)$")
> >   message(WARNING "${CMAKE_Fortran_COMPILER_ID} is not supported.")
> > endif()
> > 
> > # User options
> > option(OPENMP "Enable OpenMP Threading" OFF)
> > option(ENABLE_MKL "Use MKL for LAPACK implementation (if available)" ON)
> > option(USE_GSDCLOUD "Use GSD Cloud Analysis library" OFF)
> > option(USE_MGBF "Use MGBF library" ON)
> > 
> > set(GSI_VALID_MODES "GFS" "Regional")
> > set(GSI_MODE "GFS" CACHE STRING "Choose the GSI Application.")
> > set_property(CACHE GSI_MODE PROPERTY STRINGS ${GSI_VALID_MODES})
> > 
> > # Ensure valid GSI_MODE is selected
> > if(NOT GSI_MODE IN_LIST GSI_VALID_MODES)
> >   message(FATAL_ERROR "GSI_MODE must be one of ${GSI_VALID_MODES}")
> > endif()
> > 
> > # Echo user options
> > message(STATUS "GSI: OPENMP ................. ${OPENMP}")
> > message(STATUS "GSI: ENABLE_MKL ............. ${ENABLE_MKL}")
> > message(STATUS "GSI: USE_GSDCLOUD ........... ${USE_GSDCLOUD}")
> > message(STATUS "GSI: USE_MGBF ............... ${USE_MGBF}")
> > message(STATUS "GSI: GSI_MODE ............... ${GSI_MODE}")
> > 
> > # Dependencies
> > if(ENABLE_MKL)
> >   find_package(MKL)
> > endif()
> > if(MKL_FOUND)
> >   set(LAPACK_LIBRARIES ${MKL_LIBRARIES})
> > else()
> >   set(ENABLE_MKL OFF CACHE INTERNAL "GSI: Disable MKL since it was NOT FOUND")
> >   find_package(LAPACK REQUIRED)
> > endif()
> > find_package(MPI REQUIRED)
> > find_package(NetCDF REQUIRED Fortran)
> > if(OPENMP)
> >   find_package(OpenMP REQUIRED)
> > endif()
> > 
> > # NCEPLibs dependencies
> > find_package(bacio REQUIRED)
> > find_package(sigio REQUIRED)
> > find_package(sfcio REQUIRED)
> > find_package(nemsio REQUIRED)
> > find_package(ncio REQUIRED)
> > find_package(ncdiag REQUIRED)
> > find_package(sp REQUIRED)
> > find_package(ip REQUIRED)
> > find_package(w3emc REQUIRED)
> > find_package(bufr REQUIRED)
> > find_package(crtm REQUIRED)
> > if(GSI_MODE MATCHES "Regional")
> >   find_package(wrf_io REQUIRED)
> > endif()
> > 
> > # See https://github.com/NOAA-EMC/NCEPLIBS-nemsio/pull/22
> > target_link_libraries(nemsio::nemsio INTERFACE w3emc::w3emc_d bacio::bacio_4)
> > 
> > # GSD Cloud Analysis library dependency
> > if(USE_GSDCLOUD)
> >   if(NOT TARGET gsdcloud)
> >     find_package(gsdcloud REQUIRED)
> >   endif()
> > endif()
> > 
> > # MGBF library dependency
> > if(USE_MGBF)
> >   if(NOT TARGET mgbf)
> >     find_package(mgbf REQUIRED)
> >   endif()
> > endif()
> > 
> > # Get compiler flags for the GSI application
> > include(gsiapp_compiler_flags)
> > 
> > # Get the list of all source files
> > include(gsi_files.cmake)
> > 
> > # Collect common files for GSI Fortran library
> > list(APPEND GSI_SRC_Fortran
> >   ${GSI_SRC_srcs}
> >   ${GSI_SRC_class})
> > 
> > # Collect files for specific GSI Application
> > if(GSI_MODE MATCHES "GFS") # GFS GSI application
> >   list(APPEND GSI_SRC_Fortran
> >     ${GSI_SRC_gfs_stub}
> >     ${GSI_SRC_fixture_gfs})
> > elseif(GSI_MODE MATCHES "Regional") # Regional GSI application
> >   list(APPEND GSI_SRC_Fortran
> >     ${GSI_SRC_regional_cplr}
> >     ${GSI_SRC_fixture_regional})
> > endif()
> > 
> > # Compiler options and definitions
> > list(APPEND GSI_C_defs
> >   FortranByte=char
> >   FortranInt=int
> >   funder
> >   "FortranLlong=long long")
> > 
> > list(APPEND GSI_Fortran_defs _REAL8_)
> > if(CMAKE_Fortran_COMPILER_ID MATCHES "^(Intel)$")
> >   list(APPEND GSI_Fortran_defs POUND_FOR_STRINGIFY)
> > endif()
> > if(USE_GSDCLOUD)
> >   list(APPEND GSI_Fortran_defs RR_CLOUDANALYSIS)
> > endif()
> > 
> > # Create a library of GSI C sources
> > add_library(gsi_c_obj OBJECT ${GSI_SRC_C})
> > target_compile_definitions(gsi_c_obj PRIVATE ${GSI_C_defs})
> > 
> > # Create a library of GSI Fortran sources
> > set(module_dir "${CMAKE_CURRENT_BINARY_DIR}/include/gsi")
> > add_library(gsi_fortran_obj OBJECT ${GSI_SRC_Fortran})
> > set_target_properties(gsi_fortran_obj PROPERTIES Fortran_MODULE_DIRECTORY "${module_dir}")
> > target_include_directories(gsi_fortran_obj INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
> >                                                      $<BUILD_INTERFACE:${module_dir}>
> >                                                      $<INSTALL_INTERFACE:include/gsi>)
> > target_compile_definitions(gsi_fortran_obj PRIVATE ${GSI_Fortran_defs})
> > target_link_libraries(gsi_fortran_obj PUBLIC NetCDF::NetCDF_Fortran)
> > target_link_libraries(gsi_fortran_obj PUBLIC MPI::MPI_Fortran)
> > target_link_libraries(gsi_fortran_obj PUBLIC ${LAPACK_LIBRARIES})
> > target_link_libraries(gsi_fortran_obj PUBLIC bacio::bacio_4)
> > target_link_libraries(gsi_fortran_obj PUBLIC sigio::sigio)
> > target_link_libraries(gsi_fortran_obj PUBLIC sfcio::sfcio)
> > target_link_libraries(gsi_fortran_obj PUBLIC nemsio::nemsio)
> > target_link_libraries(gsi_fortran_obj PUBLIC ncio::ncio)
> > target_link_libraries(gsi_fortran_obj PUBLIC w3emc::w3emc_d)
> > target_link_libraries(gsi_fortran_obj PUBLIC sp::sp_d)
> > target_link_libraries(gsi_fortran_obj PUBLIC bufr::bufr_d)
> > target_link_libraries(gsi_fortran_obj PUBLIC crtm::crtm)
> > if(GSI_MODE MATCHES "Regional")
> >   target_link_libraries(gsi_fortran_obj PUBLIC wrf_io::wrf_io)
> > endif()
> > target_link_libraries(gsi_fortran_obj PUBLIC ncdiag::ncdiag)
> > if(USE_GSDCLOUD)
> >   if(TARGET gsdcloud)
> >     add_dependencies(gsi_fortran_obj gsdcloud)
> >   endif()
> >   target_link_libraries(gsi_fortran_obj PUBLIC gsdcloud::gsdcloud)
> > endif()
> > if(USE_MGBF)
> >   if(TARGET mgbf)
> >     add_dependencies(gsi_fortran_obj mgbf)
> >   endif()
> >   target_link_libraries(gsi_fortran_obj PUBLIC mgbf::mgbf)
> > endif()
> > if(OpenMP_Fortran_FOUND)
> >   target_link_libraries(gsi_fortran_obj PRIVATE OpenMP::OpenMP_Fortran)
> > endif()
> > 
> > # Create the GSI library
> > add_library(gsi STATIC)
> > add_library(${PROJECT_NAME}::gsi ALIAS gsi)
> > set_target_properties(gsi PROPERTIES Fortran_MODULE_DIRECTORY "${module_dir}")
> > target_include_directories(gsi PUBLIC $<BUILD_INTERFACE:${module_dir}>
> >                                       $<INSTALL_INTERFACE:include/gsi>)
> > target_link_libraries(gsi PUBLIC gsi_c_obj)
> > target_link_libraries(gsi PUBLIC gsi_fortran_obj)
> > if(OpenMP_Fortran_FOUND)
> >   target_link_libraries(gsi PRIVATE OpenMP::OpenMP_Fortran)
> > endif()
> > 
> > # Create the GSI executable
> > add_executable(gsi.x ${GSI_SRC_main})
> > add_dependencies(gsi.x gsi)
> > set_target_properties(gsi.x PROPERTIES Fortran_MODULE_DIRECTORY "${module_dir}")
> > target_link_libraries(gsi.x PRIVATE gsi)
> > if(OpenMP_Fortran_FOUND)
> >   target_link_libraries(gsi.x PRIVATE OpenMP::OpenMP_Fortran)
> > endif()
> 138,139c201,202
> < ${gsi_src_files_list}
> < ${gsitlnmc_src_files_list}
> ---
> > # Install Fortran modules
> > install(DIRECTORY ${module_dir} DESTINATION ${CMAKE_INSTALL_PREFIX}/include)
> 141,142c204,205
> < PARENT_SCOPE
> < )
> ---
> > # Install executable targets
> > install(TARGETS gsi.x RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
> 143a207,238
> > # Install and export library targets
> > install(
> >   TARGETS gsi_c_obj gsi_fortran_obj gsi
> >   EXPORT ${PROJECT_NAME}Exports
> >   LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
> >   ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
> > 
> > # Package config
> > include(CMakePackageConfigHelpers)
> > set(CONFIG_INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME})
> > 
> > export(EXPORT ${PROJECT_NAME}Exports
> >        NAMESPACE ${PROJECT_NAME}::
> >        FILE ${PROJECT_NAME}-targets.cmake)
> > 
> > configure_package_config_file(
> >   ${CMAKE_CURRENT_SOURCE_DIR}/cmake/PackageConfig.cmake.in ${CMAKE_BINARY_DIR}/${PROJECT_NAME}-config.cmake
> >   INSTALL_DESTINATION ${CONFIG_INSTALL_DESTINATION})
> > install(FILES ${CMAKE_BINARY_DIR}/${PROJECT_NAME}-config.cmake
> >         DESTINATION ${CONFIG_INSTALL_DESTINATION})
> > 
> > write_basic_package_version_file(
> >   ${CMAKE_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
> >   VERSION ${PROJECT_VERSION}
> >   COMPATIBILITY AnyNewerVersion)
> > install(FILES ${CMAKE_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
> >         DESTINATION ${CONFIG_INSTALL_DESTINATION})
> > 
> > install(EXPORT ${PROJECT_NAME}Exports
> >         NAMESPACE ${PROJECT_NAME}::
> >         FILE ${PROJECT_NAME}-targets.cmake
> >         DESTINATION ${CONFIG_INSTALL_DESTINATION})
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cmaq_routines.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: coinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: combine_radobs.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: co_mop_ak.f90
> diff -r ./compact_diffs.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/compact_diffs.f90
> 61c61
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 73,75c73,75
> < ! public :: xdcirdp
> < ! public :: xmulbv
> < ! public :: xbacbv
> ---
> >   public :: xdcirdp
> >   public :: xmulbv
> >   public :: xbacbv
> 77,82c77,82
> < ! public :: ydsphdp
> < ! public :: ymulbv
> < ! public :: ybacbv
> < ! public :: tydsphdp
> < ! public :: ybacvb
> < ! public :: ymulvb
> ---
> >   public :: ydsphdp
> >   public :: ymulbv
> >   public :: ybacbv
> >   public :: tydsphdp
> >   public :: ybacvb
> >   public :: ymulvb
> 84,89c84,89
> < ! public :: cdcoef
> < ! public :: dfcd
> < ! public :: aldub
> < ! public :: dlinvmm
> < ! public :: dlufm
> < ! public :: dlubmm
> ---
> >   public :: cdcoef
> >   public :: dfcd
> >   public :: aldub
> >   public :: dlinvmm
> >   public :: dlufm
> >   public :: dlubmm
> 96c96
> < ! public :: lbcox1,lacox1,lbcox2,lacoy1,lacox2,lbcoy1,lcy,lacoy2,lbcoy2
> ---
> >   public :: lbcox1,lacox1,lbcox2,lacoy1,lacox2,lbcoy1,lcy,lacoy2,lbcoy2
> 102c102
> <   logical,save :: compdiff_initialized_=.false.
> ---
> >   logical,save :: initialized_=.false.
> 118c118
> <     created = compdiff_initialized_
> ---
> >     created = initialized_
> 123c123
> <     inited = compdiff_initialized_ .and. inisphed_
> ---
> >     inited = initialized_ .and. inisphed_
> 178c178
> <   if(compdiff_initialized_) return
> ---
> >   if(initialized_) return
> 180c180
> <   compdiff_initialized_=.true.
> ---
> >   initialized_=.true.
> 213c213
> <     if(.not.compdiff_initialized_) return
> ---
> >     if(.not.initialized_) return
> 215c215
> <     compdiff_initialized_=.false.
> ---
> >     initialized_=.false.
> 271d270
> <   real(r_kind),dimension(nlon):: grid3n,grid3s,grid1n,grid1s
> 317,326c316,319
> <   polnu=polnu/float(nlon)
> <   polnv=polnv/float(nlon)
> <   polsu=polsu/float(nlon)
> <   polsv=polsv/float(nlon)
> <   do ix=1,nlon
> <      grid3n(ix)= polnu*coslon(ix)+polnv*sinlon(ix)
> <      grid1n(ix)=-polnu*sinlon(ix)+polnv*coslon(ix)
> <      grid3s(ix)= polsu*coslon(ix)+polsv*sinlon(ix)
> <      grid1s(ix)= polsu*sinlon(ix)-polsv*coslon(ix)
> <   end do
> ---
> >   polnu=polnu/real(nlon,r_kind)
> >   polnv=polnv/real(nlon,r_kind)
> >   polsu=polsu/real(nlon,r_kind)
> >   polsv=polsv/real(nlon,r_kind)
> 329,339c322,324
> <      do i=1,nlat
> <         if(i /= 1 .and. i /= nlat)then
> <            work(1,i,j)=grid3(i-1,j)
> <            work(2,i,j)=grid1(i-1,j)
> <         else if(i == 1)then
> <            work(1,i,j)=grid3s(j)
> <            work(2,i,j)=grid1s(j)
> <         else
> <            work(1,i,j)=grid3n(j)
> <            work(2,i,j)=grid1n(j)
> <         end if
> ---
> >      do i=2,nlat-1
> >         work(1,i,j)=grid3(i-1,j)
> >         work(2,i,j)=grid1(i-1,j)
> 341c326,330
> <   enddo
> ---
> >      work(1,1,j)= polsu*coslon(j)+polsv*sinlon(j)
> >      work(2,1,j)= polsu*sinlon(j)-polsv*coslon(j)
> >      work(1,nlat,j)= polnu*coslon(j)+polnv*sinlon(j)
> >      work(2,nlat,j)= -polnu*sinlon(j)+polnv*coslon(j)
> >   end do
> 466c455
> <   rnlon = one/float(nlon)
> ---
> >   rnlon = one/real(nlon,r_kind)
> 752,762c741,743
> <      do i=1,nlat
> <         if(i /= 1 .and. i /= nlat)then
> <            grid3(i-1,j)=work(1,i,j)
> <            grid1(i-1,j)=work(2,i,j)
> <         else if(i == 1)then
> <            grid3s(j)=work(1,i,j)
> <            grid1s(j)=work(2,i,j)
> <         else
> <            grid3n(j)=work(1,i,j)
> <            grid1n(j)=work(2,i,j)
> <         end if
> ---
> >      do i=2,nlat-1
> >         grid3(i-1,j)=work(1,i,j)
> >         grid1(i-1,j)=work(2,i,j)
> 763a745,748
> >      grid3s(j)=work(1,1,j)
> >      grid1s(j)=work(2,1,j)
> >      grid3n(j)=work(1,nlat,j)
> >      grid1n(j)=work(2,nlat,j)
> 776,779c761,764
> <   polnu=polnu/float(nlon)
> <   polsu=polsu/float(nlon)
> <   polnv=polnv/float(nlon)
> <   polsv=polsv/float(nlon)
> ---
> >   polnu=polnu/real(nlon,r_kind)
> >   polsu=polsu/real(nlon,r_kind)
> >   polnv=polnv/real(nlon,r_kind)
> >   polsv=polsv/real(nlon,r_kind)
> 818,826c803,806
> <      do i=1,nlat
> <         if(i /= 1 .and. i /= nlat)then
> < !          NOTE:  Adjoint of first derivative is its negative
> <            work(1,i,j)=-(a(i-1,j)+d(i-1,j))
> <            work(2,i,j)=-(b(i-1,j)+c(i-1,j))
> <         else
> <            work(1,i,j)=zero
> <            work(2,i,j)=zero
> <         end if
> ---
> >      do i=2,nlat-1
> > !       NOTE:  Adjoint of first derivative is its negative
> >         work(1,i,j)=-(a(i-1,j)+d(i-1,j))
> >         work(2,i,j)=-(b(i-1,j)+c(i-1,j))
> 827a808,811
> >      work(1,1,j)=zero
> >      work(2,1,j)=zero
> >      work(1,nlat,j)=zero
> >      work(2,nlat,j)=zero
> 1319c1303
> <   if(.not.compdiff_initialized_) call die(myname_,'coef not created')
> ---
> >   if(.not.initialized_) call die(myname_,'coef not created')
> 1376c1360
> <   pi2onx=pi/float(nxh)
> ---
> >   pi2onx=pi/real(nxh,r_kind)
> 1378c1362
> <      coef(lacoy1+ix-1)=(float(ix)-half)*pi2onx
> ---
> >      coef(lacoy1+ix-1)=(real(ix,r_kind)-half)*pi2onx
> 1999,2002c1983,1986
> <      polnu=two*polnu/float(nlon)
> <      polnv=two*polnv/float(nlon)
> <      polsu=two*polsu/float(nlon)
> <      polsv=two*polsv/float(nlon)
> ---
> >      polnu=two*polnu/real(nlon,r_kind)
> >      polnv=two*polnv/real(nlon,r_kind)
> >      polsu=two*polsu/real(nlon,r_kind)
> >      polsv=two*polsv/real(nlon,r_kind)
> 2092,2095c2076,2079
> <      polnu=two*polnu/float(nlon)
> <      polnv=two*polnv/float(nlon)
> <      polsu=two*polsu/float(nlon)
> <      polsv=two*polsv/float(nlon)
> ---
> >      polnu=two*polnu/real(nlon,r_kind)
> >      polnv=two*polnv/real(nlon,r_kind)
> >      polsu=two*polsu/real(nlon,r_kind)
> >      polsv=two*polsv/real(nlon,r_kind)
> 2233,2236c2217,2220
> <      polnu=two*polnu/float(nlon)
> <      polnv=two*polnv/float(nlon)
> <      polsu=two*polsu/float(nlon)
> <      polsv=two*polsv/float(nlon)
> ---
> >      polnu=two*polnu/real(nlon,r_kind)
> >      polnv=two*polnv/real(nlon,r_kind)
> >      polsu=two*polsu/real(nlon,r_kind)
> >      polsv=two*polsv/real(nlon,r_kind)
> 2333,2336c2317,2320
> <      polnu=two*polnu/float(nlon)
> <      polnv=two*polnv/float(nlon)
> <      polsu=two*polsu/float(nlon)
> <      polsv=two*polsv/float(nlon)
> ---
> >      polnu=two*polnu/real(nlon,r_kind)
> >      polnv=two*polnv/real(nlon,r_kind)
> >      polsu=two*polsu/real(nlon,r_kind)
> >      polsv=two*polsv/real(nlon,r_kind)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: compute_derived.f90
> Only in ./: compute_derived.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: compute_fact10.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: compute_qvar3d.f90
> Only in ./: compute_qvar3d.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: configure
> diff -r ./constants.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/constants.f90
> 34d33
> < !   2020-07-17 Todling   - redefined constoz (in agreement w/ Haixia); not sure where previous value came from!
> 50c49
> <   use m_kinds, only: r_single,r_kind,i_kind,r_quad,i_long
> ---
> >   use kinds, only: r_single,r_kind,i_kind,r_quad,i_long
> 58,59d56
> <   public :: final_constants_derived
> <   public :: final_constants
> 86,88d82
> <   public :: kPa_per_Pa
> <   public :: Pa_per_kPa
> < 
> 93a88,91
> > ! ------ EFSOI relevant parameters -------- !
> >   public :: tref, pref
> >   public :: constants_initialized
> > 
> 96c94
> <   integer(i_kind), parameter :: max_varname_length=32
> ---
> >   integer(i_kind), parameter :: max_varname_length=20
> 120,121c118,119
> <   real(r_kind),parameter::  kPa_per_Pa = 0.001_r_kind            ! convert from Pa to cb
> <   real(r_kind),parameter::  Pa_per_kPa = 1000._r_kind            ! convert from cb to Pa
> ---
> >   real(r_kind),parameter::  tref   = 2.8000e+2_r_kind            ! reference T for total energy
> >   real(r_kind),parameter::  pref   = 1.0000e+5_r_kind            ! reference P for total energy
> 245d242
> < ! real(r_kind),parameter::  qmin = 1.e-7_r_kind  !lower bound on ges_q
> 248,249c245
> < ! real(r_kind),parameter::  constoz = 604229.0_r_kind ! Where did this come from?
> <   real(r_kind),parameter::  constoz = 603447.6_r_kind ! ((28.9644 g/mol o3)/((47.9982 g/mol air))*1e6(mol/mol)
> ---
> >   real(r_kind),parameter::  constoz = 604229.0_r_kind
> 297,298c293,294
> <   logical :: cnts_derived_initialized_=.false.
> <   logical :: cnts_initialized_=.false.
> ---
> > ! Constants initialized
> >   logical :: constants_initialized = .true.
> 325,326d320
> <     if(cnts_derived_initialized_) return
> < 
> 345d338
> <     cnts_derived_initialized_=.true.
> 349,352d341
> <   subroutine final_constants_derived
> <     cnts_derived_initialized_=.false.
> <   end subroutine final_constants_derived
> < 
> 388,389d376
> <     if(cnts_initialized_) return
> < 
> 450d436
> <     cnts_initialized_=.true.
> 453,456d438
> < 
> <   subroutine final_constants
> <     cnts_initialized_=.false.
> <   end subroutine final_constants
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: control2model_ad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: control2model.f90
> Only in ./: control2state_ad.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: control2state.f90
> Only in ./: control2state.F90
> diff -r ./control_vectors.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/control_vectors.f90
> 35a36,37
> > !   2019-09-13  martin   - added incvars_to_zero variable for writing out fv3 netCDF increments
> > !   2019-10-28  martin   - added incvars_zero_strat variable for zeroing out increments above tropopause
> 75,76c77,78
> < use m_kinds, only: r_kind,r_double,r_single,i_kind,r_quad
> < use m_mpimod, only: gsi_mpi_comm_world,mpi_max,mpi_rtype,mype,npe,ierror
> ---
> > use kinds, only: r_kind,r_double,r_single,i_kind,r_quad
> > use mpimod, only: mpi_comm_world,mpi_max,mpi_rtype,mype,npe,ierror
> 78,81c80,81
> < !_RTuse gsi_4dvar, only: iadatebgn
> < !_RT use file_utility, only : get_lun
> < use mpeu_util, only: get_lun => luavail
> < use mpeu_util, only: warn
> ---
> > use gsi_4dvar, only: iadatebgn
> > use file_utility, only : get_lun
> 83c83
> < use hybrid_ensemble_parameters, only: l_hyb_ens
> ---
> > use hybrid_ensemble_parameters, only: beta_s0,l_hyb_ens
> 85a86
> > use gridmod, only : minmype
> 115c116
> <      final_anacv
> ---
> >      final_anacv,c2sset_flg,e2sset_flg
> 129,130d129
> < public be3d        ! normalized scale factor for ensemble background error 3d-variables
> < public be2d        ! normalized scale factor for ensemble background error 2d-variables
> 134a134
> > public nrf2_loc,nrf3_loc,nmotl_loc   ! what are these for??
> 136a137,140
> > public :: incvars_to_zero ! array of fieldnames to zero out increments for
> > public :: incvars_zero_strat ! array of fieldnames to zero out increments above tropopause
> > public :: incvars_efold ! scale factor x in which e^(-(k-ktrop)/x) for above fields
> > 
> 144c148
> <    type(GSI_Bundle), pointer :: aens(:,:)
> ---
> >    type(GSI_Bundle), pointer :: aens(:,:,:)
> 156c160,161
> < logical :: lsqrtb,lcalc_gfdl_cfrac  
> ---
> > logical,save :: lsqrtb,lcalc_gfdl_cfrac  
> > logical :: c2sset_flg,e2sset_flg  
> 160a166
> > integer(i_kind),allocatable,dimension(:):: nrf2_loc,nrf3_loc,nmotl_loc
> 173,175d178
> < real(r_kind)    ,allocatable,dimension(:) :: be3d
> < real(r_kind)    ,allocatable,dimension(:) :: be2d
> < real(r_kind)    ,allocatable,dimension(:) :: bemo ! not public; not needed
> 179a183,185
> > character(len=12),allocatable,dimension(:) :: incvars_to_zero 
> > character(len=12),allocatable,dimension(:) :: incvars_zero_strat 
> > real(r_kind) :: incvars_efold
> 262a269
> >   llinit = .true.
> 273c280
> < subroutine init_anacv(rcname)
> ---
> > subroutine init_anacv
> 293a301
> > use hybrid_ensemble_parameters,only:idaen3d,idaen2d
> 295,297c303,304
> < character(len=*),optional,intent(in) :: rcname
> < !character(len=*),parameter:: rcname_def='anavinfo.txt'
> < character(len=*),parameter:: rcname_def='anavinfo'  ! filename should have extension
> ---
> > !character(len=*),parameter:: rcname='anavinfo.txt'
> > character(len=*),parameter:: rcname='anavinfo'  ! filename should have extension
> 303d309
> < integer(i_kind) ioflag
> 305,310c311
> < real(r_kind) aas,amp,bes
> < 
> < if(llinit) then
> <   if(mype==0) call warn(myname_,': CV already initialized')
> <   return
> < endif
> ---
> > real(r_kind) aas,amp
> 314,318c315
> < if(present(rcname)) then
> <   open(luin,file=trim(rcname),form='formatted')
> < else
> <   open(luin,file=rcname_def,form='formatted')
> < endif
> ---
> > open(luin,file=rcname,form='formatted')
> 337,340c334
> <    read(utable(ii),*,IOSTAT=ioflag) var, ilev, itracer, aas, amp, source, funcof, bes
> <    if (ioflag/=0) then
> <       read(utable(ii),*) var, ilev, itracer, aas, amp, source, funcof
> <    endif
> ---
> >    read(utable(ii),*) var, ilev, itracer, aas, amp, source, funcof
> 354d347
> < allocate(be3d(nc3d),be2d(nc2d),bemo(mvars))
> 357a351,356
> > allocate(idaen3d(nc3d),idaen2d(nc2d))
> > allocate(incvars_to_zero(nvars))
> > allocate(incvars_zero_strat(nvars))
> > incvars_to_zero(:) = 'NONE'
> > incvars_zero_strat(:) = 'NONE'
> > incvars_efold = 5.0_r_kind
> 361c360
> < allocate(nrf_3d(nrf))
> ---
> > allocate(nrf_3d(nrf),nrf2_loc(nc2d),nrf3_loc(nc3d),nmotl_loc(max(1,mvars)))
> 367,371c366
> <    read(utable(ii),*,IOSTAT=ioflag) var, ilev, itracer, aas, amp, source, funcof, bes
> <    if (ioflag/=0) then
> <       read(utable(ii),*) var, ilev, itracer, aas, amp, source, funcof
> <       bes=-one
> <    endif
> ---
> >    read(utable(ii),*) var, ilev, itracer, aas, amp, source, funcof
> 374a370
> >        nmotl_loc(mvars)=ii
> 376d371
> <        bemo(mvars)=bes
> 380a376
> >          nrf2_loc(nc2d)=ii  ! rid of soon
> 382c378,382
> <          be2d(nc2d)=bes
> ---
> >          if(itracer>10) then
> >             idaen2d(nc2d)=2
> >          else
> >             idaen2d(nc2d)=1
> >          endif
> 385a386
> >          nrf3_loc(nc3d)=ii  ! rid of soon
> 388c389,393
> <          be3d(nc3d)=bes
> ---
> >          if(itracer>10) then
> >             idaen3d(nc3d)=2
> >          else
> >             idaen3d(nc3d)=1
> >          endif
> 413c418,419
> < llinit = .true.
> ---
> > c2sset_flg = .true.   ! set to true in setup.  set to false after first (only) call to c2sset
> > e2sset_flg = .true.   ! set to true in setup.  set to false after first (only) call to ensctl2state_set
> 418,419c424,426
> <   deallocate(evars2d,evars3d)
> <   deallocate(nrf_3d)
> ---
> >   deallocate(nrf_var)
> >   deallocate(nrf_3d,nrf2_loc,nrf3_loc,nmotl_loc)
> >   deallocate(as3d,as2d)
> 423,426c430,431
> <   deallocate(be3d,be2d,bemo)
> <   deallocate(as3d,as2d)
> <   deallocate(nrf_var,cvars2d,cvars3d)
> <   llinit=.false.
> ---
> >   deallocate(cvars2d,cvars3d)
> >   deallocate(evars2d,evars3d)
> 458a464,465
> >   use hybrid_ensemble_parameters, only: grd_ens
> >   use hybrid_ensemble_parameters, only: naensgrp
> 461a469
> >   integer(i_kind) :: ig
> 494,495c502,503
> <       ALLOCATE(ycv%aens(nsubwin,n_ens))
> <          call GSI_GridCreate(ycv%grid_aens,grd_ens%lat2,grd_ens%lon2,grd_ens%nsig)
> ---
> >       ALLOCATE(ycv%aens(nsubwin,naensgrp,n_ens))
> >       call GSI_GridCreate(ycv%grid_aens,grd_ens%lat2,grd_ens%lon2,grd_ens%nsig)
> 515c523
> <              call stop2(106)
> ---
> >              call stop2(109)
> 528c536
> <                 call stop2(107)
> ---
> >                 call stop2(109)
> 537,545c545,554
> <          do nn=1,n_ens
> <             ycv%aens(jj,nn)%values => ycv%values(ii+1:ii+n_aens)
> <             write(bname,'(a,i3.3,a,i4.4)') 'Ensemble Control Bundle subwin-',jj,' and member-',nn
> <             call GSI_BundleSet(ycv%aens(jj,nn),ycv%grid_aens,bname,ierror,names3d=ltmp,bundle_kind=r_kind)
> <             if (ierror/=0) then
> <                 write(6,*)'allocate_cv: error alloc(ensemble bundle)'
> <                 call stop2(108)
> <             endif
> <             ndim=ndim+ycv%aens(jj,nn)%ndim
> ---
> >          do ig=1,naensgrp
> >             do nn=1,n_ens
> >                ycv%aens(jj,ig,nn)%values => ycv%values(ii+1:ii+n_aens)
> >                write(bname,'(a,i3.3,a,i4.4)') 'Ensemble Control Bundle subwin-',jj,' and member-',nn
> >                call GSI_BundleSet(ycv%aens(jj,ig,nn),ycv%grid_aens,bname,ierror,names3d=ltmp,bundle_kind=r_kind)
> >                if (ierror/=0) then
> >                   write(6,*)'allocate_cv: error alloc(ensemble bundle)'
> >                   call stop2(109)
> >                endif
> >                ndim=ndim+ycv%aens(jj,ig,nn)%ndim
> 547c556,557
> <             ii=ii+n_aens
> ---
> >                ii=ii+n_aens
> >             enddo
> 554,561c564,567
> <   if (nsclen>0) then
> <      ycv%predr => ycv%values(ii+1:ii+nsclen)
> <      ii=ii+nsclen
> <   endif
> <   if (npclen>0) then
> <      ycv%predp => ycv%values(ii+1:ii+npclen)
> <      ii=ii+npclen
> <   endif
> ---
> >   ycv%predr => ycv%values(ii+1:ii+nsclen)
> >   ii=ii+nsclen
> >   ycv%predp => ycv%values(ii+1:ii+npclen)
> >   ii=ii+npclen
> 568c574
> <      write(6,*)'allocate_cv: error length',ii,nclen,n_step,n_aens
> ---
> >      write(6,*)'allocate_cv: error length',ii,nclen
> 605d610
> <   ycv=zero
> 637a643
> >   use hybrid_ensemble_parameters, only: naensgrp
> 640a647
> >   integer(i_kind) :: ig
> 645,646c652,655
> <            do nn=n_ens,1,-1
> <               call GSI_BundleUnset(ycv%aens(ii,nn),ierror)
> ---
> >            do ig=1,naensgrp
> >               do nn=n_ens,1,-1
> >                  call GSI_BundleUnset(ycv%aens(ii,ig,nn),ierror)
> >               enddo
> 862a872
> >   use hybrid_ensemble_parameters, only: naensgrp
> 865a876
> >   integer(i_kind) :: ig,nigtmp
> 876,878c887,891
> <         do nn=1,n_ens
> <            do ii=1,nsubwin
> <               qdot_prod_sub=qdot_prod_sub+qdot_product( xcv%aens(ii,nn)%values(:) ,ycv%aens(ii,nn)%values(:) )
> ---
> >         do ig=1,naensgrp
> >            do nn=1,n_ens
> >               do ii=1,nsubwin
> >                  qdot_prod_sub=qdot_prod_sub+qdot_product( xcv%aens(ii,ig,nn)%values(:) ,ycv%aens(ii,ig,nn)%values(:) )
> >               end do
> 882a896,901
> >      m3d=xcv%step(1)%n3d
> >      m2d=xcv%step(1)%n2d
> >      itot=max(m3d,0)+max(m2d,0)
> >      if(l_hyb_ens)itot=itot+n_ens*naensgrp
> >      allocate(partsum(itot))
> >      partsum=zero_quad
> 884,888d902
> <         m3d=xcv%step(ii)%n3d
> <         m2d=xcv%step(ii)%n2d
> <         itot=max(m3d,0)+max(m2d,0)
> <         if(l_hyb_ens)itot=itot+n_ens
> <         allocate(partsum(itot))
> 891c905
> <            partsum(i) = dplevs(xcv%step(ii)%r3(i)%q,ycv%step(ii)%r3(i)%q,ihalo=1)
> ---
> >            partsum(i) = partsum(i)+dplevs(xcv%step(ii)%r3(i)%q,ycv%step(ii)%r3(i)%q,ihalo=1)
> 895c909
> <            partsum(m3d+i) = dplevs(xcv%step(ii)%r2(i)%q,ycv%step(ii)%r2(i)%q,ihalo=1)
> ---
> >            partsum(m3d+i) = partsum(m3d+i)+dplevs(xcv%step(ii)%r2(i)%q,ycv%step(ii)%r2(i)%q,ihalo=1)
> 897a912,913
> >            do ig=1,naensgrp
> >               nigtmp=n_ens*(ig-1)
> 899,900c915,918
> <            do i = 1,n_ens
> <               partsum(m3d+m2d+i) = dplevs(xcv%aens(ii,i)%r3(1)%q,ycv%aens(ii,i)%r3(1)%q,ihalo=1)
> ---
> >               do i = 1,n_ens
> >                  partsum(m3d+m2d+nigtmp+i) = partsum(m3d+m2d+nigtmp+i) + &
> >                         dplevs(xcv%aens(ii,ig,i)%r3(1)%q,ycv%aens(ii,ig,i)%r3(1)%q,ihalo=1)
> >               end do
> 906d923
> <         deallocate(partsum)
> 907a925
> >      deallocate(partsum)
> 911c929
> <   if(mype == 0)then
> ---
> >   if(mype == minmype)then
> 950a969
> >   use hybrid_ensemble_parameters, only: naensgrp
> 956d974
> <   real(r_quad) :: zz(nsubwin)
> 958a977,978
> >   integer(i_kind) :: ig
> >   integer(i_kind) ::ngtmp,nn0
> 961d980
> <   zz(:)=zero_quad
> 967c986
> <            zz(ii)=zz(ii)+qdot_product( xcv%step(ii)%values(:) ,ycv%step(ii)%values(:) )
> ---
> >            prods(ii)=prods(ii)+qdot_product( xcv%step(ii)%values(:) ,ycv%step(ii)%values(:) )
> 971,973c990,994
> <         do nn=1,n_ens
> <            do ii=1,nsubwin
> <               zz(ii)=zz(ii)+qdot_product( xcv%aens(ii,nn)%values(:) ,ycv%aens(ii,nn)%values(:) )
> ---
> >         do ig=1,naensgrp
> >            do nn=1,n_ens
> >               do ii=1,nsubwin
> >                  prods(ii)=prods(ii)+qdot_product( xcv%aens(ii,ig,nn)%values(:) ,ycv%aens(ii,ig,nn)%values(:) )
> >               end do
> 978a1000,1002
> >         m3d=xcv%step(1)%n3d
> >         m2d=xcv%step(1)%n2d
> >         allocate(partsum(m2d+m3d))
> 980,982d1003
> <            m3d=xcv%step(ii)%n3d
> <            m2d=xcv%step(ii)%n2d
> <            allocate(partsum(m2d+m3d))
> 992c1013
> <               zz(ii)=zz(ii) + partsum(i)
> ---
> >               prods(ii)=prods(ii) + partsum(i)
> 994d1014
> <            deallocate(partsum)
> 995a1016
> >         deallocate(partsum)
> 998,1009c1019,1034
> <         do ii=1,nsubwin ! RTod: somebody could work in opt/zing this ...
> <            allocate(partsum(n_ens))
> < !$omp parallel do  schedule(dynamic,1) private(nn,m3d,m2d)
> <            do nn=1,n_ens
> <               partsum(nn) = zero_quad
> <               m3d=xcv%aens(ii,nn)%n3d
> <               do i = 1,m3d
> <                  partsum(nn)= partsum(nn) + dplevs(xcv%aens(ii,nn)%r3(i)%q,ycv%aens(ii,nn)%r3(i)%q,ihalo=1)
> <               enddo
> <               m2d=xcv%aens(ii,nn)%n2d
> <               do i = 1,m2d
> <                  partsum(nn)= partsum(nn) + dplevs(xcv%aens(ii,nn)%r2(i)%q,ycv%aens(ii,nn)%r2(i)%q,ihalo=1)
> ---
> >         allocate(partsum(n_ens*naensgrp))
> >         do ii=1,nsubwin 
> > !$omp parallel do  schedule(dynamic,1) private(nn,m3d,m2d,ig,ngtmp,nn0)
> >            do ig=1,naensgrp
> >               ngtmp=(ig-1)*n_ens
> >               do nn=1,n_ens
> >                  nn0=nn+ngtmp
> >                  partsum(nn0) = zero_quad
> >                  m3d=xcv%aens(ii,ig,nn)%n3d
> >                  do i = 1,m3d
> >                     partsum(nn0)= partsum(nn0) + dplevs(xcv%aens(ii,ig,nn)%r3(i)%q,ycv%aens(ii,ig,nn)%r3(i)%q,ihalo=1)
> >                  enddo
> >                  m2d=xcv%aens(ii,ig,nn)%n2d
> >                  do i = 1,m2d
> >                     partsum(nn0)= partsum(nn0) + dplevs(xcv%aens(ii,ig,nn)%r2(i)%q,ycv%aens(ii,ig,nn)%r2(i)%q,ihalo=1)
> >                  enddo
> 1011,1013d1035
> <            enddo
> <            do nn=1,n_ens
> <              zz(ii)=zz(ii)+partsum(nn)
> 1015c1037,1039
> <            deallocate(partsum)
> ---
> >            do nn=1,n_ens*naensgrp
> >               prods(ii)=prods(ii)+partsum(nn)
> >            end do
> 1016a1041
> >         deallocate(partsum)
> 1020,1022d1044
> <   call mpl_allreduce(nsubwin,qpvals=zz)
> <   prods(1:nsubwin) = zz(1:nsubwin)
> < 
> 1024c1046
> <   if(trim(eb) == 'cost_b') then
> ---
> >   if(mype == minmype .and. trim(eb) == 'cost_b' ) then
> 1026c1048
> <         prods(nsubwin+1) = prods(nsubwin+1) + qdot_product(xcv%predr(:),ycv%predr(:))
> ---
> >         prods(nsubwin+1) = qdot_product(xcv%predr(:),ycv%predr(:))
> 1035a1058,1060
> >   call mpl_allreduce(nsubwin+1,qpvals=prods)
> > 
> > 
> 1208c1233
> <      write(6,*)sgrep,' global  norm =',real(zt,r_kind)
> ---
> >      write(6,*)sgrep,' global  norm =',zt
> 1263c1288
> <                           vnum(iv),gsi_mpi_comm_world)
> ---
> >                           vnum(iv),MPI_comm_world)
> 1285c1310
> <                           vnum(iv),gsi_mpi_comm_world)
> ---
> >                           vnum(iv),MPI_comm_world)
> 1343c1368
> < subroutine random_cv(ycv,kseed,iadatebgn)
> ---
> > subroutine random_cv(ycv,kseed)
> 1365a1391
> > use hybrid_ensemble_parameters, only: naensgrp
> 1368d1393
> < integer(i_kind), optional, intent(in   ) :: iadatebgn
> 1373a1399
> > integer(i_kind) :: ig
> 1375,1379c1401
> < if(present(iadatebgn)) then
> <   iseed=iadatebgn
> < else
> <   iseed=17760704
> < endif
> ---
> > iseed=iadatebgn
> 1404,1407c1426,1431
> <       do jj=1,nsubwin
> <          call random_number(zz)
> <          do ii=1,nval_lenz_en
> <             ycv%aens(jj,nn)%values(ii) = two*zz(ii)-one
> ---
> >       do ig=1,naensgrp
> >          do jj=1,nsubwin
> >             call random_number(zz)
> >             do ii=1,nval_lenz_en
> >                ycv%aens(jj,ig,nn)%values(ii) = two*zz(ii)-one
> >             enddo
> 1602c1626
> < call mpi_allreduce(zloc,zglo,1,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> > call mpi_allreduce(zloc,zglo,1,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convb_ps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convb_q.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convb_t.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convb_uv.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: converr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: converr_ps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: converr_pw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: converr_q.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: converr_t.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: converr_uv.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convthin.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: convthin_time.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: correlated_obsmod.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_get_fv3_regional_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_get_pseudo_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_get_wrf_mass_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_get_wrf_nmm_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_gfs_ensmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_gfs_nstmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_read_wrf_mass_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_read_wrf_mass_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_read_wrf_nmm_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_read_wrf_nmm_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_regional_io.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_wrf_binary_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_wrf_netcdf_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_wrwrfmassa.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cplr_wrwrfnmma.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: crtm_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cvsection.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: cwhydromod.f90
> diff -r ./derivsmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/derivsmod.f90
> 14a15,16
> > !   2019-05-08 eliu - recover logic (drv_set_) to indicate the derivative
> > !                     vars are allocated and defined
> 26a29
> > !  drv_set_                - flag indicating the variables are allocated and defined 
> 34,35c37,38
> < use m_kinds, only: i_kind, r_kind
> < use m_mpimod, only: mype
> ---
> > use kinds, only: i_kind, r_kind
> > use mpimod, only: mype
> 52d54
> < use mpeu_util, only: die
> 57a60
> > public :: drv_set_         
> 70d72
> < public :: final_anadv
> 73d74
> < logical :: llinit = .false.
> 87a89
> > logical,save :: drv_set_=.false.  
> 91c93
> < subroutine init_anadv(rcname)
> ---
> > subroutine init_anadv
> 104a107,108
> > !   2019-05-08  eliu     - recover logic (drv_set_) to indicate the derivative
> > !                          vars are allocated and defined
> 120,122c124
> < character(len=*),optional,intent(in) :: rcname
> < 
> < character(len=*),parameter:: rcname_def='anavinfo'
> ---
> > character(len=*),parameter:: rcname='anavinfo'
> 134c136
> < if(llinit) return 
> ---
> > if(drv_set_) return 
> 136,140c138
> < if(present(rcname)) then
> <  open(newunit=luin,file=trim(rcname),form='formatted')
> < else
> <  open(newunit=luin,file=trim(rcname_def),form='formatted')
> < endif
> ---
> > open(newunit=luin,file=trim(rcname),form='formatted')
> 144a143,146
> > if(nrows==0) then
> >    if(luin/=5) close(luin)
> >    return
> > endif
> 172,176c174,175
> < allocate(dvars2d(n2d))
> < allocate(dvars3d(n3d))
> < allocate(dsrcs2d(n2d))
> < allocate(dsrcs3d(n3d))
> < allocate(levels(n3d))
> ---
> > allocate(dvars2d(n2d),dvars3d(n3d),&
> >          dsrcs2d(n2d),dsrcs3d(n3d),levels(n3d))
> 238,239c237,238
> <     if(n2d>0.or.n3d>0) write(6,*) myname_,':  DERIVATIVE VARIABLES: '
> <     if(n2d>0) write(6,*) myname_,':  2D-DERV STATE VARIABLES: '
> ---
> >     write(6,*) myname_,':  DERIVATIVE VARIABLES: '
> >     write(6,*) myname_,':  2D-DERV STATE VARIABLES: '
> 243c242
> <     if(n3d>0) write(6,*) myname_,':  3D-DERV STATE VARIABLES:'
> ---
> >     write(6,*) myname_,':  3D-DERV STATE VARIABLES:'
> 250c249
> < llinit=.true.  
> ---
> > drv_set_=.true.  
> 315,317d313
> < ! destroy derivative grid
> < ! call GSI_GridDestroy()
> < 
> 345c341
> <   use m_mpimod, only: gsi_mpi_comm_world
> ---
> >   use mpimod, only: mpi_comm_world
> 348c344,345
> <   character(len=*), parameter :: myname_ = 'destroy_ges_derivatives'
> ---
> > 
> >   if(.not.drv_initialized) return
> 353,354d349
> <   if(.not.drv_initialized) return
> < 
> 362d356
> <         call die(myname_,'y-derivative not properly destroyed')
> 369d362
> <         call die(myname_,'x-derivative not properly destroyed')
> 375,376c368,372
> <   if(associated(gsi_xderivative_bundle)) deallocate(gsi_xderivative_bundle)
> <   if(associated(gsi_yderivative_bundle)) deallocate(gsi_yderivative_bundle)
> ---
> >   deallocate(gsi_xderivative_bundle)
> >   deallocate(gsi_yderivative_bundle)
> > 
> > ! destroy derivative grid
> > ! call GSI_GridDestroy(grid,lat2,lon2,nsig)
> 378c374,375
> <   drv_initialized=.false.
> ---
> >   deallocate(dvars2d,dvars3d,&
> >              dsrcs2d,dsrcs3d,levels)
> 383,393d379
> <   subroutine final_anadv
> < 
> <   if(allocated(dvars2d)) deallocate(dvars2d)
> <   if(allocated(dvars3d)) deallocate(dvars3d)
> <   if(allocated(dsrcs2d)) deallocate(dsrcs2d)
> <   if(allocated(dsrcs3d)) deallocate(dsrcs3d)
> <   if(allocated(levels))  deallocate(levels)
> <   llinit=.false.
> < 
> <   end subroutine final_anadv
> < 
> 436c422
> <        if(.not.allocated(qsatg)) allocate(qsatg(lat2,lon2,nsig),&
> ---
> >        allocate(qsatg(lat2,lon2,nsig),&
> 454c440
> <     if(.not.allocated(cwgues)) allocate(cwgues(lat2,lon2,nsig))
> ---
> >     allocate(cwgues(lat2,lon2,nsig))
> 463c449
> <     if(.not.allocated(cfgues)) allocate(cfgues(lat2,lon2,nsig))
> ---
> >     allocate(cfgues(lat2,lon2,nsig))
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: deter_sfc_mod.f90
> diff -r ./directDA_radaruse_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/directDA_radaruse_mod.f90
> 7c7
> <   use m_kinds, only: r_kind,i_kind, r_double
> ---
> >   use kinds, only: r_kind,i_kind, r_double
> 9c9
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 252c252
> < !     use m_mpimod, only: mype
> ---
> > !     use mpimod, only: mype
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: dtast.f90
> diff -r ./egrid2agrid_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/egrid2agrid_mod.f90
> 65c65
> <    use m_kinds, only: r_kind,i_kind,r_double,r_single
> ---
> >    use kinds, only: r_kind,i_kind,r_double,r_single
> 342,345c342
> <             if(.not.associated(e2a%twin)) allocate(e2a%twin(1,1))
> <             if(.not.associated(e2a%itwin)) allocate(e2a%itwin(1,1))
> <             if(.not.associated(e2a%ntwin)) allocate(e2a%ntwin(1))
> <             if(.not.associated(e2a%swin)) allocate(e2a%swin(1,1))
> ---
> >             allocate(e2a%twin(1,1),e2a%itwin(1,1),e2a%ntwin(1),e2a%swin(1,1))
> 1398c1395
> <       use m_mpimod, only: mype
> ---
> >       use mpimod, only: mype
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: enorm_state.f90
> diff -r ./en_perts_io.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/en_perts_io.f90
> 29,30c29,30
> <   use m_mpimod, only: ierror,mype
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use mpimod, only: ierror,mype
> >   use kinds, only: r_kind,i_kind,r_single
> 35,36c35,36
> <   use m_mpimod, only: gsi_mpi_comm_world,ierror,mype,mpi_rtype,mpi_mode_rdonly
> <   use m_mpimod, only: mpi_rtype,mpi_info_null,mpi_offset_kind
> ---
> >   use mpimod, only: mpi_comm_world,ierror,mype,mpi_rtype,mpi_mode_rdonly
> >   use mpimod, only: mpi_rtype,mpi_info_null,mpi_offset_kind
> 85c85
> <      call mpi_file_open(gsi_mpi_comm_world,trim(filename), &
> ---
> >      call mpi_file_open(mpi_comm_world,trim(filename), &
> 127c127
> <         call gsi_bundlegetpointer(en_perts(n,1),trim(cvars3d(ic3)),w3,istatus)
> ---
> >         call gsi_bundlegetpointer(en_perts(n,1,1),trim(cvars3d(ic3)),w3,istatus)
> 145c145
> <         call gsi_bundlegetpointer(en_perts(n,1),trim(cvars2d(ic2)),w2,istatus)
> ---
> >         call gsi_bundlegetpointer(en_perts(n,1,1),trim(cvars2d(ic2)),w2,istatus)
> 192,193c192,193
> <   use m_mpimod, only: mype
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use mpimod, only: mype
> >   use kinds, only: r_kind,i_kind,r_single
> 224c224
> <         call gsi_bundlegetpointer(en_perts(n,1),trim(cvars3d(ic3)),w3,istatus)
> ---
> >         call gsi_bundlegetpointer(en_perts(n,1,1),trim(cvars3d(ic3)),w3,istatus)
> 241c241
> <         call gsi_bundlegetpointer(en_perts(n,1),trim(cvars2d(ic2)),w2,istatus)
> ---
> >         call gsi_bundlegetpointer(en_perts(n,1,1),trim(cvars2d(ic2)),w2,istatus)
> 288,289c288,289
> <   use m_mpimod, only: mype
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use mpimod, only: mype
> >   use kinds, only: r_kind,i_kind,r_single
> 291a292
> >   use hybrid_ensemble_parameters, only: nsclgrp
> 302a304,307
> >   if(nsclgrp>1) then
> >     write(6,*)"nsclgrp >1 is not considerred in this part, stop"
> >     stop
> >   endif
> 315c320
> <         call gsi_bundlegetpointer(en_perts(n,1),trim(cvars3d(ic3)),w3,istatus)
> ---
> >         call gsi_bundlegetpointer(en_perts(n,1,1),trim(cvars3d(ic3)),w3,istatus)
> 327c332
> <         call gsi_bundlegetpointer(en_perts(n,1),trim(cvars2d(ic2)),w2,istatus)
> ---
> >         call gsi_bundlegetpointer(en_perts(n,1,1),trim(cvars2d(ic2)),w2,istatus)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ensctl2model_ad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ensctl2model.f90
> Only in ./: ensctl2state_ad.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ensctl2state.f90
> Only in ./: ensctl2state.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ens_spread_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: evaljgrad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: evaljo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: evalqlim.f90
> diff -r ./fgrid2agrid_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/fgrid2agrid_mod.f90
> 56c56
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: fill_mass_grid2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: fill_nmm_grid2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: fpvsx_ad.f90
> diff -r ./fv3_regional_interface.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/fv3_regional_interface.f90
> 29c29
> <   use m_kinds, only: r_single,r_kind,i_kind
> ---
> >   use kinds, only: r_single,r_kind,i_kind
> diff -r ./general_commvars_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/general_commvars_mod.f90
> 22,23c22,23
> < !   def s2g4    - used in get_derivatives2.f90
> < !   def s1g4    - used in get_derivatives2.f90 (uv versions)
> ---
> > !   def s2g4    - used in get_derivatives2.f90 
> > !   def s1g4    - used in get_derivatives2.f90 
> 36c36
> <    use m_kinds, only: r_kind,i_kind
> ---
> >    use kinds, only: r_kind,i_kind
> 38d37
> <    use constants, only : max_varname_length
> 44d42
> <    save
> 46,47d43
> <    public :: init_general_commvars_dims
> <    public :: final_general_commvars_dims
> 70,73d65
> <    interface init_general_commvars_dims
> <      module procedure init_dims_
> <    end interface init_general_commvars_dims
> < 
> 81c73
> <    type(sub2grid_info) :: s2g_raf,s2g_cv,s2g2,s1q4,s1g4,s2g4,s2guv,s2g_d,g1,g3,g33p1
> ---
> >    type(sub2grid_info),save :: s2g_raf,s2g_cv,s2g2,s1q4,s1g4,s2g4,s2guv,s2g_d,g1,g3,g33p1
> 83,91d74
> <    integer :: mvars
> <    character(len=max_varname_length),allocatable,dimension(:) :: nrf_var
> <    character(len=max_varname_length),allocatable,dimension(:) :: cvars2d
> <    character(len=max_varname_length),allocatable,dimension(:) :: cvars3d
> <    character(len=max_varname_length),allocatable,dimension(:) :: evars2d
> <    character(len=max_varname_length),allocatable,dimension(:) :: evars3d
> <    character(len=max_varname_length),allocatable,dimension(:) :: cvarsmd
> <    character(len=max_varname_length),allocatable,dimension(:) :: dvars2d
> <    character(len=max_varname_length),allocatable,dimension(:) :: dvars3d
> 96,138d78
> <    subroutine init_dims_ (cvars2d_in,cvars3d_in,cvarsmd_in,nrf_var_in, &
> <                           dvars2d_in, dvars3d_in )
> < !  Todling: Add to relax code dependency
> <    character(len=*),intent(in) :: cvars2d_in(:),cvars3d_in(:),cvarsmd_in(:),nrf_var_in(:)
> <    character(len=*),intent(in) :: dvars2d_in(:),dvars3d_in(:)
> <    
> <    if(size(cvars2d_in)>=0) then
> <      if(.not.allocated(cvars2d)) allocate(cvars2d(size(cvars2d_in)))
> <      cvars2d = cvars2d_in
> <    endif
> <    if(size(cvars3d_in)>=0) then
> <      if(.not.allocated(cvars3d)) allocate(cvars3d(size(cvars3d_in)))
> <      cvars3d = cvars3d_in
> <    endif
> <    if(size(cvarsmd_in)>=0) then
> <       if(.not.allocated(cvarsmd)) allocate(cvarsmd(size(cvarsmd_in)))
> <       cvarsmd = cvarsmd_in
> <    endif
> <    if(size(nrf_var_in)>=0) then
> <      if(.not.allocated(nrf_var)) allocate(nrf_var(size(nrf_var_in)))
> <      nrf_var = nrf_var_in
> <    endif
> < 
> <    if(size(dvars2d_in)>=0) then
> <      if(.not.allocated(dvars2d)) allocate(dvars2d(size(dvars2d_in)))
> <      dvars2d = dvars2d_in
> <    endif
> <    if(size(dvars3d_in)>=0) then
> <      if(.not.allocated(dvars3d)) allocate(dvars3d(size(dvars3d_in)))
> <      dvars3d = dvars3d_in
> <    endif
> < 
> <    end subroutine init_dims_
> < 
> <    subroutine final_general_commvars_dims
> <    if(allocated(dvars3d)) deallocate(dvars3d)
> <    if(allocated(dvars2d)) deallocate(dvars2d)
> <    if(allocated(cvarsmd)) deallocate(cvarsmd)
> <    if(allocated(nrf_var)) deallocate(nrf_var)
> <    if(allocated(cvars3d)) deallocate(cvars3d)
> <    if(allocated(cvars2d)) deallocate(cvars2d)
> <    end subroutine final_general_commvars_dims
> <   
> 151a92,93
> > !   2018-05-09  eliu - construct variable s2g_d for derivatives when derivative variables
> > !                      are set (drv_set_ = .true.)   
> 166c108,110
> <       use m_mpimod, only: npe,levs_id,nvar_id,nvar_pe
> ---
> >       use mpimod, only: npe,levs_id,nvar_id,nvar_pe
> >       use control_vectors, only: cvars2d,cvars3d,mvars,cvarsmd,nrf_var
> >       use derivsmod, only: dvars2d, dvars3d, drv_set_ 
> 173c117
> <       integer(i_kind) i,j,k,kk,num_fields,inner_vars,l,n,n_one,n2d,n3d,mvars
> ---
> >       integer(i_kind) i,j,k,kk,num_fields,inner_vars,l,n,n_one,n2d,n3d
> 191d134
> <       mvars=size(cvarsmd)
> 217,218d159
> <       deallocate(names_s2g_raf,lnames_s2g_raf)
> < 
> 223,225c164,165
> <       if(.not.allocated(levs_id)) allocate(levs_id(nsig1o))
> <       if(.not.allocated(nvar_id)) allocate(nvar_id(nsig1o))
> <       if(.not.allocated(nvar_pe)) allocate(nvar_pe(s2g_raf%num_fields,2))
> ---
> >       allocate(levs_id(nsig1o),nvar_id(nsig1o))
> >       allocate(nvar_pe(s2g_raf%num_fields,2))
> 250,251c190
> <       if(.not.allocated(ltosi)) allocate(ltosi(nlat*nlon))
> <       if(.not.allocated(ltosj)) allocate(ltosj(nlat*nlon))
> ---
> >       allocate(ltosi(nlat*nlon),ltosj(nlat*nlon))
> 259,260c198
> <       if(.not.allocated(ltosi_s)) allocate(ltosi_s(itotsub))
> <       if(.not.allocated(ltosj_s)) allocate(ltosj_s(itotsub))
> ---
> >       allocate(ltosi_s(itotsub),ltosj_s(itotsub))
> 273,274c211
> <       if (allocated(dvars2d).and.allocated(dvars3d).and. &
> <          size(dvars2d)+size(dvars3d)>0) then 
> ---
> >       if (drv_set_) then 
> 278d214
> <          if(num_fields>0) then
> 282,301c218,235
> <            allocate(names_s2g_d(inner_vars,num_fields),vector_s2g_d(num_fields))
> < !                   bundlemod stores 3d fields first, followed by 2d fields, followed by 1d fields
> <            i=0
> <            do k=1,size(dvars3d)
> <               do j=1,nsig
> <                  i=i+1
> <                  names_s2g_d(1,i)=dvars3d(k)
> <                  vector_s2g_d(i)=names_s2g_d(1,i) == 'u'.or.names_s2g_d(1,i) == 'v'
> <               end do
> <            end do
> <            do k=1,size(dvars2d)
> <               i=i+1
> <               names_s2g_d(1,i)=dvars2d(k)
> <               vector_s2g_d(i)=names_s2g_d(1,i) == 'u'.or.names_s2g_d(1,i) == 'v'
> <            end do
> <            call general_sub2grid_create_info(s2g_d,inner_vars,nlat,nlon,nsig,num_fields,regional, &
> <                                           vector=vector_s2g_d,names=names_s2g_d,s_ref=s2g_raf)
> <            deallocate(names_s2g_d,vector_s2g_d)
> < 
> <          endif ! num_fields
> ---
> >          allocate(names_s2g_d(inner_vars,num_fields),vector_s2g_d(num_fields))
> > !                 bundlemod stores 3d fields first, followed by 2d fields, followed by 1d fields
> >          i=0
> >          do k=1,size(dvars3d)
> >             do j=1,nsig
> >                i=i+1
> >                names_s2g_d(1,i)=dvars3d(k)
> >                vector_s2g_d(i)=names_s2g_d(1,i) == 'u'.or.names_s2g_d(1,i) == 'v'
> >             end do
> >          end do
> >          do k=1,size(dvars2d)
> >             i=i+1
> >             names_s2g_d(1,i)=dvars2d(k)
> >             vector_s2g_d(i)=names_s2g_d(1,i) == 'u'.or.names_s2g_d(1,i) == 'v'
> >          end do
> >          call general_sub2grid_create_info(s2g_d,inner_vars,nlat,nlon,nsig,num_fields,regional, &
> >                                         vector=vector_s2g_d,names=names_s2g_d,s_ref=s2g_raf)
> >          deallocate(names_s2g_d,vector_s2g_d)
> 324c258,259
> < !  create general_sub2grid structure variable s2g4, which is used in get_derivatives2.f90
> ---
> > !  create general_sub2grid structure variable s2g4, which is used in
> > !  get_derivatives2.f90
> 417c352
> <        use m_mpimod, only: levs_id,nvar_id,nvar_pe
> ---
> >        use mpimod, only: levs_id,nvar_id,nvar_pe
> 420,426c355,356
> <        deallocate(ltosj_s)
> <        deallocate(ltosi_s)
> <        deallocate(ltosj)
> <        deallocate(ltosi)
> <        deallocate(nvar_pe)
> <        deallocate(nvar_id)
> <        deallocate(levs_id)
> ---
> >        deallocate(ltosi,ltosj,ltosi_s,ltosj_s)
> >        deallocate(levs_id,nvar_id,nvar_pe)
> 589c519
> <    rnlon=one/float(nlon)
> ---
> >    rnlon=one/real(nlon,r_kind)
> 694c624
> <    rnlon=one/float(nlon)
> ---
> >    rnlon=one/real(nlon,r_kind)
> 806,809c736,739
> <    polnu=polnu/float(nlon)
> <    polnv=polnv/float(nlon)
> <    polsu=polsu/float(nlon)
> <    polsv=polsv/float(nlon)
> ---
> >    polnu=polnu/real(nlon,r_kind)
> >    polnv=polnv/real(nlon,r_kind)
> >    polsu=polsu/real(nlon,r_kind)
> >    polsv=polsv/real(nlon,r_kind)
> 919,922c849,852
> <    polnu=polnu/float(nlon)
> <    polnv=polnv/float(nlon)
> <    polsu=polsu/float(nlon)
> <    polsv=polsv/float(nlon)
> ---
> >    polnu=polnu/real(nlon,r_kind)
> >    polnv=polnv/real(nlon,r_kind)
> >    polsu=polsu/real(nlon,r_kind)
> >    polsv=polsv/real(nlon,r_kind)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_read_fv3atm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_read_gfsatm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_read_nemsaero.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_read_nmmb.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_read_nmmb_radar.f90
> diff -r ./general_specmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/general_specmod.f90
> 59c59
> <   use m_kinds, only: r_kind,r_double,i_kind
> ---
> >   use kinds, only: r_kind,r_double,i_kind
> diff -r ./general_spectral_transforms.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/general_spectral_transforms.f90
> 30c30
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 89c89
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 102c102
> <      spec_work(i)=spectral_in(i)/float(grd%nlon)
> ---
> >      spec_work(i)=spectral_in(i)/real(grd%nlon,r_kind)
> 177c177
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 242c242
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 280c280
> <      spec_work(i)=spec_work(i)*float(grd%nlon)
> ---
> >      spec_work(i)=spec_work(i)*real(grd%nlon,r_kind)
> 326c326
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 371,372c371
> <   gnlon=float(grd%nlon)
> < ! gnlon=real(grd%nlon,r_kind)
> ---
> >   gnlon=real(grd%nlon,r_kind)
> 402d400
> <   return
> 437c435
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 510c508
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 526,527c524,525
> <      spcwrk1(i)=dsp(i)/float(grd%nlon)
> <      spcwrk2(i)=zsp(i)/float(grd%nlon)
> ---
> >      spcwrk1(i)=dsp(i)/real(grd%nlon,r_kind)
> >      spcwrk2(i)=zsp(i)/real(grd%nlon,r_kind)
> 615c613
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 676c674
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 740c738
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 819c817
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 870,871c868,869
> <      spcwrk1(i)=spcwrk1(i)*float(grd%nlon)
> <      spcwrk2(i)=spcwrk2(i)*float(grd%nlon)
> ---
> >      spcwrk1(i)=spcwrk1(i)*real(grd%nlon,r_kind)
> >      spcwrk2(i)=spcwrk2(i)*real(grd%nlon,r_kind)
> 930c928
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1017c1015
> <  use m_kinds, only: r_kind,i_kind
> ---
> >  use kinds, only: r_kind,i_kind
> 1102c1100
> <  use m_kinds, only: r_kind,i_kind
> ---
> >  use kinds, only: r_kind,i_kind
> 1284c1282
> <  use m_kinds, only: r_kind,i_kind
> ---
> >  use kinds, only: r_kind,i_kind
> 1454c1452
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./general_sub2grid_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/general_sub2grid_mod.f90
> 50c50
> < !   2013-08-03  todling  - protect write-out with verbose (set to false)
> ---
> > !   2013-08-03  todling  - protect write-out with print_verbose (set to false)
> 68c68
> <    use m_kinds, only: r_double,i_kind,i_long,r_single,r_kind
> ---
> >    use kinds, only: r_double,i_kind,i_long,r_single,r_kind
> 86d85
> <    public :: general_deter_subdomain_withLayout ! TEMPORARY _RT
> 90a90
> >      module procedure general_sub2grid_r_single_rank13
> 100a101
> >      module procedure general_grid2sub_r_single_rank31
> 201a203
> >     
> 204a207
> >    logical :: print_verbose=.false.
> 211c214
> <                                            vector,names,lnames,nskip,s_ref,verbose)
> ---
> >                                            vector,names,lnames,nskip,s_ref)
> 267,269c270,271
> <       use m_kinds, only: r_single
> <       use m_mpimod, only: gsi_mpi_comm_world
> <       use m_mpimod, only: mype
> ---
> >       use kinds, only: r_single
> >       use mpimod, only: mpi_comm_world
> 280d281
> <       logical,        optional,intent(in   ) :: verbose
> 284d284
> <       logical :: verbose_
> 286,291c286,287
> <       verbose_=.false.
> <       if(present(verbose)) then
> <          verbose_=verbose
> <       endif
> <       call mpi_comm_size(gsi_mpi_comm_world,s%npe,ierror)
> <       call mpi_comm_rank(gsi_mpi_comm_world,s%mype,ierror)
> ---
> >       call mpi_comm_size(mpi_comm_world,s%npe,ierror)
> >       call mpi_comm_rank(mpi_comm_world,s%mype,ierror)
> 330,331c326
> <             s%periodic,s%periodic_s,s%lon1,s%lon2,s%lat1,s%lat2,s%ilat1,s%istart,s%jlon1,s%jstart,&
> <             verbose_)
> ---
> >             s%periodic,s%periodic_s,s%lon1,s%lon2,s%lat1,s%lat2,s%ilat1,s%istart,s%jlon1,s%jstart)
> 439c434
> <          call get_iuse_pe(s%npe,s%num_fields,idoit,verbose_)
> ---
> >          call get_iuse_pe(s%npe,s%num_fields,idoit)
> 441c436
> <          if(s%mype==0.and.verbose_) &
> ---
> >          if(s%mype==0.and.print_verbose) &
> 452,456c447
> <       if (npe_used/= 0) then ! _RT bug fix?
> <          num_loc_groups=s%num_fields/npe_used
> <       else
> <          num_loc_groups=0
> <       endif
> ---
> >       num_loc_groups=s%num_fields/npe_used
> 469c460
> <       if(s%mype == 0.and.verbose_) then
> ---
> >       if(s%mype == 0.and.print_verbose) then
> 514c505
> < subroutine get_iuse_pe(npe,nz,iuse_pe,verbose)
> ---
> > subroutine get_iuse_pe(npe,nz,iuse_pe)
> 517c508
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 522d512
> <   logical,        intent(in) :: verbose
> 534c524
> <           skip2=float(npe)/float(nskip)
> ---
> >           skip2=real(npe,r_kind)/real(nskip,r_kind)
> 550c540
> <         if(mype == 0 .and. verbose)write(6,*) ' in get_pe2 ',nz,icount,npe,skip2
> ---
> >         if(mype == 0 .and. print_verbose)write(6,*) ' in get_pe2 ',nz,icount,npe,skip2
> 580a571
> >       use mpimod, only: mpi_comm_world
> 584c575
> <       type(sub2grid_info),optional,intent(inout) :: s_ref
> ---
> >       type(sub2grid_info),optional,intent(in) :: s_ref
> 592,599c583,586
> < !           s_ref%ltosj   => NULL()
> < !           s_ref%ltosi   => NULL()
> < !           s_ref%ltosj_s => NULL()
> < !           s_ref%ltosi_s => NULL()
> <             if(associated(s_ref%ltosj_s)) deallocate(s_ref%ltosj_s)
> <             if(associated(s_ref%ltosi_s)) deallocate(s_ref%ltosi_s)
> <             if(associated(s_ref%ltosj)) deallocate(s_ref%ltosj)
> <             if(associated(s_ref%ltosi)) deallocate(s_ref%ltosi)
> ---
> >             s%ltosj   => NULL()
> >             s%ltosi   => NULL()
> >             s%ltosj_s => NULL()
> >             s%ltosi_s => NULL()
> 601,604c588
> <             if(associated(s%ltosj_s)) deallocate(s%ltosj_s)
> <             if(associated(s%ltosi_s)) deallocate(s%ltosi_s)
> <             if(associated(s%ltosj)) deallocate(s%ltosj)
> <             if(associated(s%ltosi)) deallocate(s%ltosi)
> ---
> >             deallocate(s%ltosj,s%ltosi,s%ltosj_s,s%ltosi_s)
> 612,613c596
> <                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart,&
> <                     verbose)
> ---
> >                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart)
> 643,644c626,627
> <   use m_kinds, only: i_kind
> <   use m_mpimod, only: nxPE, nyPE
> ---
> >   use kinds, only: i_kind
> >   use mpimod, only: nxPE, nyPE
> 654d636
> <   logical        ,intent(in   ) :: verbose
> 674c656
> <                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart,verbose)
> ---
> >                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart)
> 681c663
> <                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart,verbose)
> ---
> >                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart)
> 691,692c673
> <                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart, &
> <                     verbose)
> ---
> >                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart)
> 696c677
> <   use m_kinds, only: i_kind
> ---
> >   use kinds, only: i_kind
> 708d688
> <   logical,        intent(in   ) :: verbose
> 782a763,772
> >   if ( print_verbose ) then
> >      do k=1,nxpe*nype
> >         if(mype == 0) &
> >              write(6,100) k,istart(k),jstart(k),ilat1(k),jlon1(k)
> >      end do
> >   end if
> > 
> > 100 format('general_DETER_SUBDOMAIN_withlayout:  task,istart,jstart,ilat1,jlon1=',5(i6,1x))
> >   
> >         
> 791,799d780
> <   if ( verbose ) then
> <      do k=1,nxpe*nype
> < !       if(mype == 0) &
> <              write(6,100) k,istart(k),jstart(k),ilat1(k),jlon1(k),lat1*lon1
> <      end do
> <   end if
> < 100 format('general_DETER_SUBDOMAIN_withlayout:  task,istart,jstart,ilat1,jlon1=',6(i6,1x))
> <   
> < 
> 845,846c826
> <                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart,&
> <                     verbose)
> ---
> >                     periodic,periodic_s,lon1,lon2,lat1,lat2,ilat1,istart,jlon1,jstart)
> 888d867
> <       logical,        intent(in   ) :: verbose
> 902c881
> <       anperpe=float(npts)/float(npe)
> ---
> >       anperpe=real(npts,r_kind)/real(npe,r_kind)
> 939c918
> <             if(mype == 0 .and. verbose) &
> ---
> >             if(mype == 0 .and. print_verbose) &
> 1044a1024,1110
> >    subroutine general_sub2grid_r_single_rank13(s,sub_vars,grid_vars)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    general_sub2grid_r_single_rank4  convert from subdomains to full horizontal grid
> > !   prgmmr: parrish          org: np22                date: 2010-02-11
> > !
> > ! abstract: generalized version of sub2grid--uses only gsi module kinds.
> > !              All information needed is contained in the structure variable
> > !              "s", instead of various modules.  This allows
> > !              for easy adaptation for any collection/ordering of variables
> > !              defined on subdomains, which need to be made available on
> > !              full horizontal grid for horizontal operations.
> > !              The structure variable is specified by subroutine general_sub2grid_setup.
> > !              This version works with single precision (4-byte) real variables.
> > !              Input sub_vars, the desired arrays on horizontal subdomains, has one
> > !              halo row, for now, which is filled with zero, since for ensemble use,
> > !              there is no need for a halo, but is easiest for now to keep it.
> > !              A later version will have variable number of halo rows, filled with proper values.
> > !
> > ! program history log:
> > !   2010-02-11  parrish, initial documentation
> > !
> > !   input argument list:
> > !     s          - structure variable, contains all necessary information for
> > !                    moving this set of subdomain variables sub_vars to
> > !                    the corresponding set of full horizontal grid variables.
> > !     sub_vars   - input grid values in vertical subdomain mode (contains one halo row)
> > !
> > !   output argument list:
> > !     grid_vars  - output grid values in horizontal slab mode.
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$
> >       use mpimod, only: mpi_comm_world,mpi_real4
> >       implicit none
> > 
> >       type(sub2grid_info),intent(in   ) :: s
> >       real(r_single),     intent(in   ) :: sub_vars(s%lat2*s%lon2*s%num_fields)
> >       real(r_single),     intent(  out) :: grid_vars(s%nlat,s%nlon,s%kbegin_loc:s%kend_alloc)
> > 
> >       real(r_single) :: sub_vars_r4(s%lat2,s%lon2,s%num_fields)
> >       real(r_single) :: sub_vars0(s%lat1,s%lon1,s%num_fields)
> >       real(r_single) :: work(s%itotsub*(s%kend_alloc-s%kbegin_loc+1)) 
> >       integer(i_kind) iloc,iskip,i,i0,j,j0,k,n,k_in,ilat,jlon,ierror,ioffset
> > 
> >       sub_vars_r4  =  reshape(sub_vars,(/s%lat2,s%lon2,s%num_fields/))
> > !    remove halo row
> > !$omp parallel do  schedule(dynamic,1) private(k,j,j0,i0,i)
> >       do k=1,s%num_fields
> >          do j=2,s%lon2-1
> >             j0=j-1
> >             do i=2,s%lat2-1
> >                i0=i-1
> >                sub_vars0(i0,j0,k)=sub_vars_r4(i,j,k)
> >             end do
> >          end do
> >       end do
> > 
> >       call mpi_alltoallv(sub_vars0,s%recvcounts,s%rdispls,mpi_real4, &
> >                         work,s%sendcounts,s%sdispls,mpi_real4,mpi_comm_world,ierror)
> > 
> > 
> >       k_in=s%kend_loc-s%kbegin_loc+1
> > 
> > ! Load grid_vars array in desired order
> > !$omp parallel do  schedule(dynamic,1) private(k,iskip,iloc,n,i,ilat,jlon,ioffset)
> >       do k=s%kbegin_loc,s%kend_loc
> >          iskip=0
> >          iloc=0
> >          do n=1,s%npe
> >             if (n/=1) then
> >                iskip=iskip+s%ijn(n-1)*k_in
> >             end if
> >             ioffset=iskip+(k-s%kbegin_loc)*s%ijn(n)
> >             do i=1,s%ijn(n)
> >                iloc=iloc+1
> >                ilat=s%ltosi(iloc)
> >                jlon=s%ltosj(iloc)
> >                grid_vars(ilat,jlon,k)=work(i + ioffset)
> >             end do
> >          end do
> >       end do
> > 
> >    end subroutine general_sub2grid_r_single_rank13
> 1081c1147
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real4
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real4
> 1110c1176
> <                         work,s%sendcounts,s%sdispls,mpi_string,gsi_mpi_comm_world,ierror)
> ---
> >                         work,s%sendcounts,s%sdispls,mpi_string,mpi_comm_world,ierror)
> 1224a1291,1368
> >    subroutine general_grid2sub_r_single_rank31(s,grid_vars,sub_vars)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    general_sub2grid  convert from subdomains to full horizontal grid
> > !   prgmmr: parrish          org: np22                date: 2010-02-11
> > !
> > ! abstract: generalized version of grid2sub--uses only gsi module kinds.
> > !              All information needed is contained in the structure variable
> > !              "s", instead of various modules.  This allows
> > !              for easy adaptation for any collection/ordering of variables
> > !              defined on subdomains, which need to be made available on
> > !              full horizontal grid for horizontal operations.
> > !              The structure variable is specified by subroutine general_sub2grid_setup.
> > !              This version works with single precision (4-byte) real variables.
> > !              Output sub_vars, the desired arrays on horizontal subdomains, has one 
> > !              halo row, for now, which is filled with zero, since for ensemble use,
> > !              there is no need for a halo, but is easiest for now to keep it.
> > !              A later version will have variable number of halo rows, filled with proper values.
> > !
> > ! program history log:
> > !   2010-02-11  parrish, initial documentation
> > !   2010-03-02  parrish - remove setting halo to zero in output
> > !   2014-12-03  derber - make similar optimization changes already in code for
> > !                      double precision.
> > !
> > !   input argument list:
> > !     s          - structure variable, contains all necessary information for
> > !                    moving this set of subdomain variables sub_vars to
> > !                    the corresponding set of full horizontal grid variables.
> > !     grid_vars  - input grid values in horizontal slab mode.
> > !
> > !   output argument list:
> > !     sub_vars   - output grid values in vertical subdomain mode
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$
> >       use constants, only: zero
> >       use mpimod, only: mpi_comm_world,mpi_real4
> >       implicit none
> > 
> >       type(sub2grid_info),intent(in   ) :: s
> >       real(r_single), intent(in   )     :: grid_vars(s%nlat,s%nlon,s%kbegin_loc:s%kend_alloc)
> >       real(r_single),     intent(  out) :: sub_vars(s%lat2*s%lon2*s%num_fields)
> > 
> >       real(r_single) :: sub_vars_r4(s%lat2,s%lon2,s%num_fields)
> >       real(r_single) :: temp(s%itotsub*(s%kend_loc-s%kbegin_loc+1))
> >       integer(i_kind) iloc,i,ii,k,n,ilat,jlon,ierror,icount
> >       integer(i_kind),dimension(s%npe) ::iskip
> > 
> > !     reorganize for eventual distribution to local domains
> >       iskip(1)=0
> >       do n=2,s%npe
> >         iskip(n)=iskip(n-1)+s%ijn_s(n-1)*(s%kend_loc-s%kbegin_loc+1)
> >       end do
> > !$omp parallel do  schedule(dynamic,1) private(n,k,i,jlon,ii,ilat,iloc,icount)
> >       do k=s%kbegin_loc,s%kend_loc
> >          icount=0
> >          do n=1,s%npe
> >             iloc=iskip(n)+(k-s%kbegin_loc)*s%ijn_s(n)
> >             do i=1,s%ijn_s(n)
> >                iloc=iloc+1
> >                icount=icount+1
> >                ilat=s%ltosi_s(icount)
> >                jlon=s%ltosj_s(icount)
> >                temp(iloc)=grid_vars(ilat,jlon,k)
> >             end do
> >          end do
> >       end do
> > 
> > 
> >       call mpi_alltoallv(temp,s%sendcounts_s,s%sdispls_s,mpi_real4, &
> >                         sub_vars_r4,s%recvcounts_s,s%rdispls_s,mpi_real4,mpi_comm_world,ierror)
> > 
> >       sub_vars  =  reshape(sub_vars_r4,(/s%lat2*s%lon2*s%num_fields/))
> >    end subroutine general_grid2sub_r_single_rank31
> 1265c1409
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real4
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real4
> 1304c1448
> <                         sub_vars,s%recvcounts_s,s%rdispls_s,mpi_string,gsi_mpi_comm_world,ierror)
> ---
> >                         sub_vars,s%recvcounts_s,s%rdispls_s,mpi_string,mpi_comm_world,ierror)
> 1431c1575
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 1460c1604
> <                         work,s%sendcounts,s%sdispls,mpi_string,gsi_mpi_comm_world,ierror)
> ---
> >                         work,s%sendcounts,s%sdispls,mpi_string,mpi_comm_world,ierror)
> 1514c1658
> <       use m_kinds, only: r_single,i_kind
> ---
> >       use kinds, only: r_single,i_kind
> 1613c1757
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 1651c1795
> <                         sub_vars,s%recvcounts_s,s%rdispls_s,mpi_string,gsi_mpi_comm_world,ierror)
> ---
> >                         sub_vars,s%recvcounts_s,s%rdispls_s,mpi_string,mpi_comm_world,ierror)
> 1782c1926
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real4
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real4
> 1812c1956
> <                         work,s%ijn,s%displs_g,mpi_string,gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                         work,s%ijn,s%displs_g,mpi_string,gridpe,mpi_comm_world,ierror)
> 1959c2103
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 1989c2133
> <                         work,s%ijn,s%displs_g,mpi_string,gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                         work,s%ijn,s%displs_g,mpi_string,gridpe,mpi_comm_world,ierror)
> 2143c2287
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real4
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real4
> 2172c2316
> <                         sub_vars,s%ijn_s(s%mype+1),mpi_string,gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                         sub_vars,s%ijn_s(s%mype+1),mpi_string,gridpe,mpi_comm_world,ierror)
> 2298c2442
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 2327c2471
> <                         sub_vars,s%ijn_s(s%mype+1),mpi_string,gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                         sub_vars,s%ijn_s(s%mype+1),mpi_string,gridpe,mpi_comm_world,ierror)
> 2411c2555
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 2524c2668
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 2633c2777
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 2742c2886
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 2851c2995
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> 2963c3107
> <       use m_mpimod, only: gsi_mpi_comm_world,mpi_real8
> ---
> >       use mpimod, only: mpi_comm_world,mpi_real8
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_tll2xy_mod.f90
> diff -r ./general_transform.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/general_transform.f90
> 63c63
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 167c167
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 334c334
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 560c560
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 673c673
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 969c969
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1169c1169
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1358c1358
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1462c1462
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: general_write_gfsatm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: genex_mod.f90
> diff -r ./gengrid_vars.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gengrid_vars.f90
> 31c31
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 63c63
> <      anlon=float(nlon)
> ---
> >      anlon=real(nlon,r_kind)
> 69c69
> <         rlons(i)=float(i-1)*dlon
> ---
> >         rlons(i)=real(i-1,r_kind)*dlon
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: genqsat.f90
> Only in ./: genqsat.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: genstats_gps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gesinfo.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: getcount_bufr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: get_derivatives2.f90
> Only in ./: get_derivatives2.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: get_derivatives.f90
> Only in ./: get_derivatives.F90
> Only in ./: get.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: get_gefs_ensperts_dualres.f90
> Only in ./: get_gefs_ensperts_dualres.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: get_gefs_for_regional.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: get_nmmb_ensperts.f90
> diff -r ./getprs.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/getprs.f90
> 33c33
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 171c171
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 280c280
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 397c397
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 509c509
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 640c640
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> diff -r ./get_semimp_mats.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/get_semimp_mats.f90
> 35c35
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 302c302
> <         use m_kinds,only: r_kind,i_kind
> ---
> >         use kinds,only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: getsiga.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: getuv.f90
> Only in ./: getuv.F90
> diff -r ./getvvel.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/getvvel.f90
> 31c31
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 224c224
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 424c424
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gfs_stratosphere.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: glbsoi.f90
> diff -r ./grdcrd.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/grdcrd.f90
> 33c33
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 106c106
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 176c176
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./gridmod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gridmod.F90
> 14c14
> <   use m_kinds, only: i_byte,r_kind,r_single,i_kind
> ---
> >   use kinds, only: i_byte,r_kind,r_single,i_kind
> 17,18c17
> < !_RT use omp_lib, only: omp_get_max_threads
> <   use constants, only: kPa_per_Pa,Pa_per_kPa
> ---
> >   use omp_lib, only: omp_get_max_threads
> 92a92,96
> > !   2019-09-04  martin  - add write_fv3_incr to write netCDF increment rather than analysis in NEMSIO format
> > !   2019-09-23  martin  - add use_gfs_ncio to read global first guess from netCDF file
> > !   2020-12-18  Hu      - add grid_type_fv3_regional
> > !   2021-12-30  Hu      - add fv3_io_layout_y
> > !   2022-03-01  X.Lu & X.Wang - add corresponding variables for dual ens for HAFS. POC: xuguang.wang@ou.edu
> 112,113d115
> <   public :: create_vgrid_vars
> <   public :: destroy_vgrid_vars
> 132c134
> <   public :: gridmod_vgrid
> ---
> >   public :: minmype
> 151a154
> >   public :: l_reg_update_hydro_delz
> 156a160
> >   public :: use_gfs_ncio
> 164c168
> <   public :: mpas_regional
> ---
> >   public :: write_fv3_incr
> 166,168d169
> <   interface gridmod_vgrid
> <      module procedure load_vert_coord_
> <   end interface
> 196,197d196
> <   logical mpas_regional
> < 
> 202a202
> >   logical use_gfs_ncio      ! .t. for using netCDF to real global first guess
> 206a207
> >   logical write_fv3_incr    ! .t. write netCDF increment rather than NEMSIO analysis
> 210a212
> >   real(r_kind) grid_ratio_fv3_regional  ! ratio of analysis grid to fv3 model grid in fv3 grid units.
> 213d214
> <   real(r_kind) grid_ratio_fv3_regional  ! ratio of analysis grid to fv3 model grid in fv3 grid units.
> 271a273
> >   integer(i_kind) minmype           ! processor with minimum size subdomain
> 391,392d392
> <   logical :: verbose = .false.
> < 
> 424a425,426
> > !   2019-09-23  martin  - add flag use_gfs_ncio to determine whether to use netCDF to read global first gues field
> > !   2021-01-05  x.zhang/lei  - add code for updating delz analysis in regional da
> 436c438
> < !   use gsi_io, only: verbose
> ---
> >     use gsi_io, only: verbose
> 446c448
> <     idvc5 = 2  ! RTodling: change default from 1 to 2
> ---
> >     idvc5 = 1
> 453c455
> <     gencode = 82
> ---
> >     gencode = 80
> 462d463
> <     mpas_regional=.false.
> 508a510
> >     use_gfs_ncio = .false.
> 537a540
> >     use gsi_io, only: verbose
> 558c561
> < !   2010-06-04  todling - revisit Zhu''s general CV settings, and vector fields
> ---
> > !   2010-06-04  todling - revisit Zhu's general CV settings, and vector fields
> 580c583
> <     integer(i_kind) icw_cv,iql_cv,iqi_cv
> ---
> >     integer(i_kind) icw_cv,iql_cv,iqi_cv,minmax
> 678c681
> <          regional,vector,verbose=print_verbose)
> ---
> >          regional,vector)
> 692a696,697
> >     minmype=0
> >     minmax=grd_a%ilat1(1)*grd_a%jlon1(1)
> 704a710,713
> >        if(grd_a%ilat1(i)*grd_a%jlon1(i)< minmax)then
> >          minmax=grd_a%ilat1(i)*grd_a%jlon1(i)
> >          minmype=i-1
> >        end if
> 705a715
> >     if(mype == minmype) write(6,*) ' minmype = ',minmype
> 707,709c717,719
> < !_#omp parallel private(nth,tid)
> <     nth = 1 !_RT omp_get_max_threads()
> < !_#omp end parallel
> ---
> > !#omp parallel private(nth,tid)
> >     nth = omp_get_max_threads()
> > !#omp end parallel
> 712,713c722
> <     if(.not.allocated(jtstart)) allocate(jtstart(nthreads))
> <     if(.not.allocated(jtstop)) allocate(jtstop(nthreads))
> ---
> >     allocate(jtstart(nthreads),jtstop(nthreads))
> 838,841c847,849
> <     if(.not.allocated(rlats)) &
> <       allocate(rlats(nlat),rlons(nlon),coslon(nlon),sinlon(nlon),&
> <                wgtlats(nlat),rbs2(nlat),corlats(nlat),wgtfactlats(nlat))
> <     call create_vgrid_vars()
> ---
> >     allocate(rlats(nlat),rlons(nlon),coslon(nlon),sinlon(nlon),&
> >              wgtlats(nlat),rbs2(nlat),corlats(nlat),wgtfactlats(nlat))
> >     allocate(ak5(nsig+1),bk5(nsig+1),ck5(nsig+1),tref5(nsig))
> 844,849d851
> < 
> <   subroutine create_vgrid_vars
> <     implicit none
> <     if(.not.allocated(ak5)) &
> <       allocate(ak5(nsig+1),bk5(nsig+1),ck5(nsig+1),tref5(nsig))
> <   end subroutine create_vgrid_vars
> 884,894c886,887
> <     if(allocated(rlats)) deallocate(rlats)
> <     if(allocated(rlons)) deallocate(rlons)
> <     if(allocated(corlats)) deallocate(corlats)
> <     if(allocated(coslon)) deallocate(coslon)
> <     if(allocated(sinlon)) deallocate(sinlon)
> <     if(allocated(wgtlats)) deallocate(wgtlats)
> <     if(allocated(wgtfactlats)) deallocate(wgtfactlats)
> <     if(allocated(rbs2)) deallocate(rbs2)
> < 
> <     call destroy_vgrid_vars()
> < 
> ---
> >     deallocate(rlats,rlons,corlats,coslon,sinlon,wgtlats,wgtfactlats,rbs2)
> >     deallocate(ak5,bk5,ck5,tref5)
> 911,917d903
> <   subroutine destroy_vgrid_vars
> <     implicit none
> <     if(allocated(ak5)) deallocate(ak5)
> <     if(allocated(bk5)) deallocate(bk5)
> <     if(allocated(ck5)) deallocate(ck5)
> <     if(allocated(tref5)) deallocate(tref5)
> <   end subroutine destroy_vgrid_vars
> 957,959c943,944
> <     if(.not.allocated(periodic_s)) &
> <        allocate(periodic_s(npe),jstart(npe),istart(npe),&
> <        ilat1(npe),jlon1(npe),&
> ---
> >     allocate(periodic_s(npe),jstart(npe),istart(npe),&
> >          ilat1(npe),jlon1(npe),&
> 1014d998
> <     if(allocated(periodic_s)) &
> 1037d1020
> < #ifdef USE_ALL_ORIGINAL
> 1041d1023
> < #endif /* USE_ALL_ORIGINAL */
> 1135d1116
> < #ifdef USE_ALL_ORIGINAL
> 1146a1128
> >        pt_ll=zero
> 1880d1861
> < #endif /* USE_ALL_ORIGINAL */
> 3126c3107
> <     use m_kinds, only: r_kind
> ---
> >     use kinds, only: r_kind
> 3128c3109
> <     use m_mpimod, only: npe
> ---
> >     use mpimod, only: npe
> 3210,3211c3191,3192
> <     use m_kinds, only: r_kind
> <     use m_mpimod, only: npe
> ---
> >     use kinds, only: r_kind
> >     use mpimod, only: npe
> 3287c3268
> <     use m_kinds, only: r_single
> ---
> >     use kinds, only: r_single
> 3350c3331
> <     use m_kinds, only: r_single
> ---
> >     use kinds, only: r_single
> 3412c3393
> <     use m_kinds, only: r_double
> ---
> >     use kinds, only: r_double
> 3476c3457
> <     use m_kinds, only: r_double
> ---
> >     use kinds, only: r_double
> 3537c3518
> <     use m_kinds, only: r_double
> ---
> >     use kinds, only: r_double
> 3603c3584
> <     use m_kinds, only: r_double
> ---
> >     use kinds, only: r_double
> 3666c3647
> <     use m_kinds, only: r_double
> ---
> >     use kinds, only: r_double
> 3730c3711
> <     use m_kinds, only: r_kind
> ---
> >     use kinds, only: r_kind
> 3785c3766
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: r_kind
> 3841c3822
> <     use m_kinds, only: r_kind
> ---
> >     use kinds, only: r_kind
> 3895,3927d3875
> <   subroutine load_vert_coord_(mype,fname)
> <   use m_set_eta, only: set_eta
> <   use m_set_eta, only: set_eta_read
> <   ! ideally, these coordinates should be passed from JEDI
> <   implicit none
> <   integer(i_kind),intent(in) :: mype
> <   character(len=*),optional,intent(in) :: fname
> <   character(len=*),parameter:: myname_=myname//'*load_vert_coord_'
> <   integer ks,ifail,ier
> <   real(r_kind) :: ptop,pint
> <   ifail=0 
> <   if(.not.allocated(ak5)) ifail=1
> <   if(.not.allocated(bk5)) ifail=1
> <   if(ifail/=0) then
> <      call create_vgrid_vars()
> <      ifail=0
> <   endif
> <   ! Expect FV3 levels/orientation/units
> <   if (present(fname)) then
> <     if (trim(fname)=='/dev/null') then
> <        call set_eta (nsig, ks, ptop, pint, ak5, bk5)
> <     else
> <        call set_eta_read(trim(fname),ak5,bk5,ier,myid=mype)
> <     endif
> <   else
> <     call set_eta (nsig, ks, ptop, pint, ak5, bk5)
> <   endif
> <   ! Reorient and adjust units for GSI
> <   ak5=kPa_per_Pa*ak5
> <   ak5=ak5(nsig+1:1:-1)
> <   bk5=bk5(nsig+1:1:-1)
> <   end subroutine load_vert_coord_
> < 
> 3968c3916
> <    use m_kinds, only: r_kind,i_kind
> ---
> >    use kinds, only: r_kind,i_kind
> 4037c3985
> <    use m_kinds, only: r_kind,i_kind
> ---
> >    use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: grtest.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gscond_ad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsdcloudanalysis4gfs.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsdcloudanalysis4NMMB.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsdcloudanalysis.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsdcloudlib_pseudoq_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsd_terrain_match_surfTobs.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsd_update_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_4dcouplermod.f90
> diff -r ./gsi_4dvar.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_4dvar.f90
> 27,28c27
> < !   2017-05-06 todling  - add tau_fcst to determine EnVarFSOI-like calculation
> < !   2020-02-26 todling  - obsbin time now in minutes
> ---
> > !   2017-05-06 todling  - add tau_fcst to determine EFSOI-like calculation
> 61c60
> < !   nmn_obsbin        - Length of observation bins (temporary control)
> ---
> > !   nhr_obsbin        - Length of observation bins (temporary control)
> 63c62
> < !   mn_obsbin         - Length of observation bins (minutes)
> ---
> > !   hr_obsbin         - Length of observation bins (hours)
> 78,79c77,78
> < !   ens_nmn           - Time between time levels for ensemble (currently same as nmn_obsbins)
> < !   ens_fmnlevs       - Forecast length for each time level for ensemble perturbations
> ---
> > !   ens_nhr           - Time between time levels for ensemble (currently same as nhr_obsbins)
> > !   ens_fhrlevs       - Forecast length for each time level for ensemble perturbations
> 99,100c98,99
> <   use m_kinds, only: r_kind,i_kind
> <   use constants, only: r60
> ---
> >   use kinds, only: r_kind,i_kind
> >   use constants, only: one
> 114c113
> <   public :: mn_obsbin,ltlint,idmodel,iwrtinc,winsub,winlen,iwinbgn
> ---
> >   public :: hr_obsbin,ltlint,idmodel,iwrtinc,winsub,winlen,iwinbgn
> 116c115
> <   public :: ladtest,ladtest_obs,lgrtest,lcongrad,nmn_obsbin,nhr_subwin,nwrvecs
> ---
> >   public :: ladtest,ladtest_obs,lgrtest,lcongrad,nhr_obsbin,nhr_subwin,nwrvecs
> 118c117
> <   public :: l4densvar,ens_fmnlevs,ens_nstarthr,ibin_anl
> ---
> >   public :: l4densvar,ens_nhr,ens_fhrlevs,ens_nstarthr,ibin_anl
> 122,124c121,123
> <   public :: evfsoi_order
> <   public :: evfsoi_afcst
> <   public :: evfsoi_ana
> ---
> >   public :: efsoi_order
> >   public :: efsoi_afcst
> >   public :: efsoi_ana
> 143,144c142,143
> <   logical         :: evfsoi_afcst
> <   logical         :: evfsoi_ana
> ---
> >   logical         :: efsoi_afcst
> >   logical         :: efsoi_ana
> 151c150
> <   integer(i_kind) :: nmn_obsbin, nobs_bins
> ---
> >   integer(i_kind) :: nhr_obsbin, nobs_bins
> 157,158c156,157
> <   integer(i_kind) :: ens_nstarthr,ibin_anl
> <   integer(i_kind),allocatable,dimension(:) :: ens_fmnlevs
> ---
> >   integer(i_kind) :: ens_nhr,ens_nstarthr,ibin_anl
> >   integer(i_kind),allocatable,dimension(:) :: ens_fhrlevs
> 160c159
> <   integer(i_kind) :: evfsoi_order
> ---
> >   integer(i_kind) :: efsoi_order
> 164c163
> <   real(r_kind) :: iwinbgn, winlen, winoff, winsub, mn_obsbin
> ---
> >   real(r_kind) :: iwinbgn, winlen, winoff, winsub, hr_obsbin
> 210c209
> < nmn_obsbin=-1
> ---
> > nhr_obsbin=-1
> 220a220
> > ens_nhr = 0
> 230,233c230,233
> < tau_fcst = -1           ! ensemble of forecast at hour current+tau_fcst 
> < evfsoi_order = 1        ! order of appox used in EnVarFSOI-like settings
> < evfsoi_afcst = .false.  ! internal EnVarFSOI-like parameter (NEVER to be in namelist)
> < evfsoi_ana   = .false.  ! internal EnVarFSOI-like parameter (NEVER to be in namelist)
> ---
> > tau_fcst = -1          ! ensemble of forecast at hour current+tau_fcst 
> > efsoi_order = 1        ! order of appox used in EFSOI-like settings
> > efsoi_afcst = .false.  ! internal EFSOI-like parameter (NEVER to be in namelist)
> > efsoi_ana   = .false.  ! internal EFSOI-like parameter (NEVER to be in namelist)
> 262c262
> < use jfunc, only: ljc4tlevs
> ---
> > use jcmod, only: ljc4tlevs
> 268,269d267
> < integer(i_kind) :: nmn_assimilation
> < integer(i_kind) :: ens_nmn
> 271,272d268
> < ens_nmn = 0
> < nmn_assimilation = 60 * nhr_assimilation
> 274c270
> < winoff = real(min_offset/r60,r_kind)
> ---
> > winoff = real(min_offset/60._r_kind,r_kind)
> 276,277c272,273
> < if (nmn_obsbin>0.and.nmn_obsbin<=nmn_assimilation) then
> <    mn_obsbin = real(nmn_obsbin,r_kind)
> ---
> > if (nhr_obsbin>0.and.nhr_obsbin<=nhr_assimilation) then
> >    hr_obsbin = real(nhr_obsbin,r_kind)
> 281c277
> <       mn_obsbin = r60
> ---
> >       hr_obsbin = one
> 283c279
> <       mn_obsbin = r60
> ---
> >       hr_obsbin = one   
> 285c281
> <       mn_obsbin = winlen * r60
> ---
> >       hr_obsbin = winlen
> 290,293c286,289
> < IF (mn_obsbin<winlen*r60) THEN
> <    ibin = NINT(winlen*r60/mn_obsbin)
> <    IF (NINT(ibin*mn_obsbin)/=nmn_assimilation) THEN
> <       write(6,*)'SETUP_4DVAR: Error=',ibin,mn_obsbin,nmn_assimilation
> ---
> > IF (hr_obsbin<winlen) THEN
> >    ibin = NINT(winlen/hr_obsbin)
> >    IF (NINT(ibin*hr_obsbin)/=nhr_assimilation) THEN
> >       write(6,*)'SETUP_4DVAR: Error=',ibin,hr_obsbin,nhr_assimilation
> 346c342
> <    ens_nmn    = nmn_obsbin
> ---
> >    ens_nhr    = nhr_obsbin
> 352c348
> <    ibin_anl = (nmn_assimilation/(2*nmn_obsbin))+1
> ---
> >    ibin_anl = (nhr_assimilation/(2*nhr_obsbin))+1
> 371c367
> < if(.not.allocated(ens_fmnlevs)) allocate(ens_fmnlevs(ntlevs_ens))
> ---
> > allocate(ens_fhrlevs(ntlevs_ens))
> 373c369
> <    ens_fmnlevs(k) = ens_nstarthr*60 + (k-1)*ens_nmn
> ---
> >    ens_fhrlevs(k) = ens_nstarthr + (k-1)*ens_nhr
> 375c371
> <       write(6,'(2(A,I5))')' SETUP_4DVAR: timelevel = ', k, ' , ens_fmnlevs = ', ens_fmnlevs(k)
> ---
> >       write(6,'(2(A,I5))')' SETUP_4DVAR: timelevel = ', k, ' , ens_fhrlevs = ', ens_fhrlevs(k)
> 389c385
> <    write(6,*)'SETUP_4DVAR: mn_obsbin=',mn_obsbin
> ---
> >    write(6,*)'SETUP_4DVAR: hr_obsbin=',hr_obsbin
> 442c438
> < integer(i_kind) iyr,imo,idy,ihr,nmin_obs,nhrobs,nhrbgn,nhroff
> ---
> > integer(i_kind) iyr,imo,idy,ihr,nmin_obs
> 443a440
> > real(r_kind) nhroff,nhrbgn,nhrobs
> 457,461c454,458
> < !call w3fs21(idate5,nmin_obs)
> < !if (MOD(nmin_obs,60)/=0) then
> < !   write(6,*)'time_4dvar: minutes should be 0',nmin_obs
> < !   call stop2(136)
> < !end if
> ---
> > call w3fs21(idate5,nmin_obs)
> > if (MOD(nmin_obs,60)/=0) then
> >    write(6,*)'time_4dvar: minutes should be 0',nmin_obs
> >    call stop2(136)
> > end if
> 464c461
> < nhrbgn=NINT(real(iwinbgn,r_kind)*r60inv)
> ---
> > nhrbgn=real(iwinbgn,r_kind)*r60inv
> 497c494
> <    deallocate(ens_fmnlevs)
> ---
> >    deallocate(ens_fhrlevs)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_aeroOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_bias.f90
> diff -r ./gsi_bundlemod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_bundlemod.F90
> 17c17
> <    use m_kinds, only: i_kind,r_single,r_kind,r_double,r_quad
> ---
> >    use kinds, only: i_kind,r_single,r_kind,r_double,r_quad
> 20d19
> <    use m_mpimod, only: mype
> 282c281
> < !                      and his f90/ESMF''s SimpleBundle.
> ---
> > !                      and his f90/ESMF's SimpleBundle.
> 1675c1674
> < !  07Jul2010 Todling  Fixed interface (no optionals, per Guo''s suggestion) to
> ---
> > !  07Jul2010 Todling  Fixed interface (no optionals, per Guo's suggestion) to
> 3385c3384
> <      call stop2(998)
> ---
> >      call stop2(313)
> 3478c3477
> <      call stop2(998)
> ---
> >      call stop2(313)
> 3544c3543
> <      call stop2(998)
> ---
> >      call stop2(313)
> 3610c3609
> <      call stop2(998)
> ---
> >      call stop2(313)
> 4144c4143
> <   subroutine print_ ( Bundle, thispe )
> ---
> >   subroutine print_ ( Bundle )
> 4149d4147
> <     integer(i_kind),optional,intent(in) :: thispe
> 4168d4165
> <     logical showthis
> 4173,4177d4169
> <     showthis=.true.
> <     if(present(thispe)) then
> <        showthis=mype==thispe
> <     endif
> <     if (.not.showthis) return
> 4180d4171
> <     print *, 'Bundle: n1d, n2d, n3d', Bundle%n1d, Bundle%n2d, Bundle%n3d
> 4183c4174
> <            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [1d] '//trim(Bundle%r1(i)%shortname), &
> ---
> >            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [1d] '//Bundle%r1(i)%shortname, &
> 4187c4178
> <            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [1d] '//trim(Bundle%r1(i)%shortname), &
> ---
> >            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [1d] '//Bundle%r1(i)%shortname, &
> 4194c4185
> <            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [2d] '//trim(Bundle%r2(i)%shortname), &
> ---
> >            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [2d] '//Bundle%r2(i)%shortname, &
> 4198c4189
> <            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [2d] '//trim(Bundle%r2(i)%shortname), &
> ---
> >            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [2d] '//Bundle%r2(i)%shortname, &
> 4205c4196
> <            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [3d] '//trim(Bundle%r3(i)%shortname), &
> ---
> >            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [3d] '//Bundle%r3(i)%shortname, &
> 4209c4200
> <            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [3d] '//trim(Bundle%r3(i)%shortname), &
> ---
> >            write(*,'(a20,2x,1p,e11.4,2x,e11.4)') '  [3d] '//Bundle%r3(i)%shortname, &
> diff -r ./gsi_chemguess_mod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_chemguess_mod.F90
> 210c210
> < !               we''ll generalize this.
> ---
> > !               we'll generalize this.
> 223c223
> < use m_kinds, only: i_kind,r_kind
> ---
> > use kinds, only: i_kind,r_kind
> 225c225
> < use m_mpimod, only : mype
> ---
> > use mpimod, only : mype
> 227,228c227
> < !use file_utility, only : get_lun
> < use mpeu_util, only: get_lun => luavail
> ---
> > use file_utility, only : get_lun
> 284c283
> < !   19May2010 Todling - porter Hou''s igfsco2 flag from setup namelist to this namelist
> ---
> > !   19May2010 Todling - porter Hou's igfsco2 flag from setup namelist to this namelist
> 319c318
> <                                                    ! < 0 don''t use in CRTM
> ---
> >                                                    ! < 0 don't use in CRTM
> 339c338
> < subroutine init_ (iamroot,rcname)
> ---
> > subroutine init_ (iamroot)
> 344d342
> <    character(len=*),optional,intent(in) :: rcname 
> 362,363c360,361
> < !character(len=*),parameter:: rcname_def='anavinfo.txt'
> < character(len=*),parameter:: rcname_def='anavinfo'  ! filename should have extension
> ---
> > !character(len=*),parameter:: rcname='anavinfo.txt'
> > character(len=*),parameter:: rcname='anavinfo'  ! filename should have extension
> 380,384c378
> < if(present(rcname)) then
> <   open(luin,file=rcname,form='formatted')
> < else
> <   open(luin,file=rcname_def,form='formatted')
> < endif
> ---
> > open(luin,file=rcname,form='formatted')
> 925c919
> < !   2012-05-12  todling  fix to return aero-4crtm of all aero''s
> ---
> > !   2012-05-12  todling  fix to return aero-4crtm of all aero's
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_cldchOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_cldtotOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_colvkOper.F90
> Only in ./: gsi_convert_cv_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_dbzOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_dwOper.F90
> diff -r ./gsi_enscouplermod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_enscouplermod.f90
> 97,98c97,98
> <    subroutine get_user_ens_(grd,member,nymd,nhms,tau,atm_bundle,iret)
> <    use m_kinds, only: i_kind,r_kind
> ---
> >    subroutine get_user_ens_(grd,member,ntindex,atm_bundle,iret)
> >    use kinds, only: i_kind,r_kind
> 105,106c105
> <       integer(i_kind)                       ,intent(in   ) :: nymd,nhms
> <       integer(i_kind)                       ,intent(in   ) :: tau
> ---
> >       integer(i_kind)                       ,intent(in   ) :: ntindex
> 110c109
> <       call this_ensemble_%get_user_ens(grd,member,nymd,nhms,tau,atm_bundle,iret)
> ---
> >       call this_ensemble_%get_user_ens(grd,member,ntindex,atm_bundle,iret)
> 113,114c112,113
> <    subroutine get_user_Nens_(grd,members,nymd,nhms,tau,atm_bundle,iret)
> <    use m_kinds, only: i_kind,r_kind
> ---
> >    subroutine get_user_Nens_(grd,members,ntindex,atm_bundle,iret)
> >    use kinds, only: i_kind,r_kind
> 121,122c120
> <       integer(i_kind)                       ,intent(in   ) :: nymd,nhms
> <       integer(i_kind)                       ,intent(in   ) :: tau
> ---
> >       integer(i_kind)                       ,intent(in   ) :: ntindex
> 126c124
> <       call this_ensemble_%get_user_Nens(grd,members,nymd,nhms,tau,atm_bundle,iret)
> ---
> >       call this_ensemble_%get_user_Nens(grd,members,ntindex,atm_bundle,iret)
> 130c128
> <    use m_kinds, only: i_kind,r_kind
> ---
> >    use kinds, only: i_kind,r_kind
> 145c143
> <    use m_kinds, only: i_kind,r_kind
> ---
> >    use kinds, only: i_kind,r_kind
> 189c187
> <    use m_kinds, only: i_kind
> ---
> >    use kinds, only: i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_fedOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_files.cmake
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_fixture_GFS.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_fixture_REGIONAL.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_gpsbendOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_gpsrefOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_gustOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_howvOper.F90
> diff -r ./gsi_io.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_io.f90
> 27c27
> <   use m_kinds, only: i_kind
> ---
> >   use kinds, only: i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_lcbasOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_lightOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_lwcpOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsimain.f90
> diff -r ./gsi_metguess_mod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_metguess_mod.F90
> 196c196
> < !               we''ll generalize this.
> ---
> > !               we'll generalize this.
> 209c209
> < use m_kinds, only: i_kind,r_kind
> ---
> > use kinds, only: i_kind,r_kind
> 211c211
> < use m_mpimod, only : mype
> ---
> > use mpimod, only : mype
> 213,214c213
> < !use file_utility, only : get_lun
> < use mpeu_util, only: get_lun => luavail
> ---
> > use file_utility, only : get_lun
> 299c298
> <                                                    ! < 0 don''t use in CRTM
> ---
> >                                                    ! < 0 don't use in CRTM
> 321c320
> < subroutine init_ (iamroot,rcname)
> ---
> > subroutine init_ (iamroot)
> 326d324
> <    character(len=*),optional,intent(in) :: rcname 
> 346,347c344,345
> < !character(len=*),parameter:: rcname_def='anavinfo.txt'
> < character(len=*),parameter:: rcname_def='anavinfo'  ! filename should have extension
> ---
> > !character(len=*),parameter:: rcname='anavinfo.txt'
> > character(len=*),parameter:: rcname='anavinfo'  ! filename should have extension
> 364,368c362
> < if(present(rcname)) then
> <   open(luin,file=trim(rcname),form='formatted')
> < else
> <   open(luin,file=rcname_def,form='formatted')
> < endif
> ---
> > open(luin,file=rcname,form='formatted')
> 414c408
> < allocate(levels(nmguess),i4crtm(nmguess),usrname(nmguess),&
> ---
> >    allocate(levels(nmguess),i4crtm(nmguess),usrname(nmguess),&
> 506,511c500
> <  
> < if(allocated(mguess3d)) deallocate(mguess3d)
> < if(allocated(metsty3d)) deallocate(metsty3d)
> < if(allocated(i4crtm3d)) deallocate(i4crtm3d)
> < if(allocated(levels3d)) deallocate(levels3d)
> < if(allocated(usrname3d))deallocate(usrname3d)
> ---
> > if(.not.guess_initialized_) return
> 512a502
> > if(allocated(mguess3d)) deallocate(mguess3d)
> 513a504
> > if(allocated(metsty3d)) deallocate(metsty3d)
> 514a506
> > if(allocated(i4crtm3d)) deallocate(i4crtm3d)
> 516c508,511
> < if(allocated(levels2d)) deallocate(levels2d)
> ---
> > if(allocated(levels3d)) deallocate(levels2d)
> > if(allocated(levels))   deallocate(levels)
> > if(allocated(i4crtm))   deallocate(i4crtm)
> > if(allocated(usrname3d))deallocate(usrname3d)
> 518d512
> < 
> 522,523d515
> < if(allocated(levels))   deallocate(levels)
> < if(allocated(i4crtm))   deallocate(i4crtm)
> 652c644,645
> <      if(associated(GSI_MetGuess_Bundle)) nullify(GSI_MetGuess_Bundle)
> ---
> >      deallocate(GSI_MetGuess_Bundle,stat=istatus)
> >      istatus=istatus+ier
> 720,725d712
> <   else if(trim(desc)=='dim::2d') then
> <      ivar = ng2d
> <      istatus=0
> <   else if(trim(desc)=='dim::3d') then
> <      ivar = ng3d
> <      istatus=0
> 939,951d925
> <   if(desc(1:8)=='usrvar::') then
> <      if(allocated(usrname)) then
> <         labfound=.true.
> <         is=len_trim(desc)
> <         if(is>=9) then
> <           i=getindex(usrname,desc(9:is))
> <           if(i>0) then
> <             ivar=usrname(i)
> <             istatus=0
> <           endif
> <         endif
> <      endif
> <   endif
> 1018,1035d991
> <   if(trim(desc)=='gsinames::2d') then
> <      labfound=.true.
> <      if(size(ivar)>=size(mguess2d)) then
> <         if(allocated(mguess2d))then
> <            ivar = mguess2d
> <            istatus=0
> <         endif
> <      endif
> <   endif
> <   if(trim(desc)=='gsinames::3d') then
> <      labfound=.true.
> <      if(size(ivar)>=size(mguess3d)) then
> <         if(allocated(mguess3d))then
> <            ivar = mguess3d
> <            istatus=0
> <         endif
> <      endif
> <   endif
> 1041,1058d996
> <            istatus=0
> <         endif
> <      endif
> <   endif
> <   if(trim(desc)=='usrnames::2d') then
> <      labfound=.true.
> <      if(size(ivar)>=size(usrname2d)) then
> <         if(allocated(usrname2d))then
> <            ivar = usrname2d
> <            istatus=0
> <         endif
> <      endif
> <   endif
> <   if(trim(desc)=='usrnames::3d') then
> <      labfound=.true.
> <      if(size(ivar)>=size(usrname3d)) then
> <         if(allocated(usrname3d))then
> <            ivar = usrname3d
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_mitmOper.F90
> diff -r ./gsimod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsimod.F90
> 15c15,54
> <   use m_kinds, only: i_kind,r_kind
> ---
> >   use kinds, only: i_kind,r_kind
> >   use obsmod, only: dmesh,dval,dthin,dtype,dfile,dplat,dsfcalc,ndat,&
> >      init_obsmod_dflts,create_obsmod_vars,write_diag,reduce_diag,oberrflg,&
> >      time_window,perturb_obs,perturb_fact,sfcmodel,destroy_obsmod_vars,dsis,&
> >      dtbduv_on,time_window_max,offtime_data,init_directories,oberror_tune,ext_sonde, &
> >      blacklst,init_obsmod_vars,lobsdiagsave,lobskeep,lobserver,hilbert_curve,&
> >      lread_obs_save,lread_obs_skip,time_window_rad,tcp_posmatch,tcp_box, &
> >      neutral_stability_windfact_2dvar,use_similarity_2dvar,ta2tb
> >   use gsi_dbzOper, only: diag_radardbz
> >   use gsi_fedOper, only: diag_fed
> > 
> >   use obsmod, only: doradaroneob,dofedoneob,oneoblat,oneoblon,oneobheight,oneobvalue,oneobddiff,oneobradid,&
> >      radar_no_thinning,ens_hx_dbz_cut,static_gsi_nopcp_dbz,rmesh_dbz,&
> >      rmesh_vr,zmesh_dbz,zmesh_vr,if_vterminal, if_model_dbz,if_model_fed,innov_use_model_fed,if_vrobs_raw,if_use_w_vr,&
> >      minobrangedbz,maxobrangedbz,maxobrangevr,maxtiltvr,inflate_dbz_obserr,missing_to_nopcp,&
> >      ntilt_radarfiles,whichradar,&
> >      minobrangevr,maxtiltdbz,mintiltvr,mintiltdbz,l2rwthin,hurricane_radar,&
> >      r_hgt_fed
> > 
> >   use obsmod, only: lwrite_predterms, &
> >      lwrite_peakwt,use_limit,lrun_subdirs,l_foreaft_thin,lobsdiag_forenkf,&
> >      obsmod_init_instr_table,obsmod_final_instr_table
> >   use obsmod, only: luse_obsdiag
> >   use obsmod, only: netcdf_diag, binary_diag
> >   use obsmod, only: l_wcp_cwm,ompslp_mult_fact
> >   use obsmod, only: l_obsprvdiag
> >   use obsmod, only: aircraft_recon, &
> >        
> >        ! The following variables are the coefficients that describe
> >        ! the linear regression fits that are used to define the
> >        ! dynamic observation error (DOE) specifications for all
> >        ! reconnissance observations collected within
> >        ! hurricanes/tropical cyclones; these apply only to the
> >        ! regional forecast models (e.g., HWRF); Henry R. Winterbottom
> >        ! (henry.winterbottom@noaa.gov).
> >        
> >        q_doe_a_136,q_doe_a_137,q_doe_b_136,q_doe_b_137, &
> >        t_doe_a_136,t_doe_a_137,t_doe_b_136,t_doe_b_137, &
> >        uv_doe_a_236,uv_doe_a_237,uv_doe_a_213,uv_doe_b_236,uv_doe_b_237,&
> >        uv_doe_b_213
> 17,19c56,89
> <   use mpeu_util,only: die,warn
> <   use mpeu_util,only: uppercase
> <   use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mype
> ---
> >   use obsmod, only: vad_near_analtime
> >   
> >   use aircraftinfo, only: init_aircraft,hdist_aircraft,aircraft_t_bc_pof,aircraft_t_bc, &
> >                           aircraft_t_bc_ext,biaspredt,upd_aircraft,cleanup_tail
> >        
> >   use obs_sensitivity, only: lobsensfc,lobsensincr,lobsensjb,lsensrecompute, &
> >                              lobsensadj,lobsensmin,iobsconv,llancdone,init_obsens
> >   use gsi_4dvar, only: setup_4dvar,init_4dvar,nhr_assimilation,min_offset, &
> >                        l4dvar,nhr_obsbin,nhr_subwin,nwrvecs,iorthomax,&
> >                        lbicg,lsqrtb,lcongrad,lbfgsmin,ltlint,ladtest,ladtest_obs, lgrtest,&
> >                        idmodel,clean_4dvar,iwrtinc,lanczosave,jsiga,ltcost,liauon, &
> >                        l4densvar,ens_nstarthr,lnested_loops,lwrite4danl,nhr_anal,thin4d,tau_fcst,efsoi_order
> >   use gsi_4dvar, only: mPEs_observer
> >   use m_obsdiags, only: alwaysLocal => obsdiags_alwaysLocal
> >   use obs_ferrscale, only: lferrscale
> >   use mpimod, only: npe,mpi_comm_world,ierror,mype
> >   use radinfo, only: retrieval,diag_rad,init_rad,init_rad_vars,adp_anglebc,angord,upd_pred,&
> >                        biaspredvar,use_edges,passive_bc,newpc4pred,final_rad_vars,emiss_bc,&
> >                        ssmis_method,ssmis_precond,gmi_method,amsr2_method,bias_zero_start, &
> >                        reset_bad_radbc,cld_det_dec2bin,diag_version,lupdqc,lqcoef
> >   use radinfo, only: tzr_qc,tzr_bufrsave
> >   use radinfo, only: crtm_coeffs_path,optconv
> >   use ozinfo, only: diag_ozone,init_oz
> >   use aeroinfo, only: diag_aero, init_aero, init_aero_vars, final_aero_vars
> >   use coinfo, only: diag_co,init_co
> >   use convinfo, only: init_convinfo, &
> >                       diag_conv,&
> >                       use_prepb_satwnd,id_drifter, ec_amv_qc,&
> >                       id_ship
> >   use lightinfo, only: diag_light,init_light
> > 
> >   use oneobmod, only: oblon,oblat,obpres,obhourset,obdattim,oneob_type,&
> >      oneobtest,magoberr,maginnov,init_oneobmod,pctswitch,lsingleradob,obchan,&
> >      anaz_rw,anel_rw,range_rw,sstn,lsingleradar,singleradar,learthrel_rw
> 21,29c91,110
> < 
> <   use jfunc, only: jfunc_init,mockbkg
> <   use jfunc, only: cwoption,qoption,pseudo_q2
> <   use jfunc, only: switch_on_derivatives
> <   use jfunc, only: tendsflag
> < 
> <   use gsi_4dvar, only: setup_4dvar,init_4dvar,clean_4dvar
> <   use gsi_4dvar, only: l4densvar,nmn_obsbin
> < 
> ---
> >   use turblmod, only: use_pbl,init_turbl
> >   use qcmod, only: dfact,dfact1,create_qcvars,destroy_qcvars,&
> >       erradar_inflate,tdrerr_inflate,use_poq7,qc_satwnds,&
> >       init_qcvars,vadfile,noiqc,c_varqc,gps_jacqc,qc_noirjaco3,qc_noirjaco3_pole,&
> >       buddycheck_t,buddydiag_save,njqc,vqc,nvqc,hub_norm,vadwnd_l2rw_qc, &
> >       pvis,pcldch,scale_cv,estvisoe,estcldchoe,vis_thres,cldch_thres,cao_check, &
> >       cris_cads, iasi_cads, airs_cads
> >   use qcmod, only: troflg,lat_c,nrand
> >   use cads, only: M__Sensor,N__Num_Bands,N__GradChkInterval,N__Band_Size,N__Bands,N__Window_Width, &
> >       N__Window_Bounds,R__BT_Threshold,R__Grad_Threshold,R__Window_Grad_Threshold, L__Do_Quick_Exit, &
> >       L__Do_CrossBand, N__BandToUse,L__Do_Imager_Cloud_Detection, N__Num_Imager_Chans, &
> >       N__Num_Imager_Clusters,N__Imager_Chans,R__Stddev_Threshold,R__Coverage_Threshold, &
> >       R__FG_Departure_Threshold, CADS_Setup_Cloud
> >   use pcpinfo, only: npredp,diag_pcp,dtphys,deltim,init_pcp
> >   use jfunc, only: iout_iter,iguess,miter,factqmin,factqmax,superfact,limitqobs, &
> >      factql,factqi,factqr,factqs,factqg, &  
> >      factv,factl,factp,factg,factw10m,facthowv,factcldch,niter,niter_no_qc,biascor,&
> >      init_jfunc,qoption,cwoption,switch_on_derivatives,tendsflag,jiterstart,jiterend,R_option,&
> >      bcoption,diurnalbc,print_diag_pcg,tsensible,diag_precon,step_start,pseudo_q2,&
> >      clip_supersaturation,cnvw_option,hofx_2m_sfcfile
> 32c113,114
> <      cvarsmd,nrf_var,lcalc_gfdl_cfrac 
> ---
> >      nrf_var,lcalc_gfdl_cfrac,incvars_to_zero,incvars_zero_strat,incvars_efold 
> >   use derivsmod, only: init_anadv
> 34,36c116,122
> <      bkgv_flowdep,bkgv_rewgtfct,bkgv_write,fpsproj,nhscrf,adjustozvar,fut2ps,cwcoveqqcov,adjustozhscl,&
> <      bkgv_write_cv,bkgv_write_sv
> <   use berror, only: simcv !_RT intro for testing
> ---
> >      bkgv_flowdep,bkgv_rewgtfct,bkgv_write,fpsproj,nhscrf,adjustozvar,fut2ps,cwcoveqqcov
4c3595,4191
< 416c417
---
> >   use anberror, only: anisotropic,ancovmdl,init_anberror,npass,ifilt_ord,triad4, &
> >      binom,normal,ngauss,rgauss,anhswgt,an_vs,&
> >      grid_ratio,grid_ratio_p,an_flen_u,an_flen_t,an_flen_z, &
> >      rtma_subdomain_option,rtma_bkerr_sub2slab,nsmooth,nsmooth_shapiro,&
> >      pf2aP1,pf2aP2,pf2aP3,afact0,covmap,lreadnorm
> 38,53c124,144
> < 
> <   use gridmod, only: nlat,nlon,nsig,&
> <      nsig1o,nnnn1o,&
> <      init_grid,init_grid_vars,&
> <      nlayers,jcap,jcap_b,vlevs,&
> <      use_sp_eqspace,final_grid_vars,&
> <      jcap_gfs,nlat_gfs,nlon_gfs,jcap_cut
> < 
> <   use gridmod, only: init_reg_glob_ll,regional,fv3_regional,grid_ratio_fv3_regional,mpas_regional
> < 
> <   use constants, only: zero,one,init_constants,gps_constants,three
> <   use constants, only: init_constants,init_constants_derived
> <   use constants, only: final_constants,final_constants_derived
> < 
> <   use fgrid2agrid_mod, only: set_fgrid2agrid
> < 
> ---
> >   use jcmod, only: init_jcvars,ljcdfi,alphajc,ljcpdry,bamp_jcpdry,eps_eer,ljc4tlevs,ljclimqc 
> >   use tendsmod, only: ctph0,stph0,tlm0
> >   use mod_vtrans, only: nvmodes_keep,init_vtrans
> >   use mod_strong, only: l_tlnmc,reg_tlnmc_type,nstrong,tlnmc_option,&
> >        period_max,period_width,init_strongvars,baldiag_full,baldiag_inc
> >   use gridmod, only: nlat,nlon,nsig,wrf_nmm_regional,nems_nmmb_regional,fv3_regional,cmaq_regional,fv3_cmaq_regional,&
> >      nmmb_reference_grid,grid_ratio_nmmb,grid_ratio_wrfmass,grid_ratio_fv3_regional,fv3_io_layout_y,&
> >      filled_grid,half_grid,wrf_mass_regional,nsig1o,nnnn1o,update_regsfc,&
> >      diagnostic_reg,gencode,nlon_regional,nlat_regional,nvege_type,&
> >      twodvar_regional,regional,init_grid,init_reg_glob_ll,init_grid_vars,netcdf,&
> >      nlayers,use_gfs_ozone,check_gfs_ozone_date,regional_ozone,jcap,jcap_b,vlevs,&
> >      use_gfs_nemsio,sfcnst_comb,use_readin_anl_sfcmask,use_sp_eqspace,final_grid_vars,&
> >      jcap_gfs,nlat_gfs,nlon_gfs,jcap_cut,wrf_mass_hybridcord,use_gfs_ncio,write_fv3_incr,&
> >      use_fv3_aero,grid_type_fv3_regional
> >   use gridmod,only: l_reg_update_hydro_delz,fv3_cmaq_regional
> >   use guess_grids, only: ifact10,sfcmod_gfs,sfcmod_mm5,use_compress,nsig_ext,gpstop,commgpstop,commgpserrinf
> >   use gsi_io, only: init_io,lendian_in,verbose,print_obs_para
> >   use regional_io_mod, only: regional_io_class
> >   use wrf_params_mod, only: update_pint, preserve_restart_date
> >   use constants, only: zero,one,init_constants,gps_constants,init_constants_derived,three
> >   use fgrid2agrid_mod, only: nord_f2a,init_fgrid2agrid,final_fgrid2agrid,set_fgrid2agrid
> 55,71c146,152
> < 
> <   use gsi_metguess_mod, only: gsi_metguess_init,gsi_metguess_final
> <   use gsi_metguess_mod, only: gsi_metguess_destroy_grids
> <   use gsi_chemguess_mod, only: gsi_chemguess_init,gsi_chemguess_final
> <   use gsi_chemguess_mod, only: gsi_chemguess_destroy_grids
> < 
> <   use general_commvars_mod, only: init_general_commvars,destroy_general_commvars
> <   use general_commvars_mod, only: init_general_commvars_dims
> <   use general_commvars_mod, only: final_general_commvars_dims
> < 
> <   use derivsmod, only: dvars2d, dvars3d
> <   use derivsmod, only: create_ges_derivatives,init_anadv,destroy_ges_derivatives
> <   use derivsmod, only: final_anadv 
> < 
> <   use tendsmod, only: create_ges_tendencies
> <   use tendsmod, only: destroy_ges_tendencies
> < 
> ---
> >   use read_l2bufr_mod, only: minnum,del_azimuth,del_elev,del_range,del_time,&
> >      range_max,elev_angle_max,initialize_superob_radar,l2superob_only,radar_sites,radar_box,radar_rmesh,radar_zmesh
> >   use m_berror_stats,only : berror_stats ! filename if other than "berror_stats"
> >   use lag_fields,only : infile_lag,lag_nmax_bal,&
> >                         &lag_vorcore_stderr_a,lag_vorcore_stderr_b,lag_modini
> >   use lag_interp,only : lag_accur
> >   use lag_traj,only   : lag_stepduration
> 74c155
> <                          regional_ensemble_option,merge_two_grid_ensperts, &
> ---
> >                          regional_ensemble_option,fv3sar_ensemble_opt,merge_two_grid_ensperts, &
> 76c157
> <                          beta_s0,s_ens_h,s_ens_v,init_hybrid_ensemble_parameters,&
> ---
> >                          beta_s0,beta_e0,s_ens_h,s_ens_v,init_hybrid_ensemble_parameters,&
> 79,89c160,234
> <                          l_ens_in_diff_time,ensemble_path,ens_fast_read,sst_staticB,&
> <                          bens_recenter,upd_ens_spread,upd_ens_localization,ens_fname_tmpl,&
> <                          EnsSource
> < 
> <   use gsi_io, only: init_io, verbose
> < 
> <   use mod_vtrans, only: nvmodes_keep,init_vtrans,destroy_vtrans
> <   use mod_strong, only: reg_tlnmc_type,l_tlnmc,nstrong,tlnmc_option,&
> <        period_max,period_width,baldiag_full,baldiag_inc, &
> <        init_strongvars ! RT: this needs attention
> <   use turblmod, only: create_turblvars
> ---
> >                          l_ens_in_diff_time,ensemble_path,ens_fast_read,sst_staticB,limqens, &
> >                          ntotensgrp,nsclgrp,naensgrp,ngvarloc,ntlevs_ens,naensloc, &
> >                          r_ensloccov4tim,r_ensloccov4var,r_ensloccov4scl,l_timloc_opt,&
> >                          vdl_scale,vloc_varlist,&
> >                          global_spectral_filter_sd,assign_vdl_nml,parallelization_over_ensmembers,l_mgbf_loc
> >   use hybrid_ensemble_parameters,only : l_both_fv3sar_gfs_ens,n_ens_gfs,n_ens_fv3sar,weight_ens_gfs,weight_ens_fv3sar
> >   use rapidrefresh_cldsurf_mod, only: init_rapidrefresh_cldsurf, &
> >                             dfi_radar_latent_heat_time_period,metar_impact_radius,&
> >                             metar_impact_radius_lowcloud,l_gsd_terrain_match_surftobs, &
> >                             l_metar_impact_radius_change, &
> >                             metar_impact_radius_max,metar_impact_radius_min,&
> >                             metar_impact_radius_max_height,metar_impact_radius_min_height,&
> >                             l_sfcobserror_ramp_t, l_sfcobserror_ramp_q, &
> >                             l_pbl_pseudo_surfobst,l_pbl_pseudo_surfobsq,l_pbl_pseudo_surfobsuv, &
> >                             pblh_ration,pps_press_incr,l_gsd_limit_ocean_q, &
> >                             l_pw_hgt_adjust, l_limit_pw_innov, max_innov_pct, &
> >                             l_cleansnow_warmts,l_conserve_thetaV,r_cleansnow_warmts_threshold, &
> >                             i_conserve_thetav_iternum,l_gsd_soiltq_nudge,l_cld_bld, cld_bld_hgt, &
> >                             build_cloud_frac_p, clear_cloud_frac_p,       &
> >                             l_hydrometeor_bkio,nesdis_npts_rad, & 
> >                             iclean_hydro_withRef,iclean_hydro_withRef_allcol, &
> >                             i_use_2mq4b,i_use_2mt4b,i_gsdcldanal_type,i_gsdsfc_uselist, &
> >                             i_lightpcp,i_sfct_gross,l_use_hydroretrieval_all,l_numconc,l_closeobs,&
> >                             i_coastline,i_gsdqc,qv_max_inc,ioption,l_precip_clear_only,l_fog_off,&
> >                             cld_bld_coverage,cld_clr_coverage,&
> >                             i_cloud_q_innovation,i_ens_mean,DTsTmax,&
> >                             i_T_Q_adjust,l_saturate_bkCloud,l_rtma3d,i_precip_vertical_check, &
> >                             corp_howv, hwllp_howv
> >   use gsi_metguess_mod, only: gsi_metguess_init,gsi_metguess_final
> >   use gsi_chemguess_mod, only: gsi_chemguess_init,gsi_chemguess_final
> >   use tcv_mod, only: init_tcps_errvals,tcp_refps,tcp_width,tcp_ermin,tcp_ermax
> >   use chemmod, only : init_chem,berror_chem,berror_fv3_cmaq_regional,oneobtest_chem,&
> >        berror_fv3_sd_regional,&
> >        maginnov_chem,magoberr_chem,&
> >        oneob_type_chem,oblat_chem,&
> >        anowbufr_ext,&
> >        oblon_chem,obpres_chem,diag_incr,elev_tolerance,tunable_error,&
> >        in_fname,out_fname,incr_fname, &
> >        laeroana_gocart, l_aoderr_table, aod_qa_limit, luse_deepblue, lread_ext_aerosol, &
> >        laeroana_fv3cmaq,laeroana_fv3smoke,pm2_5_innov_threshold,pm2_5_urban_innov_threshold,pm2_5_bg_threshold,&
> >        crtm_aerosol_model,crtm_aerosolcoeff_format,crtm_aerosolcoeff_file, &
> >        icvt_cmaq_fv3, raod_radius_mean_scale,raod_radius_std_scale 
> > 
> >   use chemmod, only : wrf_pm2_5,aero_ratios
> >   use gfs_stratosphere, only: init_gfs_stratosphere,use_gfs_stratosphere,pblend0,pblend1
> >   use gfs_stratosphere, only: broadcast_gfs_stratosphere_vars
> >   use general_commvars_mod, only: init_general_commvars,destroy_general_commvars
> >   use radiance_mod, only: radiance_mode_init,radiance_mode_destroy, &
> >        radiance_obstype_destroy
> >   use gsi_nstcouplermod, only: gsi_nstcoupler_init_nml
> >   use gsi_nstcouplermod, only: nst_gsi,nstinfo,zsea1,zsea2,fac_dtl,fac_tsl
> >   use ncepnems_io, only: init_nems,imp_physics,lupp
> >   use wrf_vars_mod, only: init_wrf_vars,fed_exist,dbz_exist
> >   use gsi_rfv3io_mod,only : fv3sar_bg_opt
> >   use radarz_cst,            only: mphyopt, MFflg
> >   use radarz_iface,          only: init_mphyopt
> >   use directDA_radaruse_mod, only: init_radaruse_directDA
> >   use directDA_radaruse_mod, only: coef4dbzfwrd
> >   use directDA_radaruse_mod, only: oe_rw, oe_dbz, refl_lowbnd_rw, refl_lowbnd_dbz, &
> >                                be_sf, hscl_sf, vscl_sf, be_vp, hscl_vp, vscl_vp,   &
> >                                be_t,  hscl_t,  vscl_t,  be_q,  hscl_q,  vscl_q,    &
> >                                be_qr, be_qs, be_qg, hscl_qx, vscl_qx,              &
> >                                l_decouple_sf_vp, l_decouple_sf_tps,                &
> >                                l_set_be_rw, l_set_be_dbz,                          &
> >                                l_set_oerr_ratio_rw, l_set_oerr_ratio_dbz,          &
> >                                l_use_rw_columntilt, l_use_dbz_directDA,            &
> >                                rw_obs4wrd_bmwth, lvldbg,                           &
> >                                l_correct_azmu, l_correct_tilt, i_correct_tilt,     &
> >                                l_azm_east1st, l_use_cvpqx,                         &
> >                                cvpqx_pval,                                         &
> >                                l_plt_be_stats, l_be_T_dep, l_gpht2gmht,            &
> >                                l_plt_diag_rw, l_chk_bmwth,                         &
> >                                i_melt_snow, i_melt_graupel,                        &
> >                                cld_cv, cld_nt_updt,  i_w_updt,                     &
> >                                l_cvpnr, cvpnr_pval, l_use_tdep_radarz
> 97,110c242,245
> <    public :: gsimain_initialize
> <    public :: gsimain_gridopts
> <    public :: gsimain_finalize
> < 
> <    interface gsimain_initialize
> <       module procedure gsimain_initialize_
> <    end interface gsimain_initialize
> <    interface gsimain_gridopts
> <       module procedure gridopts0_
> <       module procedure gridopts1_
> <    end interface gsimain_gridopts
> <    interface gsimain_finalize
> <       module procedure gsimain_finalize_
> <    end interface gsimain_finalize
> ---
> >    public gsimain_initialize
> >    public gsimain_run
> >    public gsimain_finalize
> > 
> 152a288
> > !  10-09-2009 Wu        replace nhr_offset with min_offset since it''s 1.5 hr for regional
> 174c310
> < !                        "use m_mpimod" appears in gridmod.f90.
> ---
> > !                        "use mpimod" appears in gridmod.f90.
> 257d392
> < !  04-21-2014 weir      replaced co settings with trace gas settings
> 288d422
> < !  06-17-2016 Sienkiewicz  virtmp switch for oneobmod
> 319c453
> < !                       by Ming Hu''s "logical l_closeobs" for all variables.
> ---
> > !                       by Ming Hu's "logical l_closeobs" for all variables.
> 323a458,460
> > !  03-29-2019 lei       add integer parameter fv3sar_ensemble_opt to select the format of the FV3SAR ensembles 
> > !                                 =0;  restart files
> > !                                 =1;  cold start IC files from CHGRES
> 334a472,474
> > !  07-29-2019 pondeca   add logical variable "neutral_stability_windfact_2dvar" that provides option to use a simple,
> > !                       similarity theory-based approach to compute the 10-m wind factor for
> > !                       near-surface observations
> 336a477,483
> > !  08-23-2019 pondeca   add logical variable "use_similarity_2dvar" that provides option to use
> > !                       similarity theory from the mm5 sfc model to compute the 10-m wind factor for
> > !                       near-surface observations
> > !  09-04-2019 Martin    Add option write_fv3_incr to write netCDF increment rather than NEMSIO analysis
> > !  09-13-2019 Martin    Add option incvars_to_zero(nvars) to zero out netCDF increment fields
> > !  09-20-2019 Su        add new variational QC and hub norm option
> > !  09-23-2019 Martin    Add option use_gfs_ncio to read in first-guess netCDF file
> 339c486,532
> < !  07-14-2020 todling   add adjustozhscl to scale ozone hscales (>0 will scale by this number)
> ---
> > !  10-28-2019 Martin    Add option incvars_zero_strat(nvars) to zero out increments above tropopause
> > !                          added option use_fv3_aero to choose between NGAC and FV3GFS-GSDChem
> > !  01-27-2020 Winterbottom Moved regression coeffcients for regional
> > !                          model (e.g., HWRF) aircraft recon dynamic
> > !                          observation error (DOE) specification to
> > !                          GSI namelist level (beneath obsmod.F90).
> > !  09-15-2020 Wu        Add option tcp_posmatch to mitigate possibility of erroneous TC initialization
> > !  2021-01-05  x.zhang/lei  - add code for updating delz analysis in regional da
> > !  09-07-2020 CAPS            Add options for directDA_radaruse_mod to use direct radar DA capabilities
> > !  02-09-2021 CAPS(J. Park)   Add vad_near_analtime flag (obsqc) to assimilate newvad obs around analysis time only
> > !  10-10-2019 Zhao      added options l_rtma3d and l_precip_vertical_check
> > !                       (adjustment to the cloud-analysis retrieved profile of
> > !                        Qg/Qs/Qr/QnrQto to alleviate the reflectivity ghost in
> > !                        RTMA3D.)
> > !  04-16-2020 Zhao      change option l_precip_vertical_check to i_precip_vertical_check
> > !                       option for checking and adjusting the profile of Qr/Qs/Qg/Qnr
> > !                       retrieved through cloud analysis to reduce the background
> > !                       reflectivity ghost in analysis. (default is 0)
> > !  2021-11-16 Zhao    - add option l_obsprvdiag (if true) to trigger the output of
> > !                       observation provider and sub-provider information into
> > !                       obsdiags files (used for AutoObsQC)
> > !  01-07-2022 Hu        Add fv3_io_layout_y to let fv3lam interface read/write subdomain restart
> > !                       files. The fv3_io_layout_y needs to match fv3lam model
> > !                       option io_layout(2).
> > !  05-24-2022 H.Wang    Add PM2.5 and AOD DA for regional FV3-CMAQ (RRFS-CMAQ).
> > !                       GSI will perform aerosol analysis when 
> > !                           1. laeroana_fv3cmaq =  .true.
> > !                           2. fv3_regional =      .true.  
> > !                           3. fv3_cmaq_regional = .true. 
> > !                           4. berror_fv3_cmaq_regional = .true. 
> > !  09-02-2022 Jung      Added namelist entries to call a new IR cloud detection routine
> > !                       the original cloud detection routine is the default.  To use the new 
> > !                       cloud detection routine, set the flags to .true.
> > !  09-15-2022 yokota  - add scale/variable/time-dependent localization
> > !  2023-07-30 Zhao    - added namelist options for analysis of significant wave height
> > !                       (aka howv in GSI code): corp_howv, hwllp_howv
> > !                       (in namelist session rapidrefresh_cldsurf)
> > !  
> > !  2023-09-14 H. Wang - add namelist option for FED EnVar DA. 
> > !                        - if_model_fed=.true.        :  FED in background and ens. If
> > !                          perform FED DA, this has to be true along with fed in
> > !                          control/analysis and metguess vectors. If only run GSI observer,
> > !                          it can be false.
> > !                        - innov_use_model_fed=.true. :  Use FED from BG to calculate innovation.
> > !                          this requires if_model_fed=.true. 
> > !                          it works either an EnVar DA run or a GSI observer run.
> > !  02-20-2024 yokota  - add MGBF-based localization
> 345,346d537
> <   character(len=*),parameter :: myname='gsimod'
> < 
> 350c541,542
> <   character(len=*),parameter :: gsimain_rc = 'gsiberror.nml'
> ---
> >   integer(i_kind):: iret_init_mphyopt
> >   integer(i_kind):: iret_coef4dbzfwrd
> 359,360c551,565
> < !     qoption  - option of analysis variable: 1:q/qsatg-bkg 2:norm RH
> < !     cwoption  - option of could-water analysis variable
> ---
> > !     gencode  - source generation code
> > !     factqmin - weighting factor for negative moisture constraint
> > !     factqmax - weighting factor for supersaturated moisture constraint
> > !     superfact- amount of supersaturation allowed 1.01 = 1% supersaturation
> > !     limitqobs- limit q obs to be <= 100%RH based on model temperatures
> > !     clip_supersaturation - flag to remove supersaturation during each outer loop default=.false.
> > !     deltim   - model timestep
> > !     dtphys   - physics timestep
> > !     biascor  - background error bias correction coefficient
> > !     bcoption - =0:do-nothing; =1:sibc; when <0 will estimate but not correct bkg bias
> > !     diurnalbc- 1= diurnal bias; 0= persistent bias
> > !     niter()  - number of inner interations for each outer iteration
> > !     niter_no_qc() - number of inner interations without nonlinear qc for each outer iteration
> > !     miter    - number of outer iterations
> > !     qoption  - option of analysis variable; 1:q/qsatg-bkg 2:norm RH
> 362c567,760
> < !     mockbgk - if .true., use internally defined (fake) background fields
> ---
> > !     fstat    - logical to seperate f from balance projection
> > !     nhr_assimilation - assimilation time interval (currently 6hrs for global, 3hrs for reg)
> > !     min_offset       - time in minutes of analysis in assimilation window (default 3 hours)
> > !     l4dvar           - turn 4D-Var on/off (default=off=3D-Var)
> > !     liauon           - treat 4dvar CV as tendency perturbation (default=false)
> > !     lnested_loops    - allow for nested resolution outer/inner loops
> > !     jsiga            - calculate approximate analysis errors from lanczos for jiter=jsiga
> > !     idmodel          - uses identity model when running 4D-Var (test purposes)
> > !     iwrtinc          - when >0, writes out increments from iwrtinc-index slot
> > !     nhr_obsbin       - length of observation bins
> > !     nhr_subwin       - length of weak constraint 4d-Var sub-window intervals
> > !     iout_iter- output file number for iteration information
> > !     npredp   - number of predictors for precipitation bias correction
> > !     retrieval- logical to turn off or on the SST physical retrieval
> > !     tzr_qc  - indicator to control the Tzr_QC mode: 0 = no Tz retrieval;
> > !                                                     1 = Do Tz retrieval and applied to QC
> > !     tzr_bufrsave - logical to turn off or on the bufr Tz retrieval file true=on
> > !     diag_rad - logical to turn off or on the diagnostic radiance file true=on
> > !     diag_conv-logical to turn off or on the diagnostic conventional file (true=on)
> > !     diag_ozone - logical to turn off or on the diagnostic ozone file (true=on)
> > !     diag_aero  - logical to turn off or on the diagnostic aerosol file (true=on)
> > !     diag_co - logical to turn off or on the diagnostic carbon monoxide file (true=on)
> > !     diag_light - logical to turn off or on the diagnostic lightning file (true=on)
> > !     diag_radardbz - logical to turn off or on the diagnostic radar reflectivity file (true=on)
> > !     diag_fed - logical to turn off or on the diagnostic flash extent density file (true=on)
> > !     write_diag - logical to write out diagnostic files on outer iteration
> > !     lobsdiagsave - write out additional observation diagnostics
> > !     ltlint       - linearize inner loop
> > !     lobskeep     - keep obs from first outer loop for subsequent OL
> > !     lobsensfc    - compute forecast sensitivity to observations
> > !     lobsensjb    - compute Jb sensitivity to observations
> > !     lobsensincr  - compute increment sensitivity to observations
> > !     lobsensadj   - use adjoint of approx. Hessian to compute obs sensitivity
> > !     llancdone    - use to tell adjoint that Lanczos vecs have been pre-computed
> > !     lsensrecompute - does adjoint by recomputing forward solution
> > !     lobsensmin   - use minimisation to compute obs sensitivity
> > !     lbicg        - use B-precond w/ bi-conjugate gradient for minimization
> > !     iobsconv     - compute convergence test in observation space
> > !                     =1 at final point, =2 at every iteration
> > !     lobserver    - when .t., calculate departure vectors only
> > !     lanczosave   - save lanczos vectors for forecast sensitivity computation
> > !     ltcost       - calculate true cost when using Lanczos (this is very expensive)
> > !     lferrscale   - apply H^TR^{-1}H to a forecast error vector read on the fly
> > !     iguess   - flag for guess solution (currently not working)
> > !                iguess = -1  do not use guess file
> > !                iguess =  0  write only guess file
> > !                iguess =  1  read and write guess file
> > !                iguess =  2  read only guess file
> > !     oneobtest- one ob test flag true=on
> > !     switch_on_derivatives - if true, then compute horizontal derivatives of all state variables
> > !                           (to be used eventually for time derivatives, dynamic constraints,
> > !                            and observation forward models that need horizontal derivatives)
> > !     tendsflag - if true, compute time tendencies
> > !     sfcmodel - if true, then use boundary layer forward model for surface temperature data.
> > !     dtbduv_on - if true, use d(microwave brightness temperature)/d(uv wind) in inner loop
> > !     ifact10 - flag for recomputing 10m wind factor
> > !               ifact10 = 1 compute using GFS surface physics
> > !               ifact10 = 2 compute using MM5 surface physics
> > !               ifact10 = 0 or any other value - DO NOT recompute - use value from guess file
> > !     offtime_data - if true, then allow use of obs files with ref time different
> > !                        from analysis time.  default value = .false., in which case
> > !                        analysis fails if obs file ref time is different from analysis time.
> > !
> > !     perturb_obs - logical flag to perutrb observation (true=on)
> > !     tcp_posmatch - integer =1 to move TC to guess position,
> > !                            =2 set pges to the minimum Psfc 
> > !     tcp_box      - integer to define the search box size in gridpoints, default =5 
> > !                    used with option tcp_posmatch
> > !     oberror_tune - logical flag to tune oberror table  (true=on)
> > !     perturb_fact -  magnitude factor for observation perturbation
> > !     crtm_coeffs_path - path of directory w/ CRTM coeffs files
> > !     print_diag_pcg - logical turn on of printing of GMAO diagnostics in pcgsoi.f90
> > !     preserve_restart_date - if true, then do not update regional restart file date.
> > !     tsensible - option to use sensible temperature as the analysis variable. works
> > !                 only for twodvar_regional=.true.
> > !     hilbert_curve - option for hilbert-curve based cross-validation. works only
> > !                     with twodvar_regional=.true.
> > !     neutral_stability_windfact_2dvar - option to use simple, similarity
> > !                                        theory-based approach to compute 10-m wind factor
> > !     use_similarity_2dvar - option to use similarity theory from the mm5 sfc model
> > !                            to compute 10-m wind factor
> > !     lread_obs_save - option to write out collective obs selection info
> > !     lread_obs_skip - option to read in collective obs selection info
> > !     use_gfs_ozone  - option to read in gfs ozone and interpolate to regional model domain
> > !     check_gfs_ozone_date  - option to date check gfs ozone before interpolating to regional model domain
> > !     regional_ozone  - option to turn on ozone in regional analysis
> > !     lwrite_predterms - option to write out actual predictor terms instead of predicted bias to the
> > !                        radiance diagnostic files
> > !     lwrite_peakwt    - option to writ out the approximate pressure of the peak of the weighting function
> > !                        for satellite data to the radiance diagnostic files
> > !     adp_anglebc - option to perform variational angle bias correction
> > !     angord      - order of polynomial for variational angle bias correction
> > !     newpc4pred  - option for additional preconditioning for pred coeff.
> > !     passive_bc  - option to turn on bias correction for passive (monitored) channels
> > !     reset_bad_radbc - option to turn on reseting bias correction coefficient when it is bad
> > !     use_edges   - option to exclude radiance data on scan edges
> > !     biaspredvar - set background error variance for radiance bias coeffs
> > !     (default 0.1K)
> > !     use_compress - option to turn on the use of compressibility factors in geopotential heights
> > !     nsig_ext - number of layers above the model top which are necessary to compute the bending angle for gpsro
> > !     gpstop - maximum height for gpsro data assimilation. Reject anything above this height. 
> > !     commgpstop -Reject commercial ro above this height. Logic in setupbend assumes commgpstop <= gpstop.
> > !     commgpserrinf - optional error inflation factor for commercial gpsro data
> > !     use_gfs_nemsio  - option to use nemsio to read global model NEMS/GFS first guess
> > !     use_gfs_ncio - option to use netCDF to read global model FV3-GFS first guess
> > !     use_fv3_aero - option to use FV3-Chem vs NGAC for global aerosol analysis
> > !     sfcnst_comb   - option to use nemsio sfc history file by regriding FV3 grid
> > !     use_readin_anl_sfcmask  - option to use readin surface mask
> > !     use_prepb_satwnd - allow using satwnd''s from prepbufr (historical) file
> > !     id_drifter  -  option to identify drifting buoy observations (modify KX from 180/280)
> > !     id_ship     -  option to identify ship          observations (modify KX from 180)
> > !     use_gfs_stratosphere - for now, can only be set to true if nems_nmmb_regional=true.  Later extend
> > !                             to other regional models.  When true, a guess gfs valid at the same time
> > !                             as the nems-nmmb guess is used to replace the upper levels with gfs values.
> > !                             The nems-nmmb vertical coordinate is smoothly merged between pressure values
> > !                             pblend0,pblend1 so that below pblend0 the vertical coordinate is the original
> > !                             nems-nmmb, and above pblend1 it becomes the gfs vertical coordinate.  For
> > !                             the current operational nems-nmmb and gfs vertical coordinates and
> > !                             pblend0=152mb, pblend1=79mb, the merged nems-nmmb/gfs vertical coordinate
> > !                             has 75 levels compared to nems-nmmb original 60 levels.  The purpose of this
> > !                             is to allow direct use of gdas derived sat radiance bias correction coefs,
> > !                             since it has been determined that height of top level and stratosphere
> > !                             resolution are key to successful assimilation of most channels.
> > !                                   (NOTE: I have not actually verified this statement yet!)
> > !     pblend0,pblend1 - see above comment for use_gfs_stratosphere
> > !     l4densvar - logical to turn on ensemble 4dvar
> > !     ens_nstarthr - start hour for ensemble perturbations (generally should match min_offset)
> > !     lwrite4danl - logical to write out 4d analysis states if 4dvar or 4denvar mode
> > !     nhr_anal - forecast hours to write out if lwrite4danal=T
> > !     ladtest -  if true, doing the adjoint test for the operator that maps
> > !                    control_vector to the model state_vector
> > !     ladtest_obs -  if true, doing the adjoint adjoint check for the
> > !                     observation operators that are currently used in the NCEP GSI variational
> > !                     analysis scheme
> > !     lrun_subdirs - logical to toggle use of subdirectires at runtime for pe specific files
> > !     mpes_observer - informs Solver number of PEs used to run Observer
> > !     emiss_bc    - option to turn on emissivity bias predictor
> > !     lsingleradob - logical for single radiance observation assimilation.
> > !                   Uses existing bufr file and rejects all radiances that don''t fall within a tight threshold around
> > !                   oblat/oblon (SINGLEOB_TEST)
> > !
> > !     ssmis_method - choose method for SSMIS noise reduction 0=no smoothing 1=default
> > !     ssmis_precond - weighting factor for SSMIS preconditioning (if not using newpc4pred)
> > !     gmi_method - choose method for GMI noise reduction. 0=no smoothing, 4=default
> > !     amsr2_method - choose method for AMSR2 noise reduction. 0=no smoothing, 5=default
> > !     bias_zero_start - Initialise bias correction from zero (default=true,
> > !                        false=mode start method)
> > !     ec_amv_qc - If true use additional QC from ECMWF addressing issues with
> > !                         upper level GOES-16/17 winds (default = true)
> > !     R_option   - Option to use variable correlation length for lcbas based on data
> > !                    density - follows Hayden and Purser (1995) (twodvar_regional only)
> > !     thin4d - if true, removes thinning of observations due to the location in
> > !              the time window
> > !     lobsdiag_forenkf - if true, save linearized H operator (jacobian) in
> > !     diagnostic file on 1st outer iteration.  The Jacobian can then be used by
> > !     the EnKF to compute ensemble perturbations in observation space.
> > !     luse_obsdiag - use obsdiags (useful when running EnKF observers; e.g., echo Jo table) 
> > !     imp_physics - type of GFS microphysics
> > !     lupp - if T, UPP is used and extra variables are output
> > !     lcalc_gfdl_cfrac - if T, calculate and use GFDL cloud fraction in observation operator 
> > !     cao_check - if T, turn on cold-air-outbreak screening for quality control
> > !     binary_diag - trigger binary diag-file output (being phased out)
> > !     netcdf_diag - trigger netcdf diag-file output
> > !     write_fv3_incr - trigger writing out FV3 netCDF increment file
> > !                      rather than NEMSIO analysis
> > !     incvars_to_zero - list of strings of variable names in FV3 netCDF
> > !                       increment file that should be forced to be zero
> > !     incvars_zero_strat - list of strings of variable names in FV3 netcdf
> > !                          increment file that will be reduced to zero
> > !                          above the tropopause
> > !     incvars_efold - scale factor x in which e^(-(k-ktrop)/x) for above fields 
> > !
> > !     diag_version - specifies desired version of diag files
> > !     l_wcp_cwm - namelist logical whether to use swcp/lwcp operator that includes cwm
> > !     aircraft_recon - namelist logical whether to apply DOE to aircraft data
> > !     tau_fcst - controls EFSOI-like calculation
> > !     efsoi_order - sets order of EFSOI-like calculation
> > !     lupdqc - logical to replace the obs errors from satinfo with diag of est(R) in the case of correlated obs
> > !     lqcoef - logical to combine the inflation coefficients generated by qc with est(R)
> > !     ta2tb - logical to use brightness temperature (SDR) instead of antenna
> > !             temperature (TDR) for assimilation
> > !     l_use_rw_columntilt - option to assimilate radar column-tilt radial wind obs in GSI 
> > !                     (.TRUE.: on; .FALSE.: off) / Inputfile: l2rwbufr_cltl (bufr format)
> > !     l_use_dbz_directDA - option to assimilate radar reflectivity obs directly in GSI 
> > !                     (.TRUE.: on; .FALSE.: off) / Inputfile: dbzbufr (bufr format)
> > !     l_obsprvdiag - trigger (if true) writing out observation provider and sub-provider
> > !                    information into obsdiags files (used for AutoObsQC)
> > !     optconv - downweighting option for iasi and cris for moisture channels to
> > !     improve convergence.  default 0.0 (no change).  Larger number improves
> > !     convergence.
> > !     inflate_dbz_obserr - logical that controls inflation of reflectivity ob error
> > !                          for obs that exceed gross error magnitude
> > !                          if true, inflate ob error
> > !                          if false, reject ob
> 363a762,763
> > !     NOTE:  for now, if in regional mode, then iguess=-1 is forced internally.
> > !            add use of guess file later for regional mode.
> 365,372c765,807
> <   namelist/setup/&
> <        pseudo_q2,&
> <        cwoption,&
> <        qoption,&
> <        verbose,&
> <        l4densvar,&
> <        nmn_obsbin,&
> <        mockbkg
> ---
> >   namelist/setup/gencode,factqmin,factqmax,superfact,limitqobs,clip_supersaturation, &
> >        factql,factqi,factqr,factqs,factqg, &     
> >        factv,factl,factp,factg,factw10m,facthowv,factcldch,R_option,deltim,dtphys,&
> >        biascor,bcoption,diurnalbc,&
> >        neutral_stability_windfact_2dvar,use_similarity_2dvar,&
> >        niter,niter_no_qc,miter,qoption,cwoption,nhr_assimilation,&
> >        min_offset,pseudo_q2,&
> >        iout_iter,npredp,retrieval,&
> >        tzr_qc,tzr_bufrsave,&
> >        diag_rad,diag_pcp,diag_conv,diag_ozone,diag_aero,diag_co,diag_light,diag_radardbz,diag_fed, &
> >        iguess,write_diag,reduce_diag, &
> >        oneobtest,sfcmodel,dtbduv_on,ifact10,l_foto,offtime_data,&
> >        use_pbl,use_compress,nsig_ext,gpstop,commgpstop, commgpserrinf, &
> >        perturb_obs,perturb_fact,oberror_tune,preserve_restart_date, &
> >        crtm_coeffs_path,berror_stats,tcp_posmatch,tcp_box, &
> >        newpc4pred,adp_anglebc,angord,passive_bc,use_edges,emiss_bc,upd_pred,reset_bad_radbc,&
> >        ssmis_method, ssmis_precond, gmi_method, amsr2_method, bias_zero_start, &
> >        ec_amv_qc, lobsdiagsave, lobsdiag_forenkf, &
> >        l4dvar,lbicg,lsqrtb,lcongrad,lbfgsmin,ltlint,nhr_obsbin,nhr_subwin,&
> >        mPES_observer,&
> >        alwaysLocal,&
> >        use_fv3_aero,&
> >        nwrvecs,iorthomax,ladtest,ladtest_obs, lgrtest,lobskeep,lsensrecompute,jsiga,ltcost, &
> >        lobsensfc,lobsensjb,lobsensincr,lobsensadj,lobsensmin,iobsconv, &
> >        idmodel,iwrtinc,lwrite4danl,nhr_anal,jiterstart,jiterend,lobserver,lanczosave,llancdone, &
> >        lferrscale,print_diag_pcg,tsensible,lread_obs_save,lread_obs_skip, &
> >        use_gfs_ozone,check_gfs_ozone_date,regional_ozone,lwrite_predterms,&
> >        lwrite_peakwt,use_gfs_nemsio,use_gfs_ncio,sfcnst_comb,liauon,use_prepb_satwnd,l4densvar,ens_nstarthr,&
> >        use_gfs_stratosphere,pblend0,pblend1,step_start,diag_precon,lrun_subdirs,&
> >        use_sp_eqspace,lnested_loops,lsingleradob,thin4d,use_readin_anl_sfcmask,&
> >        luse_obsdiag,id_drifter,id_ship,verbose,print_obs_para,lsingleradar,singleradar,lnobalance, &
> >        inflate_dbz_obserr,missing_to_nopcp,minobrangedbz,minobrangedbz,maxobrangedbz,&
> >        maxobrangevr,maxtiltvr,whichradar,doradaroneob,dofedoneob,oneoblat,&
> >        oneoblon,oneobheight,oneobvalue,oneobddiff,oneobradid,&
> >        rmesh_vr,zmesh_dbz,zmesh_vr, ntilt_radarfiles, whichradar,&
> >        radar_no_thinning,ens_hx_dbz_cut,static_gsi_nopcp_dbz,rmesh_dbz,&
> >        minobrangevr, maxtiltdbz, mintiltvr,mintiltdbz,if_vterminal,if_vrobs_raw,if_use_w_vr,&
> >        if_model_dbz,if_model_fed,innov_use_model_fed,imp_physics,lupp,netcdf_diag,binary_diag,l_wcp_cwm,aircraft_recon,diag_version,&
> >        write_fv3_incr,incvars_to_zero,incvars_zero_strat,incvars_efold,diag_version,&
> >        cao_check,lcalc_gfdl_cfrac,tau_fcst,efsoi_order,lupdqc,lqcoef,cnvw_option,l2rwthin,hurricane_radar,&
> >        l_reg_update_hydro_delz, l_obsprvdiag,&
> >        l_use_dbz_directDA, l_use_rw_columntilt, ta2tb, optconv, &
> >        r_hgt_fed
> 376d810
> < !     jcap_b   - background spectral resolution (when applicable)
> 380c814,844
> < !     use_sp_eqspace    - if .true., then ensemble grid is equal spaced, staggered 1/2 grid unit off
> ---
> > !     hybrid   - logical hybrid data file flag true=hybrid
> > !     nlon_regional - 
> > !     nlat_regional
> > !     diagnostic_reg - logical for regional debugging
> > !     update_regsfc - logical to write out updated surface fields to the
> > !                     regional analysis file (default = false)
> > !     netcdf            - if true, then wrf files are in netcdf format,
> > !                       -   otherwise wrf files are in binary format.
> > !     regional          - logical for regional GSI run
> > !     wrf_nmm_regional  - logical for input from WRF NMM
> > !     fv3_regional      - logical for input from FV3 regional
> > !     wrf_mass_regional - logical for input from WRF MASS-CORE
> > !     cmaq_regional     - logical for input from CMAQ
> > !     nems_nmmb_regional- logical for input from NEMS NMMB
> > !     nmmb_reference_grid= 'H', then analysis grid covers H grid domain
> > !                                = 'V', then analysis grid covers V grid domain
> > !     grid_ratio_nmmb   - ratio of analysis grid to nmmb model grid in nmmb model grid units.
> > !     grid_ratio_fv3_regional - ratio of analysis grid to fv3 grid in fv3 grid units.
> > !     fv3_io_layout_y    - set to the same number as io_layout of fv3 regional model in y direction.
> > !     grid_ratio_wrfmass - ratio of analysis grid to wrf mass grid in wrf grid units.
> > !     grid_type_fv3_regional - type of fv3 model grid (grid orientation).
> > !     twodvar_regional  - logical for regional 2d-var analysis
> > !     filled_grid       - logical to fill in puts on WRF-NMM E-grid
> > !     half_grid         - logical to use every other row of WRF-NMM E-Grid
> > !     nvege_type - number of types of vegetation; old=24, IGBP=20
> > !     nlayers    - number of sub-layers to break indicated model layer into
> > !                  prior to calling radiative transfer model
> > !     jcap_gfs   - spectral truncation used to transform high wavenumber
> > !                  spectral coefficients to a coarser resolution grid,
> > !                  when use_gfs_ozone = .true. or use_gfs_stratosphere = .true.   
> > !     use_sp_eqspac     - if .true., then ensemble grid is equal spaced, staggered 1/2 grid unit off
> 381a846
> > !     wrf_mass_hybridcord - logical for using WRF MASS CORE with hybrid vertical coordinate
> 384,385c849,853
> <   namelist/gridopts/jcap,jcap_b,nlat,nlon,nsig,use_sp_eqspace,fv3_regional,grid_ratio_fv3_regional,&
> <                     regional,mpas_regional
> ---
> >   namelist/gridopts/jcap,jcap_b,nsig,nlat,nlon,nlat_regional,nlon_regional,&
> >        diagnostic_reg,update_regsfc,netcdf,regional,wrf_nmm_regional,nems_nmmb_regional,fv3_regional,fv3_cmaq_regional,&
> >        wrf_mass_regional,twodvar_regional,filled_grid,half_grid,nvege_type,nlayers,cmaq_regional,&
> >        nmmb_reference_grid,grid_ratio_nmmb,grid_ratio_fv3_regional,grid_ratio_wrfmass,jcap_gfs,jcap_cut,&
> >        wrf_mass_hybridcord,grid_type_fv3_regional,fv3_io_layout_y
> 412d879
> < !     adjustozhscl - when > 0, scales ozone horizontal scales by this number
> 415,416c882,942
> < 	bkgv_flowdep,bkgv_rewgtfct,bkgv_write,fpsproj,adjustozvar,fut2ps,cwcoveqqcov,adjustozhscl,&
7,12c4194,13575
< >         simcv,bkgv_write_cv,bkgv_write_sv,usenewgfsberror
< diff -r ../../../../../sorc/gsibec/src/gsibec/gsi/mod_fv3_lola.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/gsibec/src/gsibec/gsi/mod_fv3_lola.f90
< 263a264,265
< >   if (allocated(coeffx )) deallocate(coeffx )
< >   if (allocated(coeffy )) deallocate(coeffy )
< 829c831
---
> >       bkgv_flowdep,bkgv_rewgtfct,bkgv_write,fpsproj,adjustozvar,fut2ps,cwcoveqqcov,usenewgfsberror
> > 
> > ! ANBKGERR (anisotropic background error related variables):
> > !     anisotropic - if true, then use anisotropic background error
> > !     ancovmdl    - covariance model settings - 0: pt-based, 1: ensemble based
> > !     triad4      - for 2d variables, if true, use blended triad algorithm
> > !     ifilt_ord   - filter order for anisotropic filters
> > !     npass       - 2*npass = number of factors in background error
> > !     normal      - number of random vectors to use for filter normalization
> > !                     ( if < 0 then slightly slower, but results independent of
> > !                       number of processors)
> > !     binom       - if true, weight correlation lengths of factors using binomial
> > !                      distribution, with shortest scales on outside, longest scales
> > !                      on inside.  This can help to produce smoother correlations in the
> > !                      presence of strong anisotrophy
> > !     grid_ratio  - ratio of coarse to fine grid in fine grid units
> > !     grid_ratio_p- ratio of coarse to fine grid in fine grid units for polar patches
> > !     nord_f2a    - order of interpolation for transfer operators between filter grid and analysis grid
> > !     ngauss      - number of gaussians to add together in each factor
> > !     rgauss      - multipliers on reference aspect tensor for each gaussian factor
> > !     anhswgt     - empirical weights to apply to each gaussian
> > !     an_vs       - scale factor for background error vertical scales (temporary carry over from
> > !                    isotropic inhomogeneous option)
> > !     an_flen_u   -  coupling parameter for connecting horizontal wind to background error
> > !     an_flen_t   -  coupling parameter for connecting grad(pot temp) to background error
> > !     an_flen_z   -  coupling parameter for connecting grad(terrain) to background error
> > !     afact0      - anistropy effect parameter, the range must be in 0.0-1.0.
> > !     covmap      - if true, covariance map would be drawn
> > !     rtma_subdomain_option - if true, then call alternative code which calls recursive filter
> > !                              directly from subdomain mode, bypassing transition to/from
> > !                              horizontal slabs.  This is mainly to improve efficiency for
> > !                              2d rtma analysis.  at the moment, this only works for
> > !                              twodvar_regional=.true.  rtma_subdomain_option will be forced
> > !                              to false when twodvar_regional=.false.
> > !     rtma_bkerr_sub2slab - if true, then run recursive filter in slab mode
> > !     lreadnorm   -  if true, then read normalization from fixed files
> > !     nsmooth     -  number of 1-2-1 smoothing passes before and after background error application
> > !     nsmooth_shapiro - number of 2nd moment preserving (shapiro) smoothing passes before and after
> > !                       background error application.
> > !                        NOTE:  default for nsmooth and nsmooth_shapiro is 0.
> > !                               if both are > 0, then nsmooth will be forced to zero.
> > 
> >   namelist/anbkgerr/anisotropic,ancovmdl,triad4,ifilt_ord,npass,normal,binom,&
> >        ngauss,rgauss,anhswgt,an_vs, &
> >        grid_ratio,grid_ratio_p,nord_f2a,an_flen_u,an_flen_t,an_flen_z, &
> >        rtma_subdomain_option,rtma_bkerr_sub2slab,lreadnorm,nsmooth,nsmooth_shapiro, &
> >        afact0,covmap
> > 
> > ! JCOPTS (Jc term)
> > !                 if .false., uses original formulation based on wind, temp, and ps tends
> > !     ljcdfi      - when .t. uses digital filter initialization of increments (4dvar)
> > !     alphajc     - parameter for digital filter
> > !     ljpdry      - when .t. uses dry pressure constraint on increment
> > !     bamp_jcpdry - parameter for pdry_jc
> > !     eps_eer     - Errico-Ehrendofer parameter for q-term in energy norm
> > !     ljc4tlevs    - when true and in 4D mode, apply any weak constraints over all time levels
> > !                   instead of just at a single time
> > !
> > 
> >   namelist/jcopts/ljcdfi,alphajc,switch_on_derivatives,tendsflag,ljcpdry,bamp_jcpdry,eps_eer,&
> >       ljc4tlevs,ljclimqc 
> 430c956
> < !     baldiag_full
> ---
> > !     baldiag_full 
> 440c966
> <   namelist/strongopts/tlnmc_option, &
> ---
> >   namelist/strongopts/reg_tlnmc_type,tlnmc_option, &
> 442c968,1331
> <                       baldiag_full,baldiag_inc
> ---
> > 		      baldiag_full,baldiag_inc
> > 
> > ! OBSQC (observation quality control variables):
> > !
> > !     Parameters used for gross error checks
> > !        obserrx = max(ermin,min(ermax,obs error)
> > !        if(abs(simulated)-observation)/obserrx > gross observation rejected
> > !
> > !
> > !     Parameters below use for nonlinear (variational) quality control
> > !     dfact    - factor for duplicate obs at same location for conv. data
> > !     dfact1   - time factor for duplicate obs at same location for conv. data
> > !     erradar_inflate - radar error inflation factor
> > !     tdrerr_inflate - logical for tdr obs error inflation
> > !     oberrflg - logical for reading in new obs error table (if set to true)
> > !     vadfile  - character(10) variable holding name of vadwnd bufr file
> > !     noiqc    - logical flag to bypass OIQC (if set to true)
> > !     c_varqc - constant number to control var. qc turnning on speed
> > !     blacklst - logical for reading in raob blacklist (if set to true)
> > !     use_poq7 - logical flag to accept (.true.) sbuv profile quality flag 7
> > !     tcp_refps  - reference pressure for tcps oberr calculation (mb)
> > !     tcp_width  - parameter for tcps oberr inflation (width, mb)
> > !     tcp_ermin  - parameter for tcps oberr inflation (minimum oberr, mb)
> > !     tcp_ermax  - parameter for tcps oberr inflation (maximum oberr, mb)
> > !     gps_jacqc  - logical to turn on GNSSRO Jacobian QC (default is off)
> > !     qc_noirjaco3 - controls whether to use O3 Jac from IR instruments
> > !     qc_noirjaco3_pole - controls wheter to use O3 Jac from IR instruments near poles
> > !     qc_satwnds - allow bypass sat-winds qc normally removing lots of mid-tropo obs
> > !     aircraft_t_bc_pof  - logical for aircraft temperature bias correction, pof
> > !                          is used for predictor
> > !     aircraft_t_bc  - logical for aircraft temperature bias correction
> > !     aircraft_t_bc_ext - logical for reading aircraft temperature bias correction from external file
> > !     buddycheck_t - When true, run buddy check algorithm on temperature observations
> > !     buddydiag_save - When true, output files containing buddy check QC info for all
> > !                      obs run through the buddy check
> > !     njqc  -  When true, use Purser''s non linear QC
> > !     vqc   -  when true, use ECMWF's non linear QC
> > !     nvqc   -  when true, use Dr. Purser's variational QC 
> > !     hub_norm - when true,use huber norm format distribution 
> > !     closest_obs- when true, choose the timely closest surface observation from
> > !     multiple observations at a station.  Currently only applied to Ceiling
> > !     height and visibility.
> > !     pvis   - power parameter in nonlinear transformation for vis 
> > !     pcldch - power parameter in nonlinear transformation for cldch
> > !     scale_cv - scaling constant in meter
> > !     estvisoe - estimate of vis observation error
> > !     estcldchoe - estimate of cldch observation error
> > !     vis_thres  - threshold value for both vis observation and input first guess
> > !     cldch_thres  - threshold value for both cldch observation and input first guess
> > !     cld_det_dec2bin - re-interprets cld_det in satinfo as binary entries
> > !     ompslp_mult_fact - multiplication factor for OMPS LP obserror read in
> > 
> > ! The following variables are the coefficients that describe the
> > ! linear regression fits that are used to define the dynamic
> > ! observation error (DOE) specifications for all reconnissance
> > ! observations collected within hurricanes/tropical cyclones; these
> > ! apply only to the regional forecast models (e.g., HWRF); Henry
> > ! R. Winterbottom (henry.winterbottom@noaa.gov).
> > 
> > ! Observation types:
> > 
> > ! 1/236: HDOB (e.g., flight-level) observations.
> >        
> > ! 1/237: Dropsonde observations.
> > 
> > ! 213: SFMR observations.
> > 
> > ! The following correspond to the specific humidity (q) observations:
> > 
> > !     q_doe_a_136, q_doe_a_137 - specific humidity linear regression
> > !                                derived 'a' coefficients for specific
> > !                                humidity observations.
> > 
> > !     q_doe_b_136, q_doe_b_137 - specific humidity linear regression
> > !                                derived 'b' coefficients for specific
> > !                                humidity observations.
> > 
> > !     t_doe_a_136, t_doe_a_137 - temperature linear regression derived
> > !                                'a' coefficients for temperature
> > !                                observations.
> > 
> > !     t_doe_b_136, t_doe_b_137 - temperature linear regression derived
> > !                                'b' coefficients for temperature
> > !                                observations.  
> > 
> > !     uv_doe_a_236, uv_doe_a_237, uv_doe_a_213 - wind linear
> > !                                                regression derived
> > !                                                'a' coefficients for
> > !                                                wind observations.
> > 
> > !     uv_doe_b_236, uv_doe_b_237, uv_doe_b_213 - wind linear
> > !                                                regression derived
> > !                                                'b' coefficients for
> > !                                                wind observations.
> > 
> > !     vad_near_analtime - assimilate newvadwnd obs around analysis time only
> > !
> > !     Flags to use the new IR cloud detection routine.  Flag must be set to true to use the new routine.  The default
> > !     (no flag or .false.) will use the default.
> > !     airs_cads: use the clod and aerosool detection software for the AIRS instrument
> > !     cris_cads: use the cloud and aerosol detection software for CrIS instruments
> > !     iasi_cads: use the cloud and aerosol detection software for IASI instruments
> > !     
> >   
> >   namelist/obsqc/dfact,dfact1,erradar_inflate,tdrerr_inflate,oberrflg,&
> >        vadfile,noiqc,c_varqc,blacklst,use_poq7,hilbert_curve,tcp_refps,tcp_width,&
> >        tcp_ermin,tcp_ermax,gps_jacqc,qc_noirjaco3,qc_noirjaco3_pole,qc_satwnds,njqc,vqc,nvqc,hub_norm,troflg,lat_c,nrand,&
> >        aircraft_t_bc_pof,aircraft_t_bc,aircraft_t_bc_ext,biaspredt,upd_aircraft,cleanup_tail,&
> >        hdist_aircraft,buddycheck_t,buddydiag_save,vadwnd_l2rw_qc,ompslp_mult_fact,  &
> >        pvis,pcldch,scale_cv,estvisoe,estcldchoe,vis_thres,cldch_thres,cld_det_dec2bin, &
> >        q_doe_a_136,q_doe_a_137,q_doe_b_136,q_doe_b_137, &
> >        t_doe_a_136,t_doe_a_137,t_doe_b_136,t_doe_b_137, &
> >        uv_doe_a_236,uv_doe_a_237,uv_doe_a_213,uv_doe_b_236,uv_doe_b_237,uv_doe_b_213, &
> >        vad_near_analtime,airs_cads,cris_cads,iasi_cads
> > 
> > ! OBS_INPUT (controls input data):
> > !      dmesh(max(dthin))- thinning mesh for each group
> > !      time_window_max  - upper limit on time window for all input data
> > !      time_window_rad  - upper limit on time window for certain radiance input data
> > !      ext_sonde        - logical for extended forward model on sonde data
> > !      l_foreaft_thin -   separate TDR fore/aft scan for thinning
> > 
> >   namelist/obs_input/dmesh,time_window_max,time_window_rad, &
> >        ext_sonde,l_foreaft_thin,hofx_2m_sfcfile
> > 
> > ! SINGLEOB_TEST (one observation test case setup):
> > !      maginnov   - magnitude of innovation for one ob
> > !      magoberr   - magnitude of observational error
> > !      oneob_type - observation type (lsingleradob: platform type, i.e. 'airs')
> > !      oblat      - observation latitude (lsingleradob: footprint cenlat)
> > !      oblon      - observation longitude (lsingleradob: footprint cenlon)
> > !      obpres     - observation pressure
> > !      obdattim   - observation date
> > !      obhourset  - observation delta time from analysis time
> > !      pctswitch  - if .true. innovation & oberr are relative (%) of background value
> > !                      (level ozone only)
> > !      obchan     - if > 0, selects the channel number.  If <= zero, it will use
> > !                   all channels that pass qc in setuprad.    
> > 
> >   namelist/singleob_test/maginnov,magoberr,oneob_type,&
> >        oblat,oblon,obpres,obdattim,obhourset,pctswitch,&
> >        obchan,anel_rw,anaz_rw,range_rw,sstn,learthrel_rw
> > 
> > ! SUPEROB_RADAR (level 2 bufr file to radar wind superobs):
> > !      del_azimuth     - azimuth range for superob box  (default 5 degrees)
> > !      del_elev        - elevation angle range for superob box  (default .05 degrees)
> > !      del_range       - radial range for superob box  (default 5 km)
> > !      del_time        - 1/2 time range for superob box  (default .5 hours)
> > !      elev_angle_max  - max elevation angle (default of 5 deg recommended by S. Liu)
> > !      minnum                  - minimum number of samples needed to make a superob
> > !      range_max       - max radial range to use in constructing superobs  (default 100km)
> > !      l2superob_only  - if true, then process level 2 data creating superobs, then quit.
> > !                          (added for easier retrospective testing, since level 2 bufr
> > !                             files are very large and hard to work with)
> > 
> >   namelist/superob_radar/del_azimuth,del_elev,del_range,del_time,&
> >        elev_angle_max,minnum,range_max,l2superob_only,radar_sites,radar_box,radar_rmesh,radar_zmesh
> > 
> > ! RADARUSE_directDA
> > !     mphyopt          - microphysics scheme to use in the forward operator
> > !                        (2-6(LIN) and 108(TM) are supported for now)
> > !     oe_rw            - observerion error of radar radial wind obs (m/s)
> > !                        default=1.0
> > !     oe_dbz           - observerion error of radar reflectivity (dbz)
> > !                        default=1.0
> > !     l_set_be_rw      - re-set background error statistics for using radar wind
> > !                        obs (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     l_set_be_dbz     - re-set background error statistics for using radar dbz
> > !                        obs (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !    l_set_oerr_ratio_rw  - re-set obs error (inflation ratio) for radar wind
> > !                           assimilation (.TRUE.: on  ; .FALSE.: off)
> > !                           default=.false.
> > !    l_set_oerr_ratio_dbz - re-set obs error (inflation ratio) for radar 
> > !                           reflectivity assimilation 
> > !                           (.TRUE.: on  ; .FALSE.: off)
> > !                           default=.false.
> > !     be_sf            - multiplying factor to tune the background error
> > !                        standard deviation of stream function (s.f.)
> > !                        default=0.2/4.5 
> > !     hscl_sf          - horizontal background error correlation length scale of
> > !                        stream function (meter)
> > !                        default=20000.
> > !     vscl_sf          - vertical background error correlation length scale of
> > !                        stream function
> > !                        default=1.5
> > !     be_vp            - multiplying factor to tune the background error
> > !                        standard deviation of velocity potential (v.p.)
> > !                        default=0.2/4.5 
> > !     hscl_vp          - horizontal background error correlation length scale of
> > !                        velocity potential (meter)
> > !                        default=20000.
> > !     vscl_vp          - vertical background error correlation length scale of
> > !                        velocity potential
> > !                        default=1.5
> > !     be_t             - multiplying factor to tune the background error
> > !                        standard deviation of temperature (t)
> > !                        default=-1.0
> > !     hscl_t           - horizontal background error correlation length scale of
> > !                        temperature
> > !                        default=-20000.
> > !     vscl_t           - vertical background error correlation length scale of
> > !                        temperature
> > !                        default=-1.5
> > !     be_q             - multiplying factor to tune the background error
> > !                        standard deviation of moisture mixing ratio (q)
> > !                        default=-1.0
> > !     hscl_q           - horizontal background error correlation length scale of
> > !                        moisture mixing ratio
> > !                        default=-20000.
> > !     vscl_q           - vertical background error correlation length scale of
> > !                        moisture mixing ratio
> > !                        default=-1.5
> > !     be_qr            - background error standard deviation for mixing ratio of
> > !                        rain water (kg/kg)
> > !                        default=1.0E-3
> > !     be_qs            - background error standard deviation for mixing ratio of
> > !                        snow water (kg/kg)
> > !                        default=1.0E-3
> > !     be_qg            - background error standard deviation for mixing ratio of
> > !                        graupel (kg/kg)
> > !                        default=1.0E-3
> > !     hscl_qx          - horizontal correlation length scale for mixing ratio of
> > !                        cloud hydrometers (meter)
> > !                        default=6000.
> > !     vscl_qx          - vertical   correlation length scale for mixing ratio of
> > !                        cloud hydrometers
> > !                        default=1.5
> > !     l_decouple_sf_vp  - de-couple the correlation/balance 
> > !                         between s.f. and v.p.
> > !                         (.TRUE.: on  ; .FALSE.: off)
> > !                         default=.false.
> > !     l_decouple_sf_tps - de-couple the correlation/balance
> > !                         between s.f. and temperature, ps
> > !                         (.TRUE.: on  ; .FALSE.: off)
> > !                         default=.false.
> > !     rw_obs4wrd_bmwth - beam width impact on radar wind obs forward operator
> > !                        default=2
> > !                        ! 1: GSI original (vrminmax)
> > !                        ! 2: simple vertical interpolation
> > !                        ! 3: weighted average of multiple-layers
> > !     lvldbg           - debugging level regarding to directDA code
> > !                        default=0
> > !     l_correct_azmu   - options for correction of azimuth angles of 
> > !                        radar observations (used in read_radar.f90)
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.true.
> > !     l_correct_tilt   - options for correction of tilt angles of 
> > !                        radar observations (used in read_radar.f90)
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.true.
> > !     i_correct_tilt   - options for algorithm to compute corrected tilt
> > !                        default=2
> > !                        ! 1. equations used in GSI;
> > !                        ! 2. equations used in ARPS
> > !     l_azm_east1st    - change azimuth to east as 0 before correct it
> > !                        default=.true.
> > !     l_use_cvpqx      - use power transform to qx (qr/qs/qg)
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     cvpqx_pval       - power value to qx(qr/qs/qg)
> > !                        default=0.000001
> > !     l_plt_be_stats   - output background error statistics for plot
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.true.
> > !     l_be_T_dep       - temperature dependent error variance
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     l_gpht2gmht      - convert goepotential height to geometric height 
> > !                        (used in setupdbz.f90)
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     refl_lowbnd_rw   - lower-bound of obs dbz for rw assimilation
> > !                        default=5.
> > !                        (if obs_dbz < dbz_lowbnd_dbz, then
> > !                         the rw (wind) obs accompanied with
> > !                         this obs_dbz  is rejected for rw assimilation)
> > !     refl_lowbnd_dbz  - lower-bound of obs dbz for dbz assimilation
> > !                        default=0.
> > !                        (if obs_dbz < dbz_lowbnd_dbz, then
> > !                         this obs_dbz is rejected for dbz assimilation)
> > !     l_plt_diag_rw    - options for checking-up and diagnose of radial wind
> > !                        (used in setuprw and read_radar)
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     l_chk_bmwth      - options for checking-up and diagnose of radial wind
> > !                        (used in setuprw and read_radar)
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     i_melt_snow      - control the melting effect 
> > !                        in dbz obs forward operator for snow
> > !                        default=0
> > !                        ! < 0 : no melting, and keeping dry at
> > !                        !       any temperature
> > !                        ! >=0 : melting depends on
> > !                        !       temperature ! (273.15 K)
> > !                        ! =100: melting and keeping wet at
> > !                        !       any temperature
> > !     i_melt_graupel   - control the melting effect 
> > !                        in dbz obs forward operator for graupel
> > !                        default=0
> > !                        ! < 0 : no melting, and keeping dry all
> > !                        !       the time
> > !                        ! >=0 : melting depends on
> > !                        !       temperature ! (273.15 K)
> > !                        ! =100: melting and keeping wet at
> > !                        !       any temperature
> > !     cld_cv           - cloud hydrometers used as control variables 
> > !                        in analysis
> > !                        default=0
> > !     cld_nt_updt      - cloud hydrometer number concentration 
> > !                        default=1
> > !                        ! 0: no update to number concentration
> > !                        ! 1: updated through analysis (for now,
> > !                        ! only in hybrid analysis)
> > !     i_w_updt         - w (vertical velocity) is analysis variable 
> > !                        and updated
> > !                        default=0
> > !                        ! 0: not analyzed ; 1: analyzed
> > !     l_cvpnr          - use power tranform for qnr
> > !                        (.TRUE.: on  ; .FALSE.: off)
> > !                        default=.false.
> > !     cvpnr_pval       - power value for qnr
> > !                        default=.0.6
> > !     MFflg            - Flag to determine what options are selected
> > !                        to calculate fraction of wet mixing ratio (melting)
> > !                        Affects only for TM operator in EnKF application
> > !                        default = 3
> > !                        1 – melting based on the ratio between qr and qx
> > !                        2 – melting is not considered
> > !                        3 – temperature-based melting
> > !     l_use_tdep_radarz – use temperature dependent feature in radarZ,
> > !                         if it is set as .TRUE., GSI provide tk to radarZ
> > !                         if not used, ta is set as constant (273.16K)
> > !                         Affects only for TM operator in EnKF
> > !                         default = .true.
> > !
> >   namelist/radaruse_directDA/mphyopt,oe_rw,oe_dbz,l_set_be_rw,l_set_be_dbz,   &
> >                          l_set_oerr_ratio_rw, l_set_oerr_ratio_dbz,       &
> >                          be_sf,hscl_sf,vscl_sf,be_vp,hscl_vp,vscl_vp,     &
> >                          be_q, hscl_q, vscl_q, be_t, hscl_t, vscl_t,      &
> >                          be_qr, be_qs, be_qg, hscl_qx, vscl_qx,           &
> >                          l_decouple_sf_vp,l_decouple_sf_tps,              &
> >                          rw_obs4wrd_bmwth, lvldbg,                        &
> >                          l_correct_azmu, l_correct_tilt, i_correct_tilt,  &
> >                          l_azm_east1st, l_use_cvpqx, cvpqx_pval,          &
> >                          l_plt_be_stats,                                  &
> >                          l_be_T_dep, l_gpht2gmht,                         &
> >                          refl_lowbnd_rw, refl_lowbnd_dbz,                 &
> >                          l_plt_diag_rw, l_chk_bmwth,                      &
> >                          i_melt_snow, i_melt_graupel,                     &
> >                          cld_cv, cld_nt_updt, i_w_updt,                   &
> >                          l_cvpnr, cvpnr_pval, MFflg, l_use_tdep_radarz
> > 
> > ! LAG_DATA (lagrangian data assimilation related variables):
> > !     lag_accur - Accuracy used to decide whether or not a balloon is on the grid
> > !     infile_lag- File containing the initial position of the balloon
> > !     lag_stepduration- Duration of one time step for the propagation model
> > !     lag_nmax_bal- Maximum number of balloons at starting time
> > !     lag_vorcore_stderr_a - Observation error for vorcore balloon
> > !     lag_vorcore_stderr_b -   error = b + a*timestep(in hours)
> >   namelist/lag_data/lag_accur,infile_lag,lag_stepduration,lag_nmax_bal,&
> >       lag_vorcore_stderr_a,lag_vorcore_stderr_b
> 466,468c1355,1370
> < !     s_ens_h             - homogeneous isotropic horizontal ensemble localization scale (km)
> < !     s_ens_v             - vertical localization scale (grid units for now)
> < !                              s_ens_h, s_ens_v, and beta_s0 are tunable parameters.
> ---
> > !     beta_e0 - default weight given to ensemble background error covariance
> > !               (if .not. readin_beta). if beta_e0<0, then it is set to
> > !               1.-beta_s0 (this is the default)
> > !     s_ens_h - horizontal localization correlation length of Gaussian exp(-0.5*(r/L)**2)
> > !               (units of km), default = 2828.0
> > !     s_ens_v - vertical localization correlation length of Gaussian exp(-0.5*(r/L)**2)
> > !               (grid units if s_ens_v>=0, or units of ln(p) if s_ens_v<0), default = 30.0
> > !                  in scale/variable/time-dependent localization (SDL/VDL/TDL),
> > !                  localization length for i-th scale, j-th variable, and k-th time is
> > !                     s_ens_[hv]( i + nsclgrp*(j-1) + nsclgrp*ngvarloc*(k-1) )
> > !                        in SDL(nsclgrp>1),         i = 1(largest scale)  .. nsclgrp(smallest scale)
> > !                        in VDL(ngvarloc=2),        j = 1(itracer<=10)    .. 2(itracer>=11)
> > !                        in TDL(l_timloc_opt=true), k = 1(first time bin) .. ntlevs_ens(last time bin)
> > !                  in SDL, scale separation length for i-th scale is also set here as
> > !                     s_ens_[hv]( naensgrp+i ) - naensgrp is the total number of localization lengths for SDL/VDL/TDL
> > !                        in applying SDL only horizontally, set s_ens_v(naensgrp+i)=0.0
> 506,515c1408,1462
> < !     bens_recenter - center Bens around background/guess
> < !     upd_ens_spread - update ens spread with recentering around guess 
> < !     upd_ens_localization - update ens localizations (goes together w/ upd_ens_spread)
> < !     ens_fname_tmpl - provides template name of ensmeble members
> < !              
> < !                         
> <   namelist/hybrid_ensemble/l_hyb_ens,uv_hyb_ens,q_hyb_ens,aniso_a_en,generate_ens,n_ens,nlon_ens,nlat_ens,jcap_ens,&
> <                 pseudo_hybens,merge_two_grid_ensperts,regional_ensemble_option,full_ensemble,pwgtflg,&
> <                 jcap_ens_test,beta_s0,s_ens_h,s_ens_v,readin_localization,eqspace_ensgrid,readin_beta,&
> <                 grid_ratio_ens, ens_fname_tmpl, &
> ---
> > !     nsclgrp - number of scale-dependent localization lengths
> > !     l_timloc_opt - if true, then turn on time-dependent localization
> > !     ngvarloc - number of variable-dependent localization lengths
> > !     naensloc - total number of spatial localization lengths and scale separation lengths (should be naensgrp+nsclgrp-1)
> > !     r_ensloccov4tim - factor multiplying to cross-time covariance
> > !                         For example,
> > !                         =0.0: cross-time covariance is decreased to zero
> > !                         =0.5: cross-time covariance is decreased to half
> > !                         =1.0: cross-time covariance is retained
> > !     r_ensloccov4var - factor multiplying to cross-variable covariance
> > !                         For example,
> > !                         =0.0: cross-variable covariance is decreased to zero
> > !                         =0.5: cross-variable covariance is decreased to half
> > !                         =1.0: cross-variable covariance is retained
> > !     r_ensloccov4scl - factor multiplying to cross-scale covariance
> > !                         For example,
> > !                         =0.0: cross-scale covariance is decreased to zero
> > !                         =0.5: cross-scale covariance is decreased to half
> > !                         =1.0: cross-scale covariance is retained
> > !     global_spectral_filter_sd - if true, use spectral filter function for
> > !                                 scale decomposition in the global application (Huang et al. 2021)
> > !     assign_vdl_nml - if true, vdl_scale, and vloc_varlist will be used for
> > !                      assigning variable-dependent localization upon SDL in gsiparm.anl.
> > !                      This method described in (Wang and Wang 2022, JAMES) is
> > !                      equivalent to, but different from the method associated
> > !                      with the parameter r_ensloccov4var.
> > !     vloc_varlist - list of control variables using the same localization length,
> > !                     effective only with assign_vdl_nml=.true. For example,
> > !                     vloc_varlist(1,:) = 'sf','vp','ps','t',
> > !                     vloc_varlist(2,:) = 'q',
> > !                     vloc_varlist(3,:) = 'qr','qs','qg','dbz','w','ql','qi',
> > !                     vloc_varlist(4,:) = 'sf','vp','ps','t','q',
> > !                     vloc_varlist(5,:) = 'qr','qs','qg','dbz','w','ql','qi',
> > !                     This example indicates that 3 variable-groups will be adopted for VDL. 
> > !                     'sf','vp','ps','t' will share the same localization length of v1L1; 
> > !                     'q' will have the localization lenth of v2L1
> > !                     'qr','qs','qg','dbz','w','ql','qi', use the same localization length of v3L1
> > !
> > !                     For L2, a different configuration of VDL can be applied:
> > !                               ~~~~~~~~~
> > !                     'sf','vp','ps','t','q' will share the same localization length of v2L2; 
> > !                     'qr','qs','qg','dbz','w','ql','qi', use the same localization length of v2L2
> > !     vdl_scale - number of variables in each variable-group, effective only with assign_vdl_nml=.true.
> > !                 if 3 variable-groups with 2 separated scale is set, 
> > !                 vdl_scale = 3,    3,    3,   2,    2
> > !                             ^     ^     ^    ^     ^ 
> > !                 s_ens_h  = v1L1  v2L1  v3L1  v1L2 v2L2
> > !                 Then localization lengths will be assigned as above.
> > !     l_mgbf_loc - if true, multi-grid beta filter is used for localization instead of recursive filter
> > !
> >   namelist/hybrid_ensemble/l_hyb_ens,uv_hyb_ens,q_hyb_ens,aniso_a_en,generate_ens,n_ens,&
> >                 l_both_fv3sar_gfs_ens,n_ens_gfs,n_ens_fv3sar,weight_ens_gfs,weight_ens_fv3sar,nlon_ens,nlat_ens,jcap_ens,&
> >                 pseudo_hybens,merge_two_grid_ensperts,regional_ensemble_option,fv3sar_bg_opt,fv3sar_ensemble_opt,full_ensemble,pwgtflg,&
> >                 jcap_ens_test,beta_s0,beta_e0,s_ens_h,s_ens_v,readin_localization,eqspace_ensgrid,readin_beta,&
> >                 grid_ratio_ens, &
> 517,518c1464,1721
> <                 i_en_perts_io,l_ens_in_diff_time,ensemble_path,ens_fast_read,sst_staticB,&
> <                 bens_recenter,upd_ens_spread,upd_ens_localization,EnsSource
> ---
> >                 i_en_perts_io,l_ens_in_diff_time,ensemble_path,ens_fast_read,sst_staticB,limqens, &
> >                 nsclgrp,l_timloc_opt,ngvarloc,naensloc,r_ensloccov4tim,r_ensloccov4var,r_ensloccov4scl,&
> >                 vdl_scale,vloc_varlist,&
> >                 global_spectral_filter_sd,assign_vdl_nml,parallelization_over_ensmembers,l_mgbf_loc
> > 
> > ! rapidrefresh_cldsurf (options for cloud analysis and surface 
> > !                             enhancement for RR appilcation  ):
> > !      dfi_radar_latent_heat_time_period     -   DFI forward integration window in minutes
> > !      metar_impact_radius  - metar low cloud observation impact radius in grid number
> > !      l_metar_impact_radius_change - if .true. the impact radius will change
> > !                            with height that set up with the metar_impact_radius_max, min,
> > !                            max_height, min_height, (default:false)
> > !      metar_impact_radius_max  - The max impact radius of metar cloud observation
> > !                            in meter (default: 100000 m).
> > !      metar_impact_radius_min  - The min impact radius of metar cloud observation
> > !                            in meter (default: 10000 m).
> > !      metar_impact_radius_max_height - The hight above which metar_impact_radius_max apply
> > !                            in meter (default: 1200m).
> > !      metar_impact_radius_min_height - The hight below which metar_impact_radius_min apply
> > !                            in meter (default: 200m).
> > !      l_gsd_terrain_match_surftobs - if .true., GSD terrain match for surface temperature observation
> > !      l_sfcobserror_ramp_t  - namelist logical for adjusting surface temperature observation error
> > !      l_sfcobserror_ramp_q  - namelist logical for adjusting surface moisture observation error
> > !      l_pbl_pseudo_surfobst  - if .true. produce pseudo-obs in PBL layer based on surface obs T
> > !      l_pbl_pseudo_surfobsq  - if .true. produce pseudo-obs in PBL layer based on surface obs Q
> > !      l_pbl_pseudo_surfobsuv - if .true. produce pseudo-obs in PBL layer based on surface obs UV
> > !      pblh_ration - percent of the PBL height within which to add pseudo-obs (default:0.75)
> > !      pps_press_incr - pressure increase for each additional pseudo-obs 
> > !                       on top of previous level (default:30hPa)
> > !      l_gsd_limit_ocean_q      - if .true. do GSD limitation of Q over ocean
> > !      l_pw_hgt_adjust      - if .true. do GSD PW adjustment for model vs. obs station height
> > !      l_limit_pw_innov     - if .true. do GSD limitation of PW obs
> > !      max_innov_pct        - sets limit of PW ob to a percent of the background value (0-1)
> > !      l_cleansnow_warmts   - if .true. do GSD limitation of using retrieved snow over warn area
> > !                                               (Ts > r_cleansnow_warmts_threshold) 
> > !      r_cleansnow_warmts_threshold - threshold for using retrieved snow over warn area
> > !      l_conserve_thetaV    - if .true. conserve thetaV during moisture adjustment in cloud analysis
> > !      i_conserve_thetav_iternum    - iteration number for conserving thetaV during moisture adjustment
> > !      l_gsd_soiltq_nudge   - if .true. do GSD soil T and Q nudging based on the lowest t analysis inc
> > !      l_cld_bld            - if .true. do GSD GOES cloud building
> > !      cld_bld_hgt          - sets limit below which GOES cloud building occurs (default:1200m)
> > !      build_cloud_frac_p   - sets the threshold for building clouds from satellite
> > !      clear_cloud_frac_p   - sets the threshold for clearing clouds from satellite
> > !      nesdis_npts_rad  - NESDIS cloud product impact radiu (grid points)
> > !      iclean_hydro_withRef - if =1, then clean hydrometeors if the grid point
> > !                               has no echo and maxref=0
> > !      iclean_hydro_withRef_allcol - if =1, then clean whole column hydrometeors
> > !                      if the observed max ref =0 and satellite cloud shows
> > !                      clean
> > !      i_use_2mq4b    -  background used for calculate surface moisture observation
> > !                               innovation
> > !                         =0  Use Q from the 1st model level. (default) 
> > !                         =1  use 2m Q as part of background
> > !      i_use_2mt4b    -  background used for calculate surface temperature         
> > !                             observation innovation
> > !                         =0  Use T from the 1st model level. (default)
> > !                         =1  use 2m T as part of background 
> > !      i_gsdcldanal_type    - options for how GSD cloud analysis should be conducted         
> > !                         =0. no cloud analysis (default)
> > !                         =1.  cloud analysis after var analysis for WRF_ARW
> > !                         =2.  cloud analysis after var analysis for NMMB
> > !                         =3.  cloud analysis only; var is skipped
> > !                         =5.  skip cloud analysis and updating NETCDF result file at
> > !                                         the end of the analysis
> > !                         =6.  skip NETCDF background read step and do cloud analysis only
> > !                         =7   cloud analysis in observer with I/O
> > !                         =30  cloud analysis for GFS
> > !                         =99  only read hydrometer fields but no cloud analysis
> > 
> > !      i_gsdsfc_uselist  - options for how to use surface observation use or
> > !                          rejection list
> > !                         =0 . EMC method (default)
> > !                         =1 . GSD method
> > !      i_lightpcp        - options for how to deal with light precipitation
> > !                         =0 . don''t add light precipitation (default)
> > !                         =1 . add light precipitation in warm section
> > !      i_sfct_gross      - if use extended threshold for surface T gross check
> > !                         =0 use threshold from convinfo (default)
> > !                         =1 for cold surface, threshold for gross check is
> > !                         enlarged to bring more large negative innovation into
> > !                         analysis.
> > !      l_numconc         - namelist logical to update cloud water and cloud ice
> > !                          number concentrations. 
> > !                         =false do not update num conc
> > !                         =true update num conc
> > !      l_use_hydroretrieval_all - the precipitation analysis use reflectivity
> > !                                 purely
> > !      l_closeobs        - namelist logical to pick the obs close to analysis
> > !                          time.
> > !                         =false do not pick, use obs error inflation with duplication
> > !                         =true only pick the obs close to analysis time only.
> > !      i_coastline        - options to turn on observation operator for coastline surface observations
> > !                         =0. turn off observation operator for coastline
> > !                         surface observations (default)
> > !                         =1.  for temperature surface observations
> > !                         =2.  for moisture surface observations
> > !                         =3.  for temperature and moisture surface observations
> > !      i_gsdqc            - option i_gsdqc to turn on special observation qc
> > !                              from GSD (for RAP/HRRR application)
> > !                         =0 turn off
> > !                         =2 turn on
> > !      qv_max_inc        - threshold to limit the maximum water vapor increment
> > !      ioption           - interpolation option for satellite mapping 
> > !                         =1  if selection is nearest neighbor
> > !                         =2  if selection is median of samples
> > !      l_precip_clear_only - the precipitation analysis only clears; it does not
> > !                            make any updates for positive precipitating hydrometeors
> > !      l_fog_off           - turn off using fog observations
> > !      cld_bld_coverage    - cloud coverage required for qc/qi building
> > !      cld_clr_coverage    - cloud coverage required for qc/qi clearing
> > !      i_cloud_q_innovation - integer to choose if and how cloud obs are used
> > !                          0= no innovations 
> > !                          1= cloud total innovations
> > !                          20= cloud build/clear derived water vapor innovations
> > !                          21= cloud build derived water vapor innovations
> > !                          22= cloud clear derived water vapor innovations
> > !                          3= cloud total & water vapor innovations
> > !      i_ens_mean    - integer for setupcldtot behavior
> > !                           0=single model run
> > !                           1=ensemble mean
> > !                           2=ensemble members
> > !      DTsTmax       - maximum allowed difference between Tskin and the first
> > !                           level T. This is to safety guard soil T adjustment.
> > !      i_T_Q_adjust -     =0 no temperature and moisture adjustment in hydrometeor analyis
> > !                         =1 (default) temperature and moisture are adjusted in hydrometeor analyis
> > !                         =2 temperature and moisture only adjusted for clearing (warmer, drier)
> > !      l_saturate_bkCloud - if .true. ensure saturation for all cloud 3-d points in background
> > !                           where observed cloud cover is missing (default:true).
> > !      l_rtma3d      - logical option for turning on configuration for RTMA3D
> > !                           (default is .FALSE.)
> > !      i_precip_vertical_check - integer option for checking and adjusting
> > !                                Qr/Qs/Qg and Qnr after cloud analysis
> > !                                to reduce the background reflectivity ghost in
> > !                                analysis. (default is 0)
> > !                           = 0(no adjustment)
> > !                           = 1(Clean off Qg only, where dbz_obs_max<=35dbz in the profile)
> > !                           = 2(clean Qg as in 1, and adjustment to the retrieved Qr/Qs/Qnr throughout the whole profile)
> > !                           = 3(similar to 2, but adjustment to Qr/Qs/Qnr only below maximum reflectivity level
> > !                             and where the dbz_obs is missing);
> > !      corp_howv     - real, static background error of howv (stddev error)
> > !                           = 0.42 meters (default)
> > !      hwllp_howv    - real, background error de-correlation length scale of howv 
> > !                           = 170,000.0 meters (default 170 km)
> > !
> >   namelist/rapidrefresh_cldsurf/dfi_radar_latent_heat_time_period, &
> >                                 metar_impact_radius,metar_impact_radius_lowcloud, &
> >                                 l_metar_impact_radius_change,metar_impact_radius_max,&
> >                                 metar_impact_radius_min,metar_impact_radius_max_height,&
> >                                 metar_impact_radius_min_height,l_gsd_terrain_match_surftobs, &
> >                                 l_sfcobserror_ramp_t,l_sfcobserror_ramp_q, &
> >                                 l_pbl_pseudo_surfobst,l_pbl_pseudo_surfobsq,l_pbl_pseudo_surfobsuv, &
> >                                 pblh_ration,pps_press_incr,l_gsd_limit_ocean_q, &
> >                                 l_pw_hgt_adjust, l_limit_pw_innov, max_innov_pct, &
> >                                 l_cleansnow_warmts,l_conserve_thetaV,r_cleansnow_warmts_threshold,  &
> >                                 i_conserve_thetav_iternum,l_gsd_soiltq_nudge,l_cld_bld, cld_bld_hgt, &
> >                                 build_cloud_frac_p, clear_cloud_frac_p,   &
> >                                 nesdis_npts_rad, &
> >                                 iclean_hydro_withRef,iclean_hydro_withRef_allcol,&
> >                                 i_use_2mq4b,i_use_2mt4b,i_gsdcldanal_type,i_gsdsfc_uselist, &
> >                                 i_lightpcp,i_sfct_gross,l_use_hydroretrieval_all,l_numconc,l_closeobs,&
> >                                 i_coastline,i_gsdqc,qv_max_inc,ioption,l_precip_clear_only,l_fog_off,&
> >                                 cld_bld_coverage,cld_clr_coverage,&
> >                                 i_cloud_q_innovation,i_ens_mean,DTsTmax, &
> >                                 i_T_Q_adjust,l_saturate_bkCloud,l_rtma3d,i_precip_vertical_check, &
> >                                 corp_howv, hwllp_howv
> > 
> > ! chem(options for gsi chem analysis) :
> > !     berror_chem       - .true. when background  for chemical species that require
> > !                          conversion to lower case and/or species names longer than 5 chars
> > !     berror_fv3_cmaq_regional   - .true. use background error stat for online
> > !                                         RRFS_CMAQ model. Control variable
> > !                                         names extended up to 10 chars
> > !     berror_fv3_sd_regional     - .true. use background error stat for online
> > !                                         RRFS_SD model. Control variable
> > !                                         names extended up to 10 chars
> > !     oneobtest_chem    - one-ob trigger for chem constituent analysis
> > !     maginnov_chem     - O-B make-believe residual for one-ob chem test
> > !     magoberr_chem     - make-believe obs error for one-ob chem test
> > !     oneob_type_chem   - type of chem-ob for one-ob test
> > !     oblat_chem        - latitude of make-believe chem obs
> > !     oblon_chem        - longitude of make-believe chem obs
> > !     obpres_chem       - pressure level of make-believe chem obs
> > !     diag_incr         - increment for CMAQ
> > !     elev_tolerance    - in meters when surface PM observation rejected due to elevation
> > !                         disparity in background and observation
> > !     tunable_error     - a factor to calculate representativeness error for PM observations
> > !     in_fname          - CMAQ input filename
> > !     out_fname         - CMAQ output filename
> > !     incr_fname        - CMAQ increment filename
> > !     laeroana_gocart   - when true, do chem analysis with wrfchem (or NGAC)
> > !     laeroana_fv3cmaq  - when true, do chem analysis with fv3 lam (both fv3_cmaq_regional and fv3_regional are true!) 
> > !     l_aoderr_table    - whethee to use aod error table or default error
> > !     aod_qa_limit      - minimum acceptable value of error flag for total column AOD
> > !     luse_deepblue     - whether to use MODIS AOD from the deepblue   algorithm
> > !     lread_ext_aerosol - if true, reads aerfNN file for aerosol arrays rather than sigfNN (NGAC NEMS IO)
> > 
> >   namelist/chem/berror_chem,berror_fv3_cmaq_regional,berror_fv3_sd_regional,& 
> >        oneobtest_chem,anowbufr_ext,maginnov_chem,magoberr_chem,&
> >        oneob_type_chem,oblat_chem,oblon_chem,obpres_chem,&
> >        diag_incr,elev_tolerance,tunable_error,&
> >        in_fname,out_fname,incr_fname,&
> >        laeroana_gocart, laeroana_fv3cmaq,laeroana_fv3smoke,l_aoderr_table, aod_qa_limit, &
> >        crtm_aerosol_model,crtm_aerosolcoeff_format,crtm_aerosolcoeff_file, &
> >        icvt_cmaq_fv3,pm2_5_innov_threshold, &
> >        pm2_5_innov_threshold,pm2_5_urban_innov_threshold,pm2_5_bg_threshold,&
> >        raod_radius_mean_scale,raod_radius_std_scale, luse_deepblue,&
> >        aero_ratios,wrf_pm2_5, lread_ext_aerosol
> > 
> > ! NST (NSST control namelist) :
> > !     nst_gsi  - indicator to control the Tr Analysis mode: 0 = no nst info in gsi at all;
> > !                                                           1 = input nst info, but used for monitoring only
> > !                                                           2 = input nst info, and used in CRTM simulation, but no Tr analysis
> > !                                                           3 = input nst info, and used in CRTM simulation and Tr analysis is on
> > !     nstinfo  - number of nst variables
> > !     zsea1    - upper depth (in mm) for vertical mean of T based on NSST T-Profile
> > !     zsea2    - lower depth (in mm) for vertical mean of T based on NSST T-Profile
> > !     fac_dtl  - index to apply diurnal thermocline layer  or not: 0 = no; 1 = yes.
> > !     fac_tsl  - index to apply thermal skin layer or not: 0 = no; 1 = yes.
> >    namelist/nst/nst_gsi,nstinfo,zsea1,zsea2,fac_dtl,fac_tsl
> > 
> > !  Initialize the Cloud and Aerosol Detection Software (CADS) 
> > !
> > !     M__Sensor                     Unique ID for sensor
> > !     N__Num_Bands                  Number of channel bands
> > !     N__Band_Size(:)               Number of channels in each band
> > !     N__Bands(:,:)                 Channel lists
> > !     N__Window_Width(:)            Smoothing filter window widths per band
> > !     N__Window_Bounds(:,:)         Channels in the spectral window gradient check
> > !     N__GradChkInterval(:)         Window width used in gradient calculation
> > !     R__BT_Threshold(:)            BT threshold for cloud contamination
> > !     R__Grad_Threshold(:)          Gradient threshold for cloud contamination
> > !     R__Window_Grad_Threshold(:)   Threshold for window gradient check in QE
> > !     L__Do_Quick_Exit              On/off switch for the Quick Exit scenario
> > !     L__Do_CrossBand               On/off switch for the cross-band method
> > !     N__BandToUse(:)               Band number assignment for each channel
> > !     L__Do_Imager_Cloud_Detection  On/off switch for the imager cloud detection
> > !     N__Num_Imager_Chans           No. of imager channels
> > !     N__Num_Imager_Clusters        No. of clusters to be expected
> > !     N__Imager_Chans(:)            List of imager channels
> > !     R__Stddev_Threshold(:)        St. Dev. threshold, one for each imager channel
> > !     R__Coverage_Threshold         Threshold for fractional coverage of a cluster
> > !     R__FG_Departure_Threshold     Threshold for imager FG departure
> > 
> >    NAMELIST / Cloud_Detect_Coeffs / M__Sensor, N__Num_Bands,            &
> >            N__Band_Size, N__Bands, N__Window_Width, N__Window_Bounds,   &
> >            N__GradChkInterval, R__BT_Threshold, R__Grad_Threshold,      &
> >            R__Window_Grad_Threshold, L__Do_Quick_Exit,                  &
> >            L__Do_CrossBand, N__BandToUse,                               &
> >            L__Do_Imager_Cloud_Detection, N__Num_Imager_Chans,           &
> >            N__Num_Imager_Clusters, N__Imager_Chans,                     &
> >            R__Stddev_Threshold, R__Coverage_Threshold,                  &
> >            R__FG_Departure_Threshold
> > 
> > 
> > !EOC
> > 
> > !---------------------------------------------------------------------------
> > 
> 530c1733
> <   subroutine gsimain_initialize_(nfldsig,nmlfile)
> ---
> >   subroutine gsimain_initialize
> 535,536c1738,1744
> <   use gsi_fixture_GEOS, only: config_GEOS => fixture_config
> <   use gsi_fixture_GFS,  only: config_GFS  => fixture_config
> ---
> >   use m_gpsStats, only: gpsStats_create ! was done within obsmod::create_obsmod_vars()
> >   use m_prad    , only: prad_create     ! was obsmod::create_passive_obsmod_vars()
> >   use m_obsdiags, only: obsdiags_create ! was done within obsmod::create_obsmod_vars()
> > 
> >   use mpeu_util,only: die
> >   use gsi_4dcouplermod, only: gsi_4dcoupler_parallel_init
> >   use gsi_4dcouplermod, only: gsi_4dcoupler_setservices
> 538,544c1746,1747
> <   integer,optional,intent(in):: nfldsig
> <   character(len=*),optional,intent(in):: nmlfile
> < 
> <   character(len=*),parameter :: myname_=myname//'*gsimain_initialize'
> <   integer:: ier,ios,lendian_in,nfldsig_
> <   logical:: flag
> <   logical:: already_init_mpi
> ---
> >   character(len=*),parameter :: myname_='gsimod.gsimain_initialize'
> >   integer:: ier,ios
> 546c1749
> <   character(len=255) :: thisrc
> ---
> >   type(regional_io_class) :: regional_io
> 548,557c1751,1760
> <   ierror=0
> <   if (present(nmlfile)) then
> <      thisrc = trim(nmlfile)
> <   else
> <      thisrc = gsimain_rc
> <   endif
> <   nfldsig_ = 1
> <   if (present(nfldsig)) then
> <     nfldsig_ = nfldsig
> <   endif
> ---
> >   call gsi_4dcoupler_parallel_init
> > 
> >   call mpi_comm_size(mpi_comm_world,npe,ierror)
> >   call mpi_comm_rank(mpi_comm_world,mype,ierror)
> >   if (mype==0) call w3tagb('GSI_ANL',1999,0232,0055,'NP23')
> > 
> > ! Initialize defaults of vars in modules
> >   call init_4dvar
> >   call regional_io%init_regional_io
> >   call init_nems
> 560,564c1763,1768
> <   call gsi_metguess_init(rcname=thisrc)
> <   call gsi_chemguess_init(rcname=thisrc)
> <   call init_anasv(rcname=thisrc)
> <   call init_anacv(rcname=thisrc)
> <   call init_anadv(rcname=thisrc)
> ---
> >   call gsi_metguess_init
> >   call gsi_chemguess_init
> >   call init_anasv
> >   call init_anacv
> >   call init_wrf_vars
> >   call radiance_mode_init
> 566,567d1769
> <   call init_io(mype,npe-1)
> <   call jfunc_init
> 569c1771,1781
> <   call init_constants(regional)
> ---
> >   call init_oneobmod
> >   call init_qcvars
> >   call init_obsmod_dflts
> >   call init_pcp
> >   call init_light
> >   call init_rad
> >   call init_oz
> >   call init_aero
> >   call init_co
> >   call init_convinfo
> >   call init_jfunc
> 571a1784
> >   call init_anberror  ! RTodling: alloc vectors should move to create
> 572a1786
> >   call init_turbl
> 574c1788,1789
> <   call init_smooth_polcas
> ---
> >   call init_smooth_polcas  
> >   call init_jcvars
> 575a1791,1792
> >   call initialize_superob_radar
> >   call init_io(mype,npe-1)
> 576a1794
> >   call init_obsens
> 577a1796,1800
> >   call init_rapidrefresh_cldsurf
> >   call init_chem
> >   call init_tcps_errvals
> >   call init_aircraft
> >   call init_gfs_stratosphere
> 579c1802,1807
> <   call init_4dvar
> ---
> >   call gsi_nstcoupler_init_nml
> >   call init_radaruse_directDA
> >   call CADS_Setup_Cloud
> > 
> >  if(mype==0) write(6,*)' at 0 in gsimod, use_gfs_stratosphere,nems_nmmb_regional = ', &
> >                        use_gfs_stratosphere,nems_nmmb_regional
> 587c1815,1837
> <   open(11,file=thisrc)
> ---
> > #ifdef ibm_sp
> > ! Initialize table of instruments and data types
> >   read(5,setup) 
> >   read(5,gridopts)
> > 
> > ! call to obsmod_init_instr_table must be after setup and gridopts are read in
> >   call obsmod_init_instr_table(nhr_assimilation,ndat)
> >   read(5,bkgerr)
> >   read(5,anbkgerr)
> >   read(5,jcopts)
> >   read(5,strongopts)
> >   read(5,obsqc)
> >   read(5,obs_input)
> >   read(5,superob_radar)
> >   read(5,lag_data)
> >   read(5,hybrid_ensemble)
> >   read(5,rapidrefresh_cldsurf)
> >   read(5,chem)
> >   read(5,nst)
> > #else
> > ! Initialize table of instruments and data types
> >   call obsmod_init_instr_table(nhr_assimilation,ndat,rcname='gsiparm.anl')
> >   open(11,file='gsiparm.anl')
> 592c1842,1846
> <   call gridopts0_(thisrc)
> ---
> >   open(11,file='gsiparm.anl')
> >   read(11,gridopts,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(gridopts)',ios)
> > 
> > ! call to obsmod_init_instr_table must be after setup and gridopts are read in
> 594d1847
> <   open(11,file=thisrc)
> 597d1849
> <   close(11)
> 599c1851,1856
> <   open(11,file=thisrc)
> ---
> >   read(11,anbkgerr,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(anbkgerr)',ios)
> > 
> >   read(11,jcopts,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(jcopts)',ios)
> > 
> 601,604c1858,1871
> <   if(ios/=0) then
> <     call warn(myname_,'using default(strongopts)')
> <   endif
> <   close(11)
> ---
> >   if(ios/=0) call die(myname_,'read(strongopts)',ios)
> > 
> >   read(11,obsqc,iostat=ios)
> > 
> >   if(ios/=0) call die(myname_,'read(obsqc)',ios)
> > 
> >   read(11,obs_input,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(obs_input)',ios)
> > 
> >   read(11,superob_radar,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(superob_radar)',ios)
> > 
> >   read(11,lag_data,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(lag_data)',ios)
> 606d1872
> <   open(11,file=thisrc)
> 608,611c1874
> <   if(ios/=0) then
> <      call warn(myname_,'using default(hybrid_ensemble)')
> <   endif
> <   close(11)
> ---
> >   if(ios/=0) call die(myname_,'read(hybrid_ensemble)',ios)
> 613,622c1876,1883
> <   if (l_hyb_ens) then
> <     select case (trim(uppercase(EnsSource)))
> <       case("GEOS")
> <         call config_GEOS()
> <       case("GFS")
> <         call config_GFS()
> <       case default
> <         call die(myname_,': unknown ensemble source')
> <     end select
> <   endif
> ---
> >   read(11,rapidrefresh_cldsurf,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(rapidrefresh_cldsurf)',ios)
> > 
> >   read(11,chem,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(chem)',ios)
> > 
> >   read(11,nst,iostat=ios)
> >   if(ios/=0) call die(myname_,'read(nst)',ios)
> 623a1885,1886
> >   close(11)
> > #endif
> 630a1894,1940
> >   if(vqc .and. niter_no_qc(1) < niter(1))then
> >      varqc_max=c_varqc*(niter(1)-niter_no_qc(1))
> >      if(varqc_max < one .and. varqc_max > zero)then
> >         c_varqc_new=one/(niter(1)-niter_no_qc(1))
> >         if(mype == 0) write(6,*) 'Warning - value for c_varqc does not allow ',&
> >             'variational qc to turn on completely in first outer iteration', &
> >             'c_varqc adjusted c_varqc - old =',c_varqc,  &
> >             'c_varqc - new  =',c_varqc_new
> >         c_varqc=c_varqc_new
> >      end if
> >   end if
> >   if(l_both_fv3sar_gfs_ens) then
> >     if(n_ens /= n_ens_gfs + n_ens_fv3sar .or. regional_ensemble_option /= 5 ) then 
> >        write(6,*)'the set up for l_both_fv3sar_gfs_ens=.true. is wrong,stop'
> >        call stop2(137)
> >     endif
> >   else
> >     if (regional_ensemble_option==5) then 
> >        n_ens_gfs=0
> >        n_ens_fv3sar=n_ens
> >     elseif (regional_ensemble_option==1) then 
> >        n_ens_gfs=n_ens
> >        n_ens_fv3sar=0
> >     else 
> >        if(mype == 0)write(6,*)'n_ens_gfs and n_ens_fv3sar won"t be used if not regional_ensemble_option==5' 
> >     endif
> >     weight_ens_gfs=one
> >     weight_ens_fv3sar=one
> >   endif
> >   if(ltlint) then
> >      if(vqc .or. njqc .or. nvqc)then
> >        vqc = .false.
> >        nvqc = .false.
> >        njqc = .false.
> >        if(mype == 0) write(6,*) ' ltlint = true, so vqc and njqc must be false'
> >      end if
> >   end if
> >   if (fv3sar_bg_opt /= 0) l_reg_update_hydro_delz=.false.
> >   if(regional_ensemble_option == 5 .and. (fv3sar_ensemble_opt /= fv3sar_bg_opt)) then
> >     write(6,*)'this setup doesn"t work, stop'
> >     call stop2(137)
> >   endif 
> >   if (anisotropic) then
> >       call init_fgrid2agrid(pf2aP1)
> >       call init_fgrid2agrid(pf2aP2)
> >       call init_fgrid2agrid(pf2aP3)
> >   endif
> 632,634c1942
> < !_RT call gsi_4dcoupler_setservices(rc=ier)
> < !_RT if(ier/=0) call die(myname_,'gsi_4dcoupler_setServices(), rc =',ier)
> < 
> ---
> > ! 4D-Var setup
> 635a1944,1947
> >   if (l4dvar) then
> >      if(reduce_diag) &
> >      call die(myname_,'Options l4dvar and reduce_diag not allowed together',99)
> >   end if 
> 637,640c1949,1960
> < ! Ensure valid number of horizontal scales
> <   if (nhscrf<0 .or. nhscrf>3) then
> <      if(mype==0) write(6,*)' GSIMOD: invalid specifications for number of horizontal scales nhscrf = ',nhscrf
> <      call die(myname_,'invalid nhscrf, check namelist settings',336)
> ---
> >   if( (.not.l4dvar) .and. (.not.l4densvar) ) ljcdfi=.false.
> >  
> >   if (l4dvar.and.lsensrecompute) then
> >      lobsensfc  =lobsensfc  .and.(jiterstart==jiterend)
> >      lobsensjb  =lobsensjb  .and.(jiterstart==jiterend)
> >      lobsensincr=lobsensincr.and.(jiterstart==jiterend)
> >   endif
> >   lobsensfc=lobsensfc.or.lobsensjb.or.lobsensincr
> >   lsensrecompute=lsensrecompute.and.lobsensfc
> >   if (lobsensadj .and. .not.lcongrad) then
> >      write(6,*)'gsimod: adjoint computation requires congrad',lobsensadj,lcongrad
> >      call stop2(137)
> 642,652c1962,1964
> < 
> < 
> < ! Write namelist output to standard out
> <   if(mype==0) then
> <      write(6,200)
> < 200  format(' calling gsisub with following input parameters:',//)
> <      write(6,setup)
> <      write(6,gridopts)
> <      write(6,bkgerr)
> <      write(6,strongopts)
> <      write(6,hybrid_ensemble)
> ---
> >   if (jsiga>0 .and. .not.lcongrad) then
> >      write(6,*)'gsimod: analysis error estimate requires congrad',jsiga,lcongrad
> >      call stop2(137)
> 655,657c1967,1971
> < ! Consistency check for TLNMC options
> <   if(reg_tlnmc_type>0) then
> <      call die(myname_,'regional optional not available',999)  
> ---
> >   ntotensgrp=nsclgrp*ngvarloc
> >   if(l_timloc_opt) then
> >      naensgrp=ntotensgrp*ntlevs_ens
> >   else
> >      naensgrp=ntotensgrp
> 658a1973,2036
> >   if( (.not. global_spectral_filter_sd) .and. (.not. assign_vdl_nml) .and. naensloc<naensgrp+nsclgrp-1) then
> >      naensloc=naensgrp+nsclgrp-1
> >   end if
> >   if(mype==0) write(6,*) 'in gsimod: naensgrp,ntotensgrp,nsclgrp,ngvarloc,ntlevs_ens= ', &
> >                           naensgrp,ntotensgrp,nsclgrp,ngvarloc,ntlevs_ens
> > 
> >   call gsi_4dcoupler_setservices(rc=ier)
> >   if(ier/=0) call die(myname_,'gsi_4dcoupler_setServices(), rc =',ier)
> > 
> > 
> > ! Check user input for consistency among parameters for given setups.
> > 
> > ! Set regional parameters
> >   if(filled_grid.and.half_grid) filled_grid=.false.
> >   regional=wrf_nmm_regional.or.wrf_mass_regional.or.twodvar_regional.or.nems_nmmb_regional .or. cmaq_regional
> >   regional=regional.or.fv3_regional.or.fv3_cmaq_regional
> > 
> > ! Force turn off MGBF-based localization except for regional application
> >   if(.not.regional.and.l_mgbf_loc) then
> >      l_mgbf_loc=.false.
> >      if(mype==0) write(6,*)'GSIMOD: for global app, l_mgbf_loc is not applicable, reset l_mgbf_loc=',l_mgbf_loc
> >   end if
> > 
> > ! Force turn off MGBF-based localization for lsqrtb=.true.
> >   if(lsqrtb.and.l_mgbf_loc) then
> >      l_mgbf_loc=.false.
> >      if(mype==0) write(6,*)'GSIMOD: for lsqrtb=.true., l_mgbf_loc is not applicable, reset l_mgbf_loc=',l_mgbf_loc
> >   end if
> > 
> > ! Currently only able to have use_gfs_stratosphere=.true. for nems_nmmb_regional=.true.
> >   use_gfs_stratosphere=use_gfs_stratosphere.and.(nems_nmmb_regional.or.wrf_nmm_regional)   
> >   if(mype==0) write(6,*) 'in gsimod: use_gfs_stratosphere,nems_nmmb_regional,wrf_nmm_regional= ', &  
> >                           use_gfs_stratosphere,nems_nmmb_regional,wrf_nmm_regional                  
> > ! Given the requested resolution, set dependent resolution parameters
> >   if(jcap_gfs == 1534)then
> >      nlat_gfs=1538
> >      nlon_gfs=3072
> >   else if(jcap_gfs == 574)then
> >      nlat_gfs=578
> >      nlon_gfs=1152
> >   else if(jcap_gfs == 382)then
> >      nlat_gfs=386
> >      nlon_gfs=768
> >   else if(jcap_gfs == 126)then
> >      nlat_gfs=130
> >      nlon_gfs=256
> >   else if(jcap_gfs == 62)then
> >      nlat_gfs=96
> >      nlon_gfs=192
> >   else
> >      if(mype == 0) write(6,*)' Invalid jcap_gfs'
> >      call stop2(329)
> >   end if
> > 
> > !  reg_tlnmc_type=2 currently requires that 2*nvmodes_keep <= npe
> >   if(reg_tlnmc_type==2) then
> >      if(2*nvmodes_keep>npe) then
> >         if(mype==0) write(6,*)' reg_tlnmc_type=2 and nvmodes_keep > npe'
> >         if(mype==0) write(6,*)' npe, old value of nvmodes_keep=',npe,nvmodes_keep
> >         nvmodes_keep=npe/2
> >         if(mype==0) write(6,*)'    new nvmodes_keep, npe=',nvmodes_keep,npe
> >      end if
> >   end if
> > 
> 673a2052,2152
> > ! check consistency in q option
> >   if(pseudo_q2 .and. qoption==1)then
> >      if(mype==0)then
> >        write(6,*)' pseudo-q2 = ', pseudo_q2, ' qoption = ', qoption
> >        write(6,*)' pseudo-q2 must be used together w/ qoption=2 only, aborting.'
> >        call stop2(999)
> >      endif
> >   endif
> > 
> >   if (innov_use_model_fed .and. .not.if_model_fed) then
> >      if(mype==0) write(6,*)' GSIMOD: invalid innov_use_model_fed=.true. but if_model_fed=.false.'
> >      call die(myname_,'invalid innov_use_model_fed,if_model_fed, check namelist settings',330)
> >   end if
> > 
> >   if (.not. (miter == 0 .or. lobserver) .and. if_model_fed .and. .not. fed_exist) then
> >      if(mype==0) write(6,*)' GSIMOD: .not. (miter == 0 .or. lobserver) and if_model_fed=.true. but fed is not in anavinfo file'
> >      call die(myname_,'Please check namelist parameters and/or add fed in anavinfo (contro/state_vector and met_guess) when miter > 0 and if_model_fed=.true.',332)
> >   end if
> > 
> >   if (.not. (miter == 0 .or. lobserver) .and. if_model_dbz .and. .not. dbz_exist) then
> >      if(mype==0) write(6,*)' GSIMOD: .not. (miter == 0 .or. lobserver) and if_model_dbz=.true. but dbz is not in anavinfo file'
> >      call die(myname_,'Please check namelist parameters and/or add dbz in anavinfo (contro/state_vector and met_guess) when miter > 0 and if_model_fed=.true.',334)
> >   end if
> > 
> > ! Ensure valid number of horizontal scales
> >   if (nhscrf<0 .or. nhscrf>3) then
> >      if(mype==0) write(6,*)' GSIMOD: invalid specifications for number of horizontal scales nhscrf = ',nhscrf
> >      call die(myname_,'invalid nhscrf, check namelist settings',336)
> >   end if
> > 
> > 
> >   writediag=.false.
> >   do i=1,miter+1
> >      if(write_diag(i))writediag=.true.
> >   end do
> >   if(.not. writediag)then
> >      diag_rad=.false.
> >      diag_conv=.false.
> >      diag_ozone=.false.
> >      diag_aero=.false.
> >      diag_co=.false.
> >      diag_pcp=.false.
> >      diag_light=.false.
> >      diag_radardbz=.false.
> >      diag_fed=.false.
> >      use_limit = 0
> >   end if
> >   if(reduce_diag) use_limit = 0
> > 
> > ! Force use of perturb_obs for oberror_tune
> >   if (oberror_tune ) then
> >      perturb_obs=.true.
> >      if (mype==0) write(6,*)'GSIMOD:  ***WARNING*** reset perturb_obs=',perturb_obs
> >   endif
> > 
> > ! Force turn off cloud analysis and hydrometeor IO
> >   if (i_gsdcldanal_type==0) then
> >      l_hydrometeor_bkio = .false.
> >      if (mype==0) write(6,*)'GSIMOD:  ***WARNING*** set l_hydrometeor_bkio=false'
> >   else if(i_gsdcldanal_type==1 .or. i_gsdcldanal_type==2 .or. &
> >           i_gsdcldanal_type==3 .or. i_gsdcldanal_type==5 .or. &
> >           i_gsdcldanal_type==6 .or. i_gsdcldanal_type==7 .or. &
> >           i_gsdcldanal_type==99 ) then
> >      l_hydrometeor_bkio = .true.
> >      if (mype==0) write(6,*)'GSIMOD:  set l_hydrometeor_bkio=true:',i_gsdcldanal_type
> >   endif
> > ! turn on hydrometeor IO for direct reflectivity DA
> >   if ( l_use_dbz_directDA) then
> >      l_hydrometeor_bkio = .true.  ! activate hydrometer IO
> >      if (mype==0) write(6,*)'GSIMOD:  ***WARNING*** set l_hydrometeor_bkio=true &
> >                             for direct Reflectivity DA capability', l_hydrometeor_bkio
> >   end if
> > 
> >   if((i_coastline == 1 .or. i_coastline == 3) .and. i_use_2mt4b==0) then
> >      i_coastline=0
> >      if (mype==0) write(6,*)'GSIMOD:  ***WARNING*** ',&
> >                     'set i_coastline=0 because i_use_2mt4b=0'
> >   endif
> >   if((i_coastline == 2 .or. i_coastline == 3) .and. i_use_2mq4b==0) then
> >      i_coastline=0
> >      if (mype==0) write(6,*)'GSIMOD:  ***WARNING*** ',&
> >                     'set i_coastline=0 because i_use_2mq4b=0'
> >   endif
> > 
> > ! Finish initialization of observation setup
> >   call init_obsmod_vars(nhr_assimilation,mype)
> > 
> > 
> > ! Force use of external observation error table for regional runs
> >   if (regional .and. .not.oberrflg) then
> >      oberrflg=.true.
> >      if (mype==0) write(6,*)'GSIMOD:  ***WARNING*** reset oberrflg=',oberrflg
> >   endif
> > 
> > 
> > ! Set 10m wind factor logicals based on ifact10
> >   if (ifact10==1 .or. ifact10==2) then
> >      if (ifact10==1) sfcmod_gfs = .true.
> >      if (ifact10==2) sfcmod_mm5 = .true.
> >   endif
> > 
> 686,690c2165,2263
> < ! check consistency in q option
> <   if(pseudo_q2 .and. qoption==1)then
> <      if(mype==0)then
> <        write(6,*)' pseudo-q2 = ', pseudo_q2, ' qoption = ', qoption
> <        write(6,*)' pseudo-q2 must be used together w/ qoption=2 only, aborting.'
> ---
> > ! Warning of reflectivity assimilation with static B
> >   if ( beta_s0 > 0.0_r_kind )then
> >     ! skipped in case of direct reflectivity DA because it works in Envar and hybrid
> >     if ( l_use_rw_columntilt .or. l_use_dbz_directDA) then
> >        do i=1,ndat
> >           if ( if_model_dbz .and. (index(dtype(i), 'dbz') /= 0) )then
> >              if (mype==0) then
> >                 write(6,*)'GSIMOD:  ***WARNING*** static B for reflectivity is regarded as zero in this GSI version &
> >                            even though beta_s0 =',beta_s0
> >                 write(6,*)'Static B extended for radar reflectivity assimilation will be included in future version.'
> >              end if
> >           end if
> >        end do
> >     end if
> >   end if
> > 
> > ! Turn off uv option if hybrid/ensemble options is false for purposes 
> > ! of TLNMC 
> >   if (.not.l_hyb_ens) uv_hyb_ens=.false.
> > 
> > ! Turn on derivatives if using dynamic constraint
> > ! For now if wrf mass or 2dvar no dynamic constraint
> >   if (l_tlnmc) tendsflag=.true.
> >   if (l_foto) then
> >      if(mype == 0)write(6,*) 'Warning foto option has been removed'
> >      call stop2(899)
> >       
> >   end if
> >   if (tendsflag) switch_on_derivatives=.true.
> > 
> > 
> > ! Turn off Jc-pdry weak constraint if regional application
> >   if (regional) ljcpdry=.false.
> > 
> > ! Initialize lagrangian data assimilation - must be called after gsi_4dvar
> >   call lag_modini()
> > 
> > 
> > ! Ensure tendency flag is on if preciptation data listed as observation type.
> > ! NOTE: only applicable for global run when not using observer
> >   if (.not.tendsflag .and. .not.regional) then
> >      check_pcp: do i=1,ndat
> >         if ( .not.tendsflag .and. index(dtype(i),'pcp') /=0 ) then
> >            tendsflag = .true.
> >            switch_on_derivatives=.true.
> >            if (mype==0) write(6,*)'GSIMOD:  set tendsflag,switch_on_derivatives=',&
> >                 tendsflag,switch_on_derivatives,' for pcp data'
> >            exit check_pcp
> >         endif
> >      end do check_pcp
> >   endif
> > 
> > ! Ensure no conflict between flag lread_obs_save and lread_obs_skip
> >   if (lread_obs_save .and. lread_obs_skip) then
> >      if (mype==0) write(6,*)'GSIMOD:  ***ERROR*** lread_obs_save=',lread_obs_save,&
> >           ' and lread_obs_skip=',lread_obs_skip,' can not both be TRUE'
> >      call stop2(329)
> >   endif
> >   if (l4densvar .and. (.not.ljc4tlevs) ) then
> >      if( ljcpdry .or. (factqmin>zero) .or. (factqmax>zero) )  then
> >         if (mype==0) write(6,*)'GSIMOD: **WARNING**, option for Jc terms over all time', &
> >                               ' levels not activated with 4Densvar'
> >         if (mype==0) write(6,*)'GSIMOD: **WARNING**, This configuration not recommended,',&
> >                               ' limq/pdry will only be applied to center of window '
> >      end if
> >   end if
> > 
> > ! Optionally read in namelist for single observation run
> >   if (oneobtest) then
> >      miter=1
> >      dfile(1)='prepqc'
> >      time_window(1)=three
> >      dplat='oneob'
> >      dthin=1
> >      dval=one
> >      dmesh=one
> >      factqmin=zero
> >      factqmax=zero
> >      superfact=1._r_kind
> >      limitqobs=.false.
> >      if (hilbert_curve) then
> >         write(6,*) 'Disabling hilbert_curve cross validation when oneobtest=.true.'
> >         hilbert_curve=.false.
> >      end if
> > #ifdef ibm_sp
> >      read(5,singleob_test)
> > #else
> >      open(11,file='gsiparm.anl')
> >      read(11,singleob_test,iostat=ios)
> >         if(ios/=0) call die(myname_,'read(singleob_test)',ios)
> >      close(11)
> > #endif
> >      dtype(1)=oneob_type
> >      if(dtype(1)=='u' .or. dtype(1)=='v')dtype(1)='uv'
> >      dsis(1)=dtype(1)
> >      if(trim(dtype(1))=='rw') then ! Reset some values for radial wind single ob.
> >         dfile(1)='l2rwbufr'
> >         dplat='null'
> >         dsis(1)='l2rw'
> 692d2264
> <      call die(myname_,'consistency(q2)',999)  
> 695,698c2267,2289
> <   if (qoption==2.or.l_tlnmc) then
> <      tendsflag =.true.
> <      switch_on_derivatives = .true.
> <      if (mype==0) write(6,*)'GSIMOD:  tendencies and derivatives are on'
> ---
> > ! Single radiance assimilation case
> >   if (lsingleradob) then
> > #ifdef ibm_sp 
> >      read(5,singleob_test)
> > #else 
> >      open(11,file='gsiparm.anl')
> >      read(11,singleob_test,iostat=ios)
> >      if(ios/=0) call die(myname_,'read(singleob_test)',ios)
> >      close(11)
> > #endif 
> >   endif
> > 
> > ! reading namelist for using directly radar DA capabilities
> >   if (l_use_rw_columntilt .or. l_use_dbz_directDA) then
> > #ifdef ibm_sp
> >      read(5,radaruse_directDA)
> > #else
> >      open(11,file='gsiparm.anl')
> >      read(11,radaruse_directDA,iostat=ios)
> >      if(ios/=0) call die(myname_,'read(radaruse_directDA)',ios)
> >      close(11)
> > #endif
> > 
> 700a2292,2343
> > 
> > ! Write namelist output to standard out
> >   if(mype==0) then
> >      write(6,200)
> > 200  format(' calling gsisub with following input parameters:',//)
> >      write(6,setup)
> >      write(6,gridopts)
> >      write(6,bkgerr)
> >      write(6,anbkgerr)
> >      write(6,jcopts)
> >      write(6,strongopts)
> >      write(6,obsqc)
> >      write(6,*)'EXT_SONDE on type 120 =',ext_sonde
> >      ngroup=0
> >      do i=1,ndat
> >         dthin(i) = max(dthin(i),0)
> >         if(dthin(i) > ngroup)ngroup=dthin(i)
> >      end do
> >      if(ngroup>0) then
> >        if (ngroup<size(dmesh)) then
> >           write(6,*)' ngroup = ',ngroup,' dmesh = ',(dmesh(i),i=1,ngroup)
> >  400      format(' ngroup = ',I5,' dmesh = ',(5f10.2))
> >        else
> >           call die(myname_,'dmesh size needs increasing',99)
> >        endif
> >      endif
> >      do i=1,ndat
> >         write(6,401)dfile(i),dtype(i),dplat(i),dsis(i),dval(i),dthin(i),dsfcalc(i),time_window(i)
> >  401    format(1x,a20,1x,a10,1x,a10,1x,a20,1x,f10.2,1x,I3,1x,I3,1x,f10.2)
> >      end do
> >      write(6,superob_radar)
> >      write(6,lag_data)
> >      write(6,hybrid_ensemble)
> >      write(6,rapidrefresh_cldsurf)
> >      write(6,chem)
> >      if (oneobtest) write(6,singleob_test)
> >      write(6,nst)
> >      if (l_use_rw_columntilt .or. l_use_dbz_directDA) write(6,radaruse_directDA)
> >   endif
> > 
> > ! Set up directories (or pe specific filenames)
> >   call init_directories(mype,npe)
> > 
> > ! Initialize space for qc
> >   call create_qcvars
> > 
> > ! Initialize constants
> >   call init_constants(regional)
> >   call gps_constants(use_compress)
> > 
> > ! If this is a wrf regional run, then run interface with wrf
> >   update_pint=.false.
> 702c2345,2349
> <      call convert_fv3_regional
> ---
> >      if (fv3_regional) then
> >         call convert_fv3_regional
> >      else
> >         if(i_gsdcldanal_type.ne.6) call regional_io%convert_regional_guess(mype,ctph0,stph0,tlm0)
> >      endif
> 703a2351,2353
> >             
> >   if (regional.and.use_gfs_stratosphere) call broadcast_gfs_stratosphere_vars
> > 
> 706,708d2355
> <   lendian_in = -1
> <   call create_ges_tendencies(tendsflag,thisrc)
> <   call create_ges_derivatives(switch_on_derivatives,nfldsig_)
> 711,712c2358
> <   call init_general_commvars_dims (cvars2d,cvars3d,cvarsmd,nrf_var, &
> <                                    dvars2d,dvars3d)
> ---
> >   if (switch_on_derivatives) call init_anadv  ! moved from derivsmod 
> 714,716c2360,2363
> <   if (tendsflag) then
> <      call create_turblvars()
> <   endif
> ---
> >   call create_obsmod_vars
> >   call gpsStats_create()                ! extracted from obsmod::create_obsmod_vars()
> >   call obsdiags_create()                ! extracted from obsmod::create_obsmod_vars()
> >   if (passive_bc) call prad_create()    ! replacing -- call obsmod::create_passive_obsmod_vars()
> 718,720d2364
> <   if(mype==0)then
> <     write(6,*) myname_, ': Complete'
> <   endif
> 722c2366,2367
> <   end subroutine gsimain_initialize_
> ---
> > ! Initialize values in radinfo
> >   call init_rad_vars
> 724,729c2369,2370
> <   subroutine gridopts0_(nmlfile)
> <   implicit none
> <   character(len=*),optional,intent(in)  :: nmlfile
> <   character(len=*),parameter :: myname_="gsimod*gridopts0_"
> <   integer(i_kind) :: ios
> <   character(len=255) :: thisrc
> ---
> > ! Initialize values in aeroinfo
> >   call init_aero_vars
> 731,735c2372,2378
> <   if (present(nmlfile)) then
> <      thisrc = trim(nmlfile)
> <   else
> <      thisrc = gsimain_rc
> <   endif
> ---
> > ! Initialize values in the radar emulator
> >   iret_init_mphyopt = -1
> >   if ( l_use_dbz_directDA ) then
> > ! Stop GSI if 'if_model_dbz' and 'l_use_dbz_directDA' are set as .true. 
> >      if ( if_model_dbz ) then
> >          call die('init_mphyopt', 'if_model_dbz in &SETUP should be set as .false.', mphyopt)
> >      end if
> 737,741c2380,2384
> < ! read in basic grid parameters
> <   open(11,file=thisrc)
> <   read(11,gridopts,iostat=ios)
> <   if(ios/=0) call die(myname_,'read(gridopts)',ios)  
> <   close(11)
> ---
> >      call init_mphyopt(mype,iret_init_mphyopt)
> > ! Check microphysics scheme if assimilating radar dBZ
> >      if ( iret_init_mphyopt /= 0 ) then
> >          call die('init_mphyopt', 'Invalid microphysics option for dbz assimilation:', mphyopt)
> >      end if
> 743,790c2386,2395
> <   end subroutine gridopts0_
> <   
> <   subroutine gridopts1_(thisrc,thispe,npex,npey,&
> <                         gnlat,gnlon,gnlev,eqspace,&
> <                         glon2,glat2,&
> <                         isc,iec,jsc,jec,igdim)
> <   use general_sub2grid_mod, only: general_deter_subdomain_withLayout
> <   implicit none
> <   character(len=*),intent(in)  :: thisrc
> <   integer,intent(in)  :: thispe
> <   integer,intent(in)  :: npex,npey
> <   integer,intent(out) :: gnlat,gnlon,gnlev
> <   integer,intent(out) :: glon2,glat2
> <   logical,intent(out) :: eqspace
> <   integer,intent(out) :: isc,iec,jsc,jec,igdim
> <   character(len=*),parameter :: myname_="gsimod*gridopts1_"
> <   integer(i_kind) :: glon1,glat1,j,nxy,ios
> <   logical :: verbose,periodic
> <   logical,allocatable :: periodic_s(:)
> <   integer(i_kind),allocatable :: iglat1(:),igstart(:),jglon1(:),jgstart(:)
> < 
> <   verbose = thispe==0
> < 
> <   call gridopts0_(nmlfile=thisrc)
> <   gnlat=nlat
> <   gnlon=nlon
> <   gnlev=nsig
> <   eqspace=use_sp_eqspace
> < 
> <   nxy=npex*npey
> <   allocate(periodic_s(nxy))
> <   allocate(iglat1(nxy),igstart(nxy),jglon1(nxy),jgstart(nxy))
> < 
> <   call general_deter_subdomain_withLayout(nxy,npex,npey,&
> <                 thispe,nlat,nlon,.false.,periodic,periodic_s,&
> <                 glon1,glon2,glat1,glat2,&
> <                 iglat1,igstart,jglon1,jgstart,&
> <                 verbose)
> < 
> <   do j=1,nxy
> <      if(thispe==j-1) then
> <        isc = jgstart(j)
> <        iec = jgstart(j) + jglon1(j) - 1
> <        jsc = igstart(j)
> <        jec = igstart(j) + iglat1(j) - 1
> <      endif
> <   end do
> <   igdim=glon1*glat1
> ---
> > ! Initialize coefficients and power index numers used in the dbz obs operator
> > ! for single moment scheme
> >      if (mphyopt  >= 2 .and. mphyopt  <= 7) then
> >         iret_coef4dbzfwrd = -1
> >         call coef4dbzfwrd(mphyopt,iret_coef4dbzfwrd)
> >         if ( iret_coef4dbzfwrd /= 0 ) then
> >             call die('COEF4DBZFWRD', 'Invalid microphysics option for single moment MP scheme:', mphyopt)
> >         end if
> >      end if
> >    end if
> 792,793d2396
> <   deallocate(iglat1,igstart,jglon1,jgstart)
> <   deallocate(periodic_s)
> 795,796c2398,2431
> <   end subroutine gridopts1_
> <   
> ---
> > 
> >   end subroutine gsimain_initialize
> > 
> > !-------------------------------------------------------------------------
> > !  NASA/GSFC, Global Modeling and Assimilation Office, Code 610.3, GMAO  !
> > !-------------------------------------------------------------------------
> > !BOP
> > 
> > ! ! IROUTINE: gsimain_run
> > 
> > ! ! INTERFACE:
> > 
> >   subroutine gsimain_run(init_pass,last_pass)
> >     use mpeu_util, only: tell
> >     implicit none
> >     logical, optional, intent(in):: init_pass  ! initial pass through multiple background bins
> >     logical, optional, intent(in):: last_pass  ! last pass through multiple background bins
> > 
> > !EOC
> > 
> > !---------------------------------------------------------------------------
> >   logical :: init_pass_
> >   logical :: last_pass_
> >  
> >   init_pass_ =.false.
> >   if(present(init_pass)) init_pass_=init_pass
> >   last_pass_  =.false.
> >   if(present(last_pass)) last_pass_ =last_pass
> > 
> > ! Call the main gsi driver routine
> >   call gsisub(init_pass_,last_pass_)
> > 
> >   end subroutine gsimain_run
> > 
> 804c2439
> <  subroutine gsimain_finalize_(closempi)
> ---
> >  subroutine gsimain_finalize
> 814a2450,2452
> >   use m_prad    , only: prad_destroy     ! was obsmod::destroyobs_passive()
> >   use m_obsdiags, only: obsdiags_destroy
> > 
> 816,817d2453
> <   logical, intent(in) :: closempi
> <   integer :: ier
> 819,823c2455,2467
> < 
> <   call destroy_vtrans
> <   call destroy_ges_tendencies
> <   call destroy_ges_derivatives
> < ! call final_reg_glob_ll ! if ever regional
> ---
> > ! RTodling debug: PROG HANGS; needs ATTENTION
> >   call mpi_comm_rank(mpi_comm_world,mype,ierror)
> >   if (anisotropic) then
> >      call final_fgrid2agrid(pf2aP3)
> >      call final_fgrid2agrid(pf2aP2)
> >      call final_fgrid2agrid(pf2aP1)
> >   endif
> >   call radiance_obstype_destroy
> >   call final_aero_vars
> >   call final_rad_vars
> >   if(passive_bc) call prad_destroy()    ! replacing -- call destroyobs_passive
> >   call obsdiags_destroy()               !
> >   call destroy_obsmod_vars
> 825d2468
> <   call final_general_commvars_dims
> 827,828c2470,2471
> <   call clean_4dvar
> <   call final_anadv
> ---
> > !_TBDone  call final_reg_glob_ll ! gridmod
> >   call radiance_mode_destroy
> 830a2474
> >   call obsmod_final_instr_table
> 833,836c2477,2478
> <   call gsi_metguess_destroy_grids(ier)
> <   call gsi_chemguess_destroy_grids(ier)
> <   call final_constants_derived
> <   call final_constants
> ---
> >   call clean_4dvar
> >   call destroy_qcvars
> 838,840c2480,2483
> <   if (closempi) then
> <      call mpi_finalize(ierror)
> <   endif
> ---
> > ! Done with GSI.
> >   if (mype==0)  call w3tage('GSI_ANL')
> >   
> >   call mpi_finalize(ierror)
> 842c2485
> <  end subroutine gsimain_finalize_
> ---
> >  end subroutine gsimain_finalize
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_mxtmOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_nemsio_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_nstcouplermod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_o3lOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_obOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_obOperTypeManager.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_ozOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_pblhOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_pcpOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_pm10Oper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_pm2_5Oper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_pmslOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_psOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_pwOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_qOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_radOper.F90
> diff -r ./gsi_rfv3io_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/gsi_rfv3io_mod.f90
> 54c54
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 64c64
> <   use rapidrefresh_cldsurf_mod, only: i_howv_3dda, i_gust_3dda
> ---
> >   use rapidrefresh_cldsurf_mod, only: i_howv_3dda
> 135d134
> <   public :: m_gsi_rfv3io_get_grid_specs
> 142a142,144
> >   public :: read_fv3_files 
> >   public :: read_fv3_netcdf_guess
> >   public :: wrfv3_netcdf
> 148c150
> <   public :: k_snwdph,k_f10m,mype_2d,n2d,k_orog,k_psfc,k_t2m,k_q2m,k_howv,k_gust
> ---
> >   public :: k_snwdph,k_f10m,mype_2d,n2d,k_orog,k_psfc,k_t2m,k_q2m,k_howv
> 159c161
> <   integer(i_kind) k_snwdph,k_f10m,mype_2d,n2d,k_orog,k_psfc,k_t2m,k_q2m,k_howv,k_gust
> ---
> >   integer(i_kind) k_snwdph,k_f10m,mype_2d,n2d,k_orog,k_psfc,k_t2m,k_q2m,k_howv
> 175,176c177
> <     k_gust =15,                 &   ! wind gust (aka gust in GSI)
> <     n2d=15                   )
> ---
> >     n2d=14                   )
> 288c289
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 293c294
> <   use m_kinds, only: i_kind,r_kind
> ---
> >   use kinds, only: i_kind,r_kind
> 295c296
> <   use m_mpimod, only: gsi_mpi_comm_world,mpi_itype,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,mpi_itype,mpi_rtype
> 386,389c387,390
> <    ! if(mype==0)write(6,*),'nx,ny=',nx,ny
> <    ! if(mype==0)write(6,*),'ny_layout_len=',ny_layout_len
> <    ! if(mype==0)write(6,*),'ny_layout_b=',ny_layout_b
> <    ! if(mype==0)write(6,*),'ny_layout_e=',ny_layout_e
> ---
> >     if(mype==0)write(6,*),'nx,ny=',nx,ny
> >     if(mype==0)write(6,*),'ny_layout_len=',ny_layout_len
> >     if(mype==0)write(6,*),'ny_layout_b=',ny_layout_b
> >     if(mype==0)write(6,*),'ny_layout_e=',ny_layout_e
> 433c434
> <        !if(mype==0) write(6,*) 'FV3 regional input grid is  E-W N-S grid'
> ---
> >        if(mype==0) write(6,*) 'FV3 regional input grid is  E-W N-S grid'
> 436c437
> <        !if(mype==0) write(6,*) 'FV3 regional input grid is  W-E S-N grid'
> ---
> >        if(mype==0) write(6,*) 'FV3 regional input grid is  W-E S-N grid'
> 463c464
> <     !if(mype==0)write(6,'(" nz=",i5)') nz
> ---
> >     if(mype==0)write(6,'(" nz=",i5)') nz
> 465c466
> <     !nsig=nz-1
> ---
> >     nsig=nz-1
> 499,503c500,504
> <     !if(mype==0)then
> <     !   do i=1,nz
> <     !      write(6,'(" ak,bk(",i3,") = ",2f17.6)') i,ak(i),bk(i)
> <     !   enddo
> <     !endif
> ---
> >     if(mype==0)then
> >        do i=1,nz
> >           write(6,'(" ak,bk(",i3,") = ",2f17.6)') i,ak(i),bk(i)
> >        enddo
> >     endif
> 551c552
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 555c556
> <   use m_kinds, only: i_kind,r_kind
> ---
> >   use kinds, only: i_kind,r_kind
> 557c558
> <   use m_mpimod, only: gsi_mpi_comm_world,mpi_itype,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,mpi_itype,mpi_rtype
> 672a674,2318
> > 
> > subroutine read_fv3_files(mype)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    read_fv3_files
> > !   prgmmr: wu               org: np22                date: 2017-10-10
> > !
> > ! abstract: read in from fv3 files and figure out available time levels 
> > !           of background fields starting from read_files as a pattern
> > !           temporary setup for one first guess file
> > ! program history log:
> > !
> > !   input argument list:
> > !     mype     - pe number
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$  end documentation block
> > 
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype,npe
> >     use guess_grids, only: nfldsig,nfldsfc,ntguessig,ntguessfc,&
> >          ifilesig,ifilesfc,hrdifsig,hrdifsfc,create_gesfinfo
> >     use guess_grids, only: hrdifsig_all,hrdifsfc_all
> >     use gsi_4dvar, only: l4dvar,l4densvar,iwinbgn,winlen,nhr_assimilation
> >     use constants, only: zero,one,r60inv
> >     use obsmod, only: iadate,time_offset
> >     use gridmod, only:regional_time
> >     implicit none
> > 
> > ! Declare passed variables
> >     integer(i_kind),intent(in   ) :: mype
> > 
> > ! Declare local parameters
> >     real(r_kind),parameter:: r0_001=0.001_r_kind
> > 
> > ! Declare local variables
> >     logical(4) fexist
> >     character(6) filename
> >     character(19) filenames
> >     integer(i_kind) in_unit
> >     integer(i_kind) i,j,iwan,npem1
> >     integer(i_kind) nhr_half
> >     integer(i_kind) nminanl,nmings,nming2,ndiff,isecond
> >     integer(i_kind),dimension(4):: idateg
> >     integer(i_kind),dimension(5):: idate5
> >     real(r_kind) hourg,temp,t4dv
> >     real(r_kind),dimension(202,2):: time_ges
> >     character*1 :: datein(4),dateout(4)
> >     integer(i_kind) datecc
> > 
> > !-----------------------------------------------------------------------------
> > ! Start read_nems_nmmb_files here.
> >     nhr_half=nhr_assimilation/2
> >     if(nhr_half*2 < nhr_assimilation) nhr_half=nhr_half+1
> >     npem1=npe-1
> > 
> >     do i=1,202
> >        time_ges(i,1) = 999_r_kind
> >        time_ges(i,2) = 999_r_kind
> >     end do
> > 
> > 
> > ! Let a single task query the guess files.
> >     if(mype==npem1) then
> > 
> > !    Convert analysis time to minutes relative to fixed date
> >        call w3fs21(iadate,nminanl)
> >        write(6,*)'READ_netcdf_fv3_FILES:  analysis date,minutes ',iadate,nminanl
> > 
> > !    Check for consistency of times from sigma guess files.
> >        in_unit=15
> >        iwan=0
> > !WWWWWW setup for one first guess file for now
> >        do i=0,9 !place holder for FGAT
> >           if ( i == 6 ) then
> >              if(fv3_io_layout_y > 1) then
> >                 write(filenames,"(A16)") 'fv3_dynvars.0000'
> >              else
> >                 write(filenames,"(A11)") 'fv3_dynvars'
> >              endif
> >           else
> >              if(fv3_io_layout_y > 1) then
> >                 write(filenames,"(A17,I2.2)") 'fv3_dynvars.0000_',i
> >              else
> >                 write(filenames,"(A12,I2.2)") 'fv3_dynvars_',i
> >              endif
> >           endif
> >           INQUIRE(FILE=filenames, EXIST=fexist)
> >           if(.not.fexist) cycle
> > 
> > !wwww read in from the external file directly, no internal files sigfxx for FV3
> >           datecc=regional_time(1)/100
> >           datein(1)=char(regional_time(1)-datecc*100)
> >           datein(2)=char(regional_time(2))
> >           datein(3)=char(regional_time(3))
> >           datein(4)=char(regional_time(4))
> >           call w3fs15(datein,(i-6),dateout)
> >           idate5(1)=ichar(dateout(1))+datecc*100
> >           idate5(2)=ichar(dateout(2))
> >           idate5(3)=ichar(dateout(3))
> >           idate5(4)=ichar(dateout(4))
> >           idate5(5)=  regional_time(5)
> >           isecond  =  regional_time(6)
> >           hourg    =  zero ! forcast hour
> > 
> >           call w3fs21(idate5,nmings)
> >           nming2=nmings+60*hourg
> >           write(6,*)'READ_netcdf_fv3_FILES:  sigma guess file, nming2 ',hourg,idate5,nming2
> >           t4dv=real((nming2-iwinbgn),r_kind)*r60inv
> >           if (l4dvar.or.l4densvar) then
> >              if (t4dv<zero .OR. t4dv>winlen) then
> >                 write(6,*)'ges file not in time range, t4dv=',t4dv
> >                 cycle ! place holder for FGAT
> >              endif
> >           else
> >              ndiff=nming2-nminanl
> > !for test with the 3 hr files with FGAT
> >              if(abs(ndiff) > 60*nhr_half ) then
> >                 write(6,*)'ges file not in time range, ndiff=',ndiff
> >                 cycle ! place holder for FGAT
> >              endif
> >           endif
> >           iwan=iwan+1
> >           time_ges(iwan,1) =real((nming2-iwinbgn),r_kind)*r60inv
> >           time_ges(iwan+100,1)=i+r0_001
> >        end do ! i !place holder for FGAT
> >        time_ges(201,1)=one
> >        time_ges(202,1)=one
> >        if(iwan > 1)then
> >           do i=1,iwan
> >              do j=i+1,iwan
> >                 if(time_ges(j,1) < time_ges(i,1))then
> >                    temp=time_ges(i+100,1)
> >                    time_ges(i+100,1)=time_ges(j+100,1)
> >                    time_ges(j+100,1)=temp
> >                    temp=time_ges(i,1)
> >                    time_ges(i,1)=time_ges(j,1)
> >                    time_ges(j,1)=temp
> >                 end if
> >              end do
> >              if(abs(time_ges(i,1)-time_offset) < r0_001)time_ges(202,1) = i
> >           end do
> >        end if
> >        time_ges(201,1) = iwan+r0_001
> > 
> > !    Check for consistency of times from surface guess files.
> >        iwan=0
> >        do i=0,99
> >           write(filename,200)i
> >   200     format('sfcf',i2.2)
> >           inquire(file=filename,exist=fexist)
> >           if(fexist)then
> >              idateg(4)=iadate(1); idateg(2)=iadate(2)
> >              idateg(3)=iadate(3); idateg(1)=iadate(4)
> >              hourg = zero
> >              idate5(1)=idateg(4); idate5(2)=idateg(2)
> >              idate5(3)=idateg(3); idate5(4)=idateg(1); idate5(5)=0
> >              call w3fs21(idate5,nmings)
> >              nming2=nmings+60*hourg
> >              write(6,*)'READ_netcdf_fv3_FILES:  surface guess file, nming2 ',hourg,idateg,nming2
> >              ndiff=nming2-nminanl
> >              if(abs(ndiff) > 60*nhr_half ) then
> >                 write(6,*)'ges file not in time range, ndiff=',ndiff
> > !               cycle ! place holder for FGAT
> >              endif
> >              iwan=iwan+1
> >              time_ges(iwan,2) =real((nming2-iwinbgn),r_kind)*r60inv
> >              time_ges(iwan+100,2)=i+r0_001
> >           end if
> >           if(iwan==1) exit
> >        end do
> >        time_ges(201,2)=one
> >        time_ges(202,2)=one
> >        if(iwan > 1)then
> >           do i=1,iwan
> >              do j=i+1,iwan
> >                 if(time_ges(j,2) < time_ges(i,2))then
> >                    temp=time_ges(i+100,2)
> >                    time_ges(i+100,2)=time_ges(j+100,2)
> >                    time_ges(j+100,2)=temp
> >                    temp=time_ges(i,2)
> >                    time_ges(i,2)=time_ges(j,2)
> >                    time_ges(j,2)=temp
> >                 end if
> >              end do
> >              if(abs(time_ges(i,2)-time_offset) < r0_001)time_ges(202,2) = i
> >           end do
> >        end if
> >        time_ges(201,2) = iwan+r0_001
> >     end if
> > 
> > 
> > ! Broadcast guess file information to all tasks
> >     call mpi_bcast(time_ges,404,mpi_rtype,npem1,mpi_comm_world,ierror)
> > 
> >     nfldsig   = nint(time_ges(201,1))
> > !!nfldsfc   = nint(time_ges(201,2))
> >     nfldsfc   = nfldsig
> > 
> > ! Allocate space for guess information files
> >     call create_gesfinfo
> > 
> >     do i=1,nfldsig
> >        ifilesig(i) = -100
> >        hrdifsig(i) = zero
> >     end do
> > 
> >     do i=1,nfldsfc
> >        ifilesfc(i) = -100
> >        hrdifsfc(i) = zero
> >     end do
> > 
> > ! Load time information for sigma guess field sinfo into output arrays
> >     ntguessig = nint(time_ges(202,1))
> >     do i=1,nfldsig
> >        hrdifsig(i) = time_ges(i,1)
> >        ifilesig(i) = nint(time_ges(i+100,1))
> >        hrdifsig_all(i) = hrdifsig(i)
> >     end do
> >     if(mype == 0) write(6,*)'READ_netcdf_fv3_FILES:  sigma fcst files used in analysis  :  ',&
> >          (ifilesig(i),i=1,nfldsig),(hrdifsig(i),i=1,nfldsig),ntguessig
> > 
> > 
> > ! Load time information for surface guess field info into output arrays
> >     ntguessfc = nint(time_ges(202,2))
> >     do i=1,nfldsfc
> >        hrdifsfc(i) = time_ges(i,2)
> >        ifilesfc(i) = nint(time_ges(i+100,2))
> >        hrdifsfc_all(i) = hrdifsfc(i)
> >     end do
> > 
> > ! Below is a temporary fix. The nems_nmmb regional mode does not have a
> > ! surface
> > ! file.  Instead the surface fields are passed through the atmospheric guess
> > ! file.  Without a separate surface file the code above sets ntguessig and 
> > ! nfldsig to zero.  This causes problems later in the code when arrays for
> > ! the surface fields are allocated --> one of the array dimensions is nfldsfc
> > ! and it will be zero.  This portion of the code should be rewritten, but
> > ! until
> > ! it is, the fix below gets around the above mentioned problem.
> > 
> >     ntguessfc = ntguessig
> > !!nfldsfc   = nfldsig
> >     do i=1,nfldsfc
> >        hrdifsfc(i) = hrdifsig(i)
> >        ifilesfc(i) = ifilesig(i)
> >        hrdifsfc_all(i) = hrdifsfc(i)
> >     end do
> >     if(mype == 0) write(6,*)'READ_nems_nmb_FILES:  surface fcst files used in analysis:  ',&
> >          (ifilesfc(i),i=1,nfldsfc),(hrdifsfc(i),i=1,nfldsfc),ntguessfc
> > 
> > 
> > ! End of routine
> >     return
> > end subroutine read_fv3_files
> > 
> > subroutine read_fv3_netcdf_guess(fv3filenamegin)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    read_fv3_netcdf_guess            read fv3 interface file
> > !   prgmmr: wu               org: np22                date: 2017-07-06
> > !
> > ! abstract:  read guess for FV3 regional model
> > ! program history log:
> > !      2022-04-01 Y. Wang and X. Wang - add capability to read reflectivity
> > !                                       for direct radar EnVar DA using reflectivity as state 
> > !                                       variable, poc: xuguang.wang@ou.edu
> > !      2023-07-30 Zhao   - added code to read significant wave height (howv) field 
> > !                          from the 2D fv3-lam firstguess file (fv3_sfcdata).
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$  end documentation block
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: npe
> >     use mpimod, only: mpi_comm_world
> >     use guess_grids, only:ges_prsi
> >     use gridmod, only: lat2,lon2,nsig,ijn,eta1_ll,eta2_ll,ijn_s
> >     use constants, only: one,fv
> >     use gsi_metguess_mod, only: gsi_metguess_bundle
> >     use gsi_chemguess_mod, only: gsi_chemguess_bundle
> >     use gsi_bundlemod, only: gsi_bundleinquire, gsi_bundlegetpointer
> >     use gsi_bundlemod, only: gsi_bundlecreate,gsi_bundledestroy
> >     use general_sub2grid_mod, only: general_sub2grid_create_info
> >     use mpeu_util, only: die
> >     use guess_grids, only: nfldsig,ntguessig
> >     use directDA_radaruse_mod, only: l_use_cvpqx, cvpqx_pval
> >     use directDA_radaruse_mod, only: l_use_dbz_directDA
> >     use directDA_radaruse_mod, only: l_cvpnr, cvpnr_pval
> >     use gridmod,only: regional
> >     use gridmod,only: l_reg_update_hydro_delz
> >     use gridmod, only: grd_a
> >     use mpimod, only: mype
> >     use gsi_metguess_mod, only: gsi_metguess_get
> >     use netcdf, only:nf90_open,nf90_close,nf90_inquire,nf90_nowrite, nf90_format_netcdf4
> >     use gsi_chemguess_mod, only: gsi_chemguess_get
> >     use obsmod, only: if_model_dbz,if_model_fed
> > 
> >     implicit none
> > 
> >     type (type_fv3regfilenameg),intent (in) :: fv3filenamegin(:)
> > 
> >     integer(i_kind) :: it
> >     character(len=24),parameter :: myname = 'read_fv3_netcdf_guess'
> >     integer(i_kind) k,i,j
> >     integer(i_kind) ier,istatus,ivar
> >     real(r_kind),dimension(:,:),pointer::ges_ps=>NULL()
> >     real(r_kind),dimension(:,:),pointer::ges_ps_readin=>NULL()
> >     real(r_kind),dimension(:,:),pointer::ges_z=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_u=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_v=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_q=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_oz=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_tv=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_tsen_readin=>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_delp  =>NULL()
> >     real(r_kind),dimension(:,:),pointer::ges_t2m=>NULL()
> >     real(r_kind),dimension(:,:),pointer::ges_q2m=>NULL()
> >     real(r_kind),dimension(:,:),pointer::ges_howv=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_ql=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_qi=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_qr=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_iqr=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_qs=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_qg=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_qnr=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_w=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_dbz=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_fed=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_aalj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_acaj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_acli=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aclj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aclk=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_acors=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aeci=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aecj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_afej=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aivpo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_akj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo2i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvpo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvpo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_amgj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_amnj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anai=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anaj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anh4i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anh4j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anh4k=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_ano3i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_ano3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_ano3k=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aothri=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aothrj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aseacat=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asij=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aso4i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aso4j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aso4k=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asoil=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo2i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo2i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atij=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atol1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atol2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atol3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_abnz1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_abnz2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_abnz3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aiso1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aiso2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aiso3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atrp1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atrp2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asqtj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aalk1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aalk2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apah1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apah2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apah3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aorgcj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aolgbj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aolgaj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apcsoj=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_axyl1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_axyl2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_axyl3j=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_pm25at=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_pm25ac=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_pm25co=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_pm2_5=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_amassi=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_amassj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_amassk=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_smoke=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_dust=>NULL()
> > 
> > 
> >     character(len=max_varname_length)  :: vartem=""
> >     character(len=64),dimension(:,:),allocatable:: names  !to be same as in the grid the dummy sub2grid_info
> >     character(len=64),dimension(:,:),allocatable:: uvnames
> >     integer(i_kind),dimension(:,:),allocatable:: lnames
> >     integer(i_kind),dimension(:,:),allocatable:: uvlnames
> >     integer(i_kind):: inner_vars,numfields
> >     integer(i_kind):: ndynvario2d,ntracerio2d,ilev,jdynvar,jtracer,jphyvar
> >     integer(i_kind):: iuv,ndynvario3d,ntracerio3d,nphyvario3d
> >     integer(i_kind):: ntracerchemio3d,ntracersmokeio3d
> >     integer(i_kind):: loc_id,ncfmt
> > 
> > !clt this block is still maintained for they would be needed for a certain 2d fields IO 
> >     it=ntguessig
> >     mype_2d=mod(1,npe)
> >     if (.not.allocated(ijns))      allocate(ijns(npe))
> >     if (.not.allocated(ijns2d))    allocate(ijns2d(npe))
> >     if (.not.allocated(ijnz))      allocate(ijnz(npe))
> >     if (.not.allocated(displss))   allocate(displss(npe))
> >     if (.not.allocated(displss2d)) allocate(displss2d(npe))
> >     if (.not.allocated(displsz_g)) allocate(displsz_g(npe))
> > 
> >     do i=1,npe
> >        ijns(i)=ijn_s(i)*nsig
> >        ijnz(i)=ijn(i)*nsig
> >        ijns2d(i)=ijn_s(i)*n2d
> >     enddo
> >     displss(1)=0
> >     displsz_g(1)=0
> >     displss2d(1)=0
> >     do i=2,npe
> >        displss(i)=displss(i-1)+ ijns(i-1)
> >        displsz_g(i)=displsz_g(i-1)+ ijnz(i-1)
> >        displss2d(i)=displss2d(i-1)+ ijns2d(i-1)
> >     enddo
> > 
> >     if (.not.allocated(name_metvars2d)) then
> >       allocate( name_metvars2d(GSI_MetGuess_Bundle(it)%n2d))
> >     end if
> >     if (.not.allocated(name_metvars3d)) then
> >       allocate( name_metvars3d(GSI_MetGuess_Bundle(it)%n3d))
> >     end if
> >     
> >     if (laeroana_fv3cmaq.or.laeroana_fv3smoke) then
> >       if (.not.allocated(name_chemvars3d)) then
> >         allocate( name_chemvars3d(GSI_ChemGuess_Bundle(it)%n3d))
> >       endif
> >     endif
> > 
> >     call gsi_bundleinquire (GSI_MetGuess_Bundle(it),'shortnames::2d', name_metvars2d,istatus)
> >     call gsi_bundleinquire (GSI_MetGuess_Bundle(it),'shortnames::3d', name_metvars3d,istatus)
> >     if (laeroana_fv3cmaq.or.laeroana_fv3smoke) then
> >       call gsi_bundleinquire (GSI_ChemGuess_Bundle(it),'shortnames::3d', name_chemvars3d,istatus)
> >     endif
> > 
> >     if(mype == 0) then
> >       do i=1,GSI_MetGuess_Bundle(it)%n2d
> >         write(6,*)'metvardeb333-2d name ', trim(name_metvars2d(i))
> >       enddo
> >       do i=1,GSI_MetGuess_Bundle(it)%n3d
> >         write(6,*)'metvardeb333-3d name ', trim(name_metvars3d(i))
> >       enddo
> >       if (laeroana_fv3cmaq.or.laeroana_fv3smoke) then
> >         do i=1,GSI_ChemGuess_Bundle(it)%n3d
> >           write(6,*)'chemvardeb333-3d name ', trim(name_chemvars3d(i))
> >         enddo
> >       endif
> >     endif
> >   
> > !here a strict requirment for the names of "u" and "v" is rquired
> > !maybe more flexibile procedure would relax it
> >      iuv=0
> >      ndynvario3d=0
> >      ntracerio3d=0
> >      nphyvario3d=0
> >      do i=1,size(name_metvars3d)
> >        vartem=trim(name_metvars3d(i))
> >        if(trim(vartem)=='u'.or.trim(vartem)=='v') then
> >          iuv=iuv+1
> >        else
> >          if(.not.(trim(vartem)=='iqr')) then
> >            if (ifindstrloc(vardynvars,trim(vartem))> 0) then
> >               ndynvario3d=ndynvario3d+1
> >            else if (ifindstrloc(vartracers,trim(vartem))> 0) then
> >               ntracerio3d=ntracerio3d+1
> >            else if (ifindstrloc(varphyvars,trim(vartem))> 0) then
> >               nphyvario3d=nphyvario3d+1
> >            else 
> >                write(6,*)'the metvarname1 ',trim(vartem),' has not been considered yet, stop'
> >                call stop2(333)
> >            endif 
> >          endif ! iqr is the inital qr, need not to be in IO 
> >        endif
> >       end do 
> >       if (iuv /= 2.or. ndynvario3d<=0.or.ntracerio3d<=0 ) then
> >         write(6,*)"the set up for met variable is not as expected, abort"
> >         call stop2(222)
> >       endif
> > 
> >       ivar=0 ; if (if_model_dbz) ivar=ivar+1; if(if_model_fed)  ivar=ivar+1 
> >       if ( ivar >  nphyvario3d ) then 
> >          write(6,*)"the set up for met variable (dbz and fed in phyvar) is not as expected,abort"
> >          call stop2(223)
> >       end if     
> > 
> >       if (fv3sar_bg_opt == 0.and.ifindstrloc(name_metvars3d,'delp') <= 0)then
> >          ndynvario3d=ndynvario3d+1  ! for delp  
> >       endif
> >       if (fv3sar_bg_opt == 1.and.ifindstrloc(name_metvars3d,'delp') > 0)then
> >          ndynvario3d=ndynvario3d-1  ! delp should not be used in IO  
> >       endif
> >       if (l_reg_update_hydro_delz.and.fv3sar_bg_opt==0) ndynvario3d=ndynvario3d+1 ! for delzinc
> >       allocate(fv3lam_io_dynmetvars3d_nouv(ndynvario3d))
> >       allocate(fv3lam_io_tracermetvars3d_nouv(ntracerio3d))
> >       allocate(fv3lam_io_phymetvars3d_nouv(nphyvario3d))
> > 
> >       if (laeroana_fv3cmaq) then
> >         allocate(fv3lam_io_tracerchemvars3d_nouv(naero_cmaq_fv3+7))
> >       endif 
> >   
> >       if (laeroana_fv3smoke) then 
> >         allocate(fv3lam_io_tracersmokevars3d_nouv(naero_smoke_fv3+1)) 
> >       endif
> > 
> >       jdynvar=0
> >       jtracer=0
> >       jphyvar=0
> >       do i=1,size(name_metvars3d)
> >         vartem=trim(name_metvars3d(i))
> >         if(.not.(trim(vartem)=='u'.or.trim(vartem)=='v'.or.trim(vartem)=='iqr')) then
> >           if(trim(vartem)=="tv" ) then
> >             jdynvar=jdynvar+1
> >             fv3lam_io_dynmetvars3d_nouv(jdynvar)="tsen"
> >           else if (ifindstrloc(vardynvars,trim(vartem)) > 0) then
> >             if(.not.(fv3sar_bg_opt==1.and.trim(vartem)=="delp")) then
> >               jdynvar=jdynvar+1
> >               fv3lam_io_dynmetvars3d_nouv(jdynvar)=trim(vartem)
> >             endif
> >            else if (ifindstrloc(vartracers,trim(vartem)) > 0) then
> >              jtracer=jtracer+1
> >              fv3lam_io_tracermetvars3d_nouv(jtracer)=trim(vartem)
> >            else if (ifindstrloc(varphyvars,trim(vartem)) > 0) then
> >              jphyvar=jphyvar+1
> >              fv3lam_io_phymetvars3d_nouv(jphyvar)=trim(vartem)
> >            else
> >               write(6,*)'the metvarname ',vartem,' is not expected, stop'
> >               call stop2(333)
> >            endif
> >         endif
> >       enddo
> >       if(fv3sar_bg_opt == 0.and.ifindstrloc( fv3lam_io_dynmetvars3d_nouv(1:jdynvar),"delp")<= 0)  then
> >         jdynvar=jdynvar+1
> >         fv3lam_io_dynmetvars3d_nouv(jdynvar)="delp"
> >       endif
> >       if (l_reg_update_hydro_delz.and.fv3sar_bg_opt==0) then 
> >          jdynvar=jdynvar+1
> >          fv3lam_io_dynmetvars3d_nouv(jdynvar)="delzinc"
> >       endif
> >       if(jdynvar /= ndynvario3d.or.jtracer /= ntracerio3d.or.jphyvar /= nphyvario3d  ) then
> >           write(6,*)'ndynvario3d is not as expected, stop'
> >           call stop2(333)
> >       endif
> >       if(mype == 0) then
> >         write(6,*) ' fv3lam_io_dynmetvars3d_nouv is ',(trim(fv3lam_io_dynmetvars3d_nouv(i)),i=1,ndynvario3d)
> >         write(6,*) ' fv3lam_io_tracermevars3d_nouv is ',(trim(fv3lam_io_tracermetvars3d_nouv(i)),i=1,ntracerio3d)
> >         write(6,*) ' fv3lam_io_phymetvars3d_nouv is ',(trim(fv3lam_io_phymetvars3d_nouv(i)),i=1,nphyvario3d)
> >       endif
> >  
> >       ndynvario2d=0
> >       ntracerio2d=0
> >       do i=1,size(name_metvars2d)
> >         vartem=trim(name_metvars2d(i))
> >         if(.not. (trim(vartem)=='ps'.and.fv3sar_bg_opt==0)) then
> >           if (ifindstrloc(vardynvars,trim(vartem))> 0) then
> >             ndynvario2d=ndynvario2d+1
> >           else if (ifindstrloc(vartracers,trim(vartem)) > 0) then
> >             ntracerio2d=ntracerio2d+1
> >           else if(trim(vartem)=='z') then
> >              if(mype == 0) write(6,*)'the metvarname ',trim(vartem),' will be dealt separately'
> >           else if(trim(vartem)=='t2m') then
> >           else if(trim(vartem)=='q2m') then
> >           else if(trim(vartem)=='howv') then
> >           else 
> >             write(6,*)'the metvarname2 ',trim(vartem),' has not been considered yet, stop'
> >             call stop2(333)
> >         endif 
> >        endif
> >       end do 
> >       if (ndynvario2d > 0) then
> >         if (.not. allocated(fv3lam_io_dynmetvars2d_nouv)) then
> >           allocate(fv3lam_io_dynmetvars2d_nouv(ndynvario2d))
> >         end if
> >       endif
> >       if (ntracerio2d > 0) then
> >         allocate(fv3lam_io_tracermetvars2d_nouv(ntracerio2d))
> >       end if
> >       jdynvar=0
> >       jtracer=0
> >       do i=1,size(name_metvars2d)
> >         vartem=trim(name_metvars2d(i))
> >         if(.not.( (trim(vartem)=='ps'.and.fv3sar_bg_opt==0).or.(trim(vartem)=="z") &
> >                   .or.(trim(vartem)=="t2m").or.(trim(vartem)=="q2m")               &
> >                   .or.(trim(vartem)=="howv")))  then ! z is treated separately
> >           if (ifindstrloc(vardynvars,trim(vartem)) > 0) then
> >             jdynvar=jdynvar+1
> >             fv3lam_io_dynmetvars2d_nouv(jdynvar)=trim(vartem)
> >           else if (ifindstrloc(vartracers,trim(vartem)) > 0) then
> >             jtracer=jtracer+1
> >             fv3lam_io_tracermetvars2d_nouv(jtracer)=trim(vartem)
> >           else 
> >             write(6,*)'the metvarname3 ',trim(vartem),' has not been considered yet, stop'
> >             call stop2(333)
> >           endif 
> >         endif
> >       end do 
> >       if(mype == 0) then
> >         if (allocated(fv3lam_io_dynmetvars2d_nouv)) &
> >           write(6,*)' fv3lam_io_dynmetvars2d_nouv is ',(trim(fv3lam_io_dynmetvars2d_nouv(i)), i=1,ndynvario2d)
> >         if (allocated(fv3lam_io_tracermetvars2d_nouv))&
> >           write(6,*)'fv3lam_io_tracermetvars2d_nouv is ',(trim(fv3lam_io_tracermetvars2d_nouv(i)),i=1,ntracerio2d)
> >       endif      
> > 
> >       if (laeroana_fv3cmaq) then
> >         jtracer = 0
> > !name_chemvars3d chemguess from anavinfo
> >         do i=1,size(name_chemvars3d)
> >           vartem=trim(name_chemvars3d(i))
> >           if (ifindstrloc(aeronames_cmaq_fv3,trim(vartem)) > 0) then
> >             jtracer=jtracer+1
> >             fv3lam_io_tracerchemvars3d_nouv(jtracer)=trim(vartem)
> >             write(6,*)'the chemvarname ',jtracer,vartem,' is found '
> >           else
> >             write(6,*)'the chemvarname ',vartem,' is not in aeronames_cmaq_fv3, !!!!!!!!!!'
> >           endif
> >         enddo
> > 
> >         ntracerchemio3d=jtracer+7
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+1)="pm25at"
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+2)="pm25ac"
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+3)="pm25co"
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+4)="pm2_5"
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+5)="amassi"
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+6)="amassj"
> >         fv3lam_io_tracerchemvars3d_nouv(jtracer+7)="amassk"
> > 
> >         if (mype == 0) then
> >           write(6,*) ' fv3lam_io_tracerchemvars3d_nouv is',(trim(fv3lam_io_tracerchemvars3d_nouv(i)),i=1,ntracerchemio3d)
> >         endif
> > 
> >       endif !laeroana_fv3cmaq
> > 
> >       if (laeroana_fv3smoke) then
> >         jtracer = 0
> > !name_chemvars3d chemguess from anainfo
> >         do i=1,size(name_chemvars3d)
> >           vartem=trim(name_chemvars3d(i))
> >            if (ifindstrloc(aeronames_smoke_fv3,trim(vartem)) > 0) then
> >              jtracer=jtracer+1
> >              fv3lam_io_tracersmokevars3d_nouv(jtracer)=trim(vartem)
> >               write(6,*)'the chemvarname ',jtracer,vartem,' is found '
> >               if (trim(vartem) == "pm2_5")then
> >                 write(6,*)'the chemvarname ',vartem,' will be calculated.'
> >               endif
> > 
> >            else
> >               if (trim(vartem) /= "pm2_5")then
> >                 write(6,*)'the chemvarname ',vartem,' is not in aeronames_smoke_fv3 !!!'
> >               endif
> >            endif
> >         enddo
> >         ntracersmokeio3d=jtracer+1
> >         fv3lam_io_tracersmokevars3d_nouv(jtracer+1)="pm2_5"
> > 
> >         if (mype == 0) then
> >           write(6,*) ' fv3lam_io_tracersmokevars3d_nouv is',(trim(fv3lam_io_tracersmokevars3d_nouv(i)),i=1,ntracersmokeio3d)
> >         endif
> > 
> >       endif !laeroana_fv3smoke
> > 
> > 
> >       if (allocated(fv3lam_io_dynmetvars2d_nouv) ) then   
> >         call gsi_bundlecreate(gsibundle_fv3lam_dynvar_nouv,GSI_MetGuess_Bundle(it)%grid,'gsibundle_fv3lam_dynvar_nouv',istatus,&
> >                  names2d=fv3lam_io_dynmetvars2d_nouv,names3d=fv3lam_io_dynmetvars3d_nouv)
> >         ndynvario2d=size(fv3lam_io_dynmetvars2d_nouv)
> >       else
> >         call gsi_bundlecreate(gsibundle_fv3lam_dynvar_nouv,GSI_MetGuess_Bundle(it)%grid,'gsibundle_fv3lam_dynvar_nouv',istatus, &
> >                  names3d=fv3lam_io_dynmetvars3d_nouv)
> >         ndynvario2d=0
> >       endif
> >       if (allocated(fv3lam_io_tracermetvars2d_nouv) ) then   
> >         call gsi_bundlecreate(gsibundle_fv3lam_tracer_nouv,GSI_MetGuess_Bundle(it)%grid,'gsibundle_fv3lam_tracer_varnouv',istatus,&
> >                  names2d=fv3lam_io_tracermetvars2d_nouv,names3d=fv3lam_io_tracermetvars2d_nouv)
> >         ntracerio2d=size(fv3lam_io_tracermetvars2d_nouv)
> >       else
> >         call gsi_bundlecreate(gsibundle_fv3lam_tracer_nouv,GSI_MetGuess_Bundle(it)%grid,'gsibundle_fv3lam_tracer_nouv',istatus, &
> >                  names3d=fv3lam_io_tracermetvars3d_nouv)
> >         ntracerio2d=0
> >       endif
> >  
> >       if( allocated(fv3lam_io_phymetvars3d_nouv) )then
> >         call gsi_bundlecreate(gsibundle_fv3lam_phyvar_nouv,GSI_MetGuess_Bundle(it)%grid,'gsibundle_fv3lam_phyvar_nouv',istatus, &
> >                  names3d=fv3lam_io_phymetvars3d_nouv)
> >       end if
> >  
> >       if (laeroana_fv3cmaq) then
> >         if (allocated(fv3lam_io_tracerchemvars3d_nouv) ) then
> >           call gsi_bundlecreate(gsibundle_fv3lam_tracerchem_nouv,GSI_ChemGuess_Bundle(it)%grid,'gsibundle_fv3lam_tracerchem_nouv',istatus, &
> >                  names3d=fv3lam_io_tracerchemvars3d_nouv)
> >         endif
> >       endif
> > 
> >       if (laeroana_fv3smoke) then
> >         if (allocated(fv3lam_io_tracersmokevars3d_nouv) ) then
> >           call gsi_bundlecreate(gsibundle_fv3lam_tracersmoke_nouv,GSI_ChemGuess_Bundle(it)%grid,'gsibundle_fv3lam_tracersmoke_nouv',istatus,&
> >                  names3d=fv3lam_io_tracersmokevars3d_nouv)
> >         endif
> >       endif
> > 
> > 
> >       inner_vars=1
> >       numfields=inner_vars*(ndynvario3d*grd_a%nsig+ndynvario2d) 
> >       allocate(lnames(1,numfields),names(1,numfields))
> >       ilev=1
> >       do i=1,ndynvario3d
> >         do k=1,grd_a%nsig
> >           lnames(1,ilev)=k
> >           names(1,ilev)=trim(fv3lam_io_dynmetvars3d_nouv(i))
> >           ilev=ilev+1
> >         enddo
> >       enddo
> >       do i=1,ndynvario2d
> >         lnames(1,ilev)=1
> >         names(1,ilev)=trim(fv3lam_io_dynmetvars2d_nouv(i))
> >         ilev=ilev+1
> >       enddo
> >       call general_sub2grid_create_info(grd_fv3lam_dynvar_ionouv,inner_vars,grd_a%nlat,&
> >             grd_a%nlon,grd_a%nsig,numfields,regional,names=names,lnames=lnames)
> >       inner_vars=1
> >       numfields=inner_vars*(ntracerio3d*grd_a%nsig+ntracerio2d) 
> >       deallocate(lnames,names)
> >       allocate(lnames(1,numfields),names(1,numfields))
> >       ilev=1
> >       do i=1,ntracerio3d
> >         do k=1,grd_a%nsig
> >           lnames(1,ilev)=k
> >           names(1,ilev)=trim(fv3lam_io_tracermetvars3d_nouv(i))
> >           ilev=ilev+1
> >         enddo
> >       enddo
> >       do i=1,ntracerio2d
> >          lnames(1,ilev)=1
> >          names(1,ilev)=trim(fv3lam_io_tracermetvars2d_nouv(i))
> >          ilev=ilev+1
> >       enddo
> >       call general_sub2grid_create_info(grd_fv3lam_tracer_ionouv,inner_vars,grd_a%nlat,&
> >             grd_a%nlon,grd_a%nsig,numfields,regional,names=names,lnames=lnames)
> > 
> >       if (laeroana_fv3cmaq) then
> >         inner_vars=1
> >         numfields=inner_vars*(ntracerchemio3d*grd_a%nsig)
> >         deallocate(lnames,names)
> >         allocate(lnames(1,numfields),names(1,numfields))
> >         ilev=1
> >         do i=1,ntracerchemio3d
> >           do k=1,grd_a%nsig
> >             lnames(1,ilev)=k
> >             names(1,ilev)=trim(fv3lam_io_tracerchemvars3d_nouv(i))
> >             ilev=ilev+1
> >           enddo
> >         enddo
> >         call general_sub2grid_create_info(grd_fv3lam_tracerchem_ionouv,inner_vars,grd_a%nlat,&
> >             grd_a%nlon,grd_a%nsig,numfields,regional,names=names,lnames=lnames)
> > 
> >       endif
> > 
> >       if (laeroana_fv3smoke) then
> >         inner_vars=1
> >         numfields=inner_vars*(ntracersmokeio3d*grd_a%nsig)
> >         deallocate(lnames,names)
> >         allocate(lnames(1,numfields),names(1,numfields))
> >         ilev=1
> >         do i=1,ntracersmokeio3d
> >           do k=1,grd_a%nsig
> >             lnames(1,ilev)=k
> >             names(1,ilev)=trim(fv3lam_io_tracersmokevars3d_nouv(i))
> >             ilev=ilev+1
> >           enddo
> >         enddo
> >         call general_sub2grid_create_info(grd_fv3lam_tracersmoke_ionouv,inner_vars,grd_a%nlat,&
> >               grd_a%nlon,grd_a%nsig,numfields,regional,names=names,lnames=lnames)
> > 
> >       endif
> > 
> >       if ( if_model_dbz .or. if_model_fed )then
> >         inner_vars=1
> >         numfields=inner_vars*(nphyvario3d*grd_a%nsig)
> >         deallocate(lnames,names)
> >         allocate(lnames(1,numfields),names(1,numfields))
> >         ilev=1
> >         do i=1,nphyvario3d
> >           do k=1,grd_a%nsig
> >             lnames(1,ilev)=k
> >             names(1,ilev)=trim(fv3lam_io_phymetvars3d_nouv(i))
> >             ilev=ilev+1
> >           enddo
> >         enddo
> >         call general_sub2grid_create_info(grd_fv3lam_phyvar_ionouv,inner_vars,grd_a%nlat,&
> >               grd_a%nlon,grd_a%nsig,numfields,regional,names=names,lnames=lnames)
> >       end if
> > 
> >       inner_vars=2
> >       numfields=grd_a%nsig
> >       allocate(uvlnames(inner_vars,numfields),uvnames(inner_vars,numfields))
> >       do k=1,grd_a%nsig
> >         uvlnames(1,k)=k
> >         uvlnames(2,k)=k
> >         uvnames(1,k)='u'
> >         uvnames(2,k)='v'
> >       enddo
> >       call general_sub2grid_create_info(grd_fv3lam_uv,inner_vars,grd_a%nlat,&
> >            grd_a%nlon,grd_a%nsig,numfields,regional,names=uvnames,lnames=uvlnames)
> > 
> >       deallocate(lnames,names,uvlnames,uvnames)
> > 
> >       do it=1,nfldsig
> >          ier=0
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'ps' ,ges_ps ,istatus );ier=ier+istatus
> >          
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'z' , ges_z ,istatus );ier=ier+istatus
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'u' , ges_u ,istatus );ier=ier+istatus
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'v' , ges_v ,istatus );ier=ier+istatus
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'tv' ,ges_tv ,istatus );ier=ier+istatus
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'q'  ,ges_q ,istatus );ier=ier+istatus
> >          call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'oz'  ,ges_oz ,istatus );ier=ier+istatus
> >          if (l_use_dbz_directDA .or. nphyvario3d > 0) then
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'ql' ,ges_ql ,istatus );ier=ier+istatus
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qi' ,ges_qi ,istatus );ier=ier+istatus
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qr' ,ges_qr ,istatus );ier=ier+istatus
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qs' ,ges_qs ,istatus );ier=ier+istatus
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qg' ,ges_qg ,istatus );ier=ier+istatus
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'w' , ges_w ,istatus );ier=ier+istatus
> >             if (l_use_dbz_directDA) then
> >                call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'iqr' ,ges_iqr ,istatus );ier=ier+istatus
> >                call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qnr',ges_qnr ,istatus );ier=ier+istatus
> >             end if
> >             if(if_model_dbz) &
> >                call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'dbz' , ges_dbz ,istatus );ier=ier+istatus
> >             if(if_model_fed) &
> >                call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'fed' , ges_fed ,istatus );ier=ier+istatus
> >          end if
> >          if (ier/=0) call die(trim(myname),'cannot get pointers for fv3 met-fields, ier =',ier)
> >    
> >          if(i_use_2mq4b > 0 .and. i_use_2mt4b > 0 ) then
> >             call GSI_BundleGetPointer(GSI_MetGuess_Bundle(it),'q2m',ges_q2m,istatus ); ier=ier+istatus
> >             if (ier/=0) call die(trim(myname),'cannot get pointers for q2m, ier=',ier)
> >             call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it),'t2m',ges_t2m,istatus );ier=ier+istatus
> >             if (ier/=0) call die(trim(myname),'cannot get pointers for t2m,ier=',ier)
> >          endif
> > 
> > !---     significant wave height (howv)
> >          if ( i_howv_3dda == 1 ) then
> >             call GSI_BundleGetPointer(GSI_MetGuess_Bundle(it),'howv',ges_howv,istatus ); ier=ier+istatus
> >             if (ier/=0) call die(trim(myname),'cannot get pointers for howv, ier=',ier)
> >          endif
> > 
> >          if(mype == 0 ) then
> >            call check(nf90_open(fv3filenamegin(it)%dynvars,nf90_nowrite,loc_id))
> >            call check(nf90_inquire(loc_id,formatNum=ncfmt))
> >            call check(nf90_close(loc_id))
> >            if(ncfmt /= nf90_format_netcdf4) then
> >               write(6,*) &
> >               'the current GSI parallelization IO for fv3_lam only works for netcdf4',&
> >               'ncfmt should be ', nf90_format_netcdf4,&
> >               ' GSI will stop  while, dynvars file is ', ncfmt
> >               call stop2(333)
> >            endif
> >            call check(nf90_open(fv3filenamegin(it)%tracers,nf90_nowrite,loc_id))
> >            call check(nf90_inquire(loc_id,formatNum=ncfmt))
> >            call check(nf90_close(loc_id))
> >            if(ncfmt /= nf90_format_netcdf4) then
> >               write(6,*) &
> >               'the current GSI parallelization IO for fv3_lam only works for netcdf4',&
> >               'ncfmt should be ', nf90_format_netcdf4,&
> >               ' GSI will stop  while, tracer file is ', ncfmt
> >               call stop2(333)
> >            endif
> >          endif
> > 
> >          if (laeroana_fv3cmaq) then
> >             ier=0
> >             call gsi_bundlegetpointer_fv3lam_chemguess
> >             if (ier/=0) call die(trim(myname),'cannot get pointers for fv3chem-fields, ier =',ier)
> >          end if
> > 
> >          if (laeroana_fv3smoke) then
> >            call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'smoke',ges_smoke,istatus );ier=ier+istatus
> >            call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'dust', ges_dust,istatus );ier=ier+istatus
> >            call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'pm2_5',ges_pm2_5,istatus );ier=ier+istatus
> >          end if
> > 
> >          if( fv3sar_bg_opt == 0) then 
> >             call gsi_fv3ncdf_readuv(grd_fv3lam_uv,ges_u,ges_v,fv3filenamegin(it),.false.)
> >          else
> >            call gsi_fv3ncdf_readuv_v1(grd_fv3lam_uv,ges_u,ges_v,fv3filenamegin(it),.false.)
> >          endif
> > 
> >          if( fv3sar_bg_opt == 0) then 
> >             call gsi_fv3ncdf_read(grd_fv3lam_dynvar_ionouv,gsibundle_fv3lam_dynvar_nouv &
> >             & ,fv3filenamegin(it)%dynvars,fv3filenamegin(it),.false.)
> >             call gsi_fv3ncdf_read(grd_fv3lam_tracer_ionouv,gsibundle_fv3lam_tracer_nouv &
> >             & ,fv3filenamegin(it)%tracers,fv3filenamegin(it),.false.)
> >             if( nphyvario3d > 0 )then
> >                call gsi_fv3ncdf_read(grd_fv3lam_phyvar_ionouv,gsibundle_fv3lam_phyvar_nouv &
> >                & ,fv3filenamegin(it)%phyvars,fv3filenamegin(it),.false.)
> >             end if
> >             if (laeroana_fv3cmaq) then
> >               call gsi_fv3ncdf_read(grd_fv3lam_tracerchem_ionouv,gsibundle_fv3lam_tracerchem_nouv &
> >               & ,fv3filenamegin(it)%tracers,fv3filenamegin(it),.false.)
> >             endif
> >             if (laeroana_fv3smoke) then
> >               call gsi_fv3ncdf_read(grd_fv3lam_tracersmoke_ionouv,gsibundle_fv3lam_tracersmoke_nouv &
> >               & ,fv3filenamegin(it)%tracers,fv3filenamegin(it),.false.)
> >             endif
> >          else
> >             call gsi_fv3ncdf_read_v1(grd_fv3lam_dynvar_ionouv,gsibundle_fv3lam_dynvar_nouv &
> >             & ,fv3filenamegin(it)%dynvars,fv3filenamegin(it),.false.)
> >             call gsi_fv3ncdf_read_v1(grd_fv3lam_tracer_ionouv,gsibundle_fv3lam_tracer_nouv &
> >             & ,fv3filenamegin(it)%tracers,fv3filenamegin(it),.false.)
> >             if (laeroana_fv3cmaq) then
> >               call gsi_fv3ncdf_read_v1(grd_fv3lam_tracerchem_ionouv,gsibundle_fv3lam_tracerchem_nouv &
> >               & ,fv3filenamegin(it)%tracers,fv3filenamegin(it),.false.)
> >             endif
> >             if (laeroana_fv3smoke) then
> >               call gsi_fv3ncdf_read_v1(grd_fv3lam_tracersmoke_ionouv,gsibundle_fv3lam_tracersmoke_nouv &
> >               & ,fv3filenamegin(it)%tracers,fv3filenamegin(it),.false.)
> >             endif
> >          endif
> >    
> >          if (laeroana_fv3cmaq) then
> >            ier=0
> >            call gsi_bundlegetpointer_fv3lam_tracerchem_nouv
> >            if (ier/=0) call die(trim(myname),'cannot get pointers for fv3lam_tracerchem_nouv, ier =',ier)
> > 
> >          ! Compute background amassi, amassj, amassk and pm2_5   
> >            do k=1,nsig
> >              do j=1,lon2
> >                do i=1,lat2
> >                  ! imodes
> >                  ges_amassi(i,j,k)=ges_aso4i(i,j,k)+ges_ano3i(i,j,k)+ges_anh4i(i,j,k)+ &
> >                                ges_anai(i,j,k) +ges_acli(i,j,k) +ges_aeci(i,j,k) + &
> >                                ges_alvpo1i(i,j,k)+ges_asvpo1i(i,j,k)+ges_asvpo2i(i,j,k)+&
> >                                ges_alvoo1i(i,j,k)+ges_alvoo2i(i,j,k)+ &
> >                                ges_asvoo1i(i,j,k)+ges_asvoo2i(i,j,k)+ges_aothri(i,j,k)
> >                  ! jmodes
> >                  ges_amassj(i,j,k)=ges_aso4j(i,j,k)+ges_ano3j(i,j,k)+ges_anh4j(i,j,k)+ &
> >                                ges_anaj(i,j,k) +ges_aclj(i,j,k) +ges_aecj(i,j,k) + &
> >                                ges_alvpo1j(i,j,k)+ges_asvpo1j(i,j,k)+ges_asvpo2j(i,j,k)+&
> >                                ges_asvpo3j(i,j,k)+ges_aivpo1j(i,j,k)+ &
> >                                ges_axyl1j(i,j,k) +ges_axyl2j(i,j,k)+ges_axyl3j(i,j,k)+ges_atol1j(i,j,k)+ges_aothrj(i,j,k)+&
> >                                ges_afej(i,j,k)   +ges_asij(i,j,k)  +ges_atij(i,j,k)  +ges_acaj(i,j,k)+&
> >                                ges_amgj(i,j,k)   +ges_amnj(i,j,k)  +ges_aalj(i,j,k)  +ges_akj(i,j,k)+&
> >                                ges_atol2j(i,j,k) +ges_atol3j(i,j,k)+&
> >                                ges_abnz1j(i,j,k) +ges_abnz2j(i,j,k)+ges_abnz3j(i,j,k)+&
> >                                ges_aiso1j(i,j,k) +ges_aiso2j(i,j,k)+ges_aiso3j(i,j,k)+&
> >                                ges_atrp1j(i,j,k) +ges_atrp2j(i,j,k)+ges_asqtj(i,j,k)+&
> >                                ges_aalk1j(i,j,k) +ges_aalk2j(i,j,k)+&
> >                                ges_apah1j(i,j,k) +ges_apah2j(i,j,k)+ges_apah3j(i,j,k)+&
> >                                ges_aorgcj(i,j,k) +ges_aolgbj(i,j,k)+ges_aolgaj(i,j,k)+&
> >                                ges_alvoo1j(i,j,k)+ges_alvoo2j(i,j,k)+&
> >                                ges_asvoo1j(i,j,k)+ges_asvoo2j(i,j,k)+ges_asvoo3j(i,j,k)+&
> >                                ges_apcsoj(i,j,k)
> >                  ! kmodes
> >                  ges_amassk(i,j,k)=ges_aso4k(i,j,k)+ges_ano3k(i,j,k)+ges_anh4k(i,j,k)+ &
> >                                ges_asoil(i,j,k)+ges_acors(i,j,k)+ges_aseacat(i,j,k)+ges_aclk(i,j,k)
> > 
> >                  ges_pm2_5(i,j,k)=ges_pm25at(i,j,k)*ges_amassi(i,j,k) +  ges_pm25ac(i,j,k)*ges_amassj(i,j,k) + &
> >                                ges_pm25co(i,j,k)*ges_amassk(i,j,k)
> >                enddo
> >              enddo
> >            enddo
> >          end if ! laeroana_fv3cmaq 
> > 
> >          if (laeroana_fv3smoke) then
> >            ier=0
> >            call GSI_BundleGetPointer ( gsibundle_fv3lam_tracersmoke_nouv,'smoke',ges_smoke,istatus );ier=ier+istatus
> >            call GSI_BundleGetPointer ( gsibundle_fv3lam_tracersmoke_nouv,'dust',ges_dust,istatus );ier=ier+istatus
> >            call GSI_BundleGetPointer ( gsibundle_fv3lam_tracersmoke_nouv,'pm2_5',ges_pm2_5,istatus );ier=ier+istatus
> >            if (ier/=0) call die(trim(myname),'cannot get pointers for fv3 chem-fields, ier =',ier)
> >            ! Calculate  pm2_5
> >              do k=1,nsig
> >                do j=1,lon2
> >                  do i=1,lat2
> >                    ges_pm2_5(i,j,k)=ges_smoke(i,j,k) +  ges_dust(i,j,k)
> >                  enddo
> >                enddo
> >              enddo
> >          endif !laeroana_fv3smoke 
> > 
> >          if( fv3sar_bg_opt == 0) then
> >            call GSI_BundleGetPointer ( gsibundle_fv3lam_dynvar_nouv, 'delp'  ,ges_delp ,istatus );ier=ier+istatus
> >            if(istatus==0) ges_delp=ges_delp*0.001_r_kind
> >          endif
> >          call gsi_copy_bundle(gsibundle_fv3lam_dynvar_nouv,GSI_MetGuess_Bundle(it))
> >          call gsi_copy_bundle(gsibundle_fv3lam_tracer_nouv,GSI_MetGuess_Bundle(it))
> >          if (laeroana_fv3cmaq) then
> >            call gsi_copy_bundle(gsibundle_fv3lam_tracerchem_nouv,GSI_ChemGuess_Bundle(it))
> >          endif
> >          if (laeroana_fv3smoke) then
> >            call gsi_copy_bundle(gsibundle_fv3lam_tracersmoke_nouv,GSI_ChemGuess_Bundle(it))
> >          endif
> >          if ( nphyvario3d > 0 ) then 
> >            call gsi_copy_bundle(gsibundle_fv3lam_phyvar_nouv,GSI_MetGuess_Bundle(it))
> >          end if
> >          call GSI_BundleGetPointer ( gsibundle_fv3lam_dynvar_nouv, 'tsen' ,ges_tsen_readin ,istatus );ier=ier+istatus
> >      !!  tsen2tv  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
> >          do k=1,nsig
> >             do j=1,lon2
> >                do i=1,lat2
> >                   ges_tv(i,j,k)=ges_tsen_readin(i,j,k)*(one+fv*ges_q(i,j,k))
> >                enddo
> >             enddo
> >          enddo
> >          if( fv3sar_bg_opt == 0) then
> >            if (.not.allocated(ges_delp_bg))allocate(ges_delp_bg(lat2,lon2,nsig))
> >            if (.not.allocated(ges_ps_bg))allocate(ges_ps_bg(lat2,lon2))
> >            ges_delp_bg=ges_delp
> >            ges_prsi(:,:,nsig+1,it)=eta1_ll(nsig+1)
> >            do i=nsig,1,-1
> >               ges_prsi(:,:,i,it)=ges_delp(:,:,i)+ges_prsi(:,:,i+1,it)
> >            enddo
> >            ges_ps(:,:)=ges_prsi(:,:,1,it)
> >            ges_ps_bg=ges_ps
> >          else
> >            call GSI_BundleGetPointer ( gsibundle_fv3lam_dynvar_nouv, 'ps'  ,ges_ps_readin ,istatus );ier=ier+istatus
> >            ges_ps_readin=ges_ps_readin*0.001_r_kind  !which is from 
> >            ges_ps=ges_ps_readin
> >            ges_ps_bg=ges_ps
> >            ges_prsi(:,:,nsig+1,it)=eta1_ll(nsig+1)
> >            do k=1,nsig
> >               ges_prsi(:,:,k,it)=eta1_ll(k)+eta2_ll(k)*ges_ps
> >            enddo
> > 
> > 
> > 
> >          endif
> > 
> > 
> >          call gsi_fv3ncdf2d_read(fv3filenamegin(it),it,ges_z,ges_t2m,ges_q2m,ges_howv)
> > 
> >          if(i_use_2mq4b > 0 .and. i_use_2mt4b > 0 ) then
> > ! Convert 2m guess mixing ratio to specific humidity
> >             ges_q2m = ges_q2m/(one+ges_q2m)
> >          endif
> > 
> >          if (l_use_dbz_directDA ) then
> >            if( fv3sar_bg_opt == 0) then
> >              ges_iqr=ges_qr
> >            else
> >               write(6,*) "FV3 IO READ for 'fv3sar_bg_opt == 0' is only available for now in direct reflectivity DA"
> >               stop
> >            end if
> > 
> >            call convert_qx_to_cvpqx(ges_qr, ges_qs, ges_qg, l_use_cvpqx, cvpqx_pval) ! convert Qx
> >            call convert_nx_to_cvpnx(ges_qnr, l_cvpnr, cvpnr_pval)                          ! convert Qnx
> > 
> >          end if
> > 
> >       end do
> > contains
> > subroutine gsi_bundlegetpointer_fv3lam_chemguess 
> >     implicit none
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aalj',ges_aalj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'acaj',ges_acaj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'acli',ges_acli,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aclj',ges_aclj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aclk',ges_aclk,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'acors',ges_acors,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aeci',ges_aeci,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aecj',ges_aecj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'afej',ges_afej,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aivpo1j',ges_aivpo1j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'akj',ges_akj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo1i',ges_alvoo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo2i',ges_alvoo2i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvpo1i',ges_alvpo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvpo1j',ges_alvpo1j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amgj',ges_amgj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amnj',ges_amnj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anai',ges_anai,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anaj',ges_anaj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anh4i',ges_anh4i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anh4j',ges_anh4j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anh4k',ges_anh4k,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'ano3i',ges_ano3i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'ano3j',ges_ano3j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'ano3k',ges_ano3k,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aothri',ges_aothri,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aothrj',ges_aothrj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aseacat',ges_aseacat,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asij',ges_asij,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aso4i',ges_aso4i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aso4j',ges_aso4j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aso4k',ges_aso4k,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asoil',ges_asoil,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo1i',ges_asvoo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo2i',ges_asvoo2i,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo1i',ges_asvpo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo1j',ges_asvpo1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo2i',ges_asvpo2i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo2j',ges_asvpo2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo3j',ges_asvpo3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atij',ges_atij,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atol1j',ges_atol1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atol2j',ges_atol2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atol3j',ges_atol3j,istatus );ier=ier+istatus
> > 
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'abnz1j',ges_abnz1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'abnz2j',ges_abnz2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'abnz3j',ges_abnz3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aiso1j',ges_aiso1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aiso2j',ges_aiso2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aiso3j',ges_aiso3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atrp1j',ges_atrp1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atrp2j',ges_atrp2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asqtj' ,ges_asqtj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aalk1j',ges_aalk1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aalk2j',ges_aalk2j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apah1j',ges_apah1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apah2j',ges_apah2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apah3j',ges_apah3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aorgcj',ges_aorgcj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aolgbj',ges_aolgbj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aolgaj',ges_aolgaj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo1j',ges_alvoo1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo2j',ges_alvoo2j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo1j',ges_asvoo1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo2j',ges_asvoo2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo3j',ges_asvoo3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apcsoj',ges_apcsoj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'axyl1j',ges_axyl1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'axyl2j',ges_axyl2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'axyl3j',ges_axyl3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'pm25at',ges_pm25at,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'pm25ac',ges_pm25ac,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'pm25co',ges_pm25co,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it),'pm2_5',ges_pm2_5,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amassi',ges_amassi,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amassj',ges_amassj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amassk',ges_amassk,istatus );ier=ier+istatus
> > end subroutine gsi_bundlegetpointer_fv3lam_chemguess
> > 
> > subroutine gsi_bundlegetpointer_fv3lam_tracerchem_nouv
> >     implicit none
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aalj',ges_aalj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'acaj',ges_acaj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'acli',ges_acli,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aclj',ges_aclj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aclk',ges_aclk,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'acors',ges_acors,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aeci',ges_aeci,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aecj',ges_aecj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'afej',ges_afej,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aivpo1j',ges_aivpo1j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'akj',ges_akj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'alvoo1i',ges_alvoo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'alvoo2i',ges_alvoo2i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'alvpo1i',ges_alvpo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'alvpo1j',ges_alvpo1j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'amgj',ges_amgj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'amnj',ges_amnj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'anai',ges_anai,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'anaj',ges_anaj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'anh4i',ges_anh4i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'anh4j',ges_anh4j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'anh4k',ges_anh4k,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'ano3i',ges_ano3i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'ano3j',ges_ano3j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'ano3k',ges_ano3k,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aothri',ges_aothri,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aothrj',ges_aothrj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aseacat',ges_aseacat,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asij',ges_asij,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aso4i',ges_aso4i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aso4j',ges_aso4j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aso4k',ges_aso4k,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asoil',ges_asoil,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvoo1i',ges_asvoo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvoo2i',ges_asvoo2i,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvpo1i',ges_asvpo1i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvpo1j',ges_asvpo1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvpo2i',ges_asvpo2i,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvpo2j',ges_asvpo2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvpo3j',ges_asvpo3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'atij',ges_atij,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'atol1j',ges_atol1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'atol2j',ges_atol2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'atol3j',ges_atol3j,istatus );ier=ier+istatus
> > 
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'abnz1j',ges_abnz1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'abnz2j',ges_abnz2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'abnz3j',ges_abnz3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aiso1j',ges_aiso1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aiso2j',ges_aiso2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aiso3j',ges_aiso3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'atrp1j',ges_atrp1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'atrp2j',ges_atrp2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asqtj' ,ges_asqtj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aalk1j',ges_aalk1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aalk2j',ges_aalk2j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'apah1j',ges_apah1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'apah2j',ges_apah2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'apah3j',ges_apah3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aorgcj',ges_aorgcj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aolgbj',ges_aolgbj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'aolgaj',ges_aolgaj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'alvoo1j',ges_alvoo1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'alvoo2j',ges_alvoo2j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvoo1j',ges_asvoo1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvoo2j',ges_asvoo2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'asvoo3j',ges_asvoo3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'apcsoj',ges_apcsoj,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'axyl1j',ges_axyl1j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'axyl2j',ges_axyl2j,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'axyl3j',ges_axyl3j,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'pm25at',ges_pm25at,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'pm25ac',ges_pm25ac,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'pm25co',ges_pm25co,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'pm2_5',ges_pm2_5,istatus );ier=ier+istatus
> > 
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'amassi',ges_amassi,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'amassj',ges_amassj,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( gsibundle_fv3lam_tracerchem_nouv, 'amassk',ges_amassk,istatus );ier=ier+istatus
> > end subroutine gsi_bundlegetpointer_fv3lam_tracerchem_nouv
> > 
> > end subroutine read_fv3_netcdf_guess
> > 
> > subroutine gsi_fv3ncdf2d_read(fv3filenamegin,it,ges_z,ges_t2m,ges_q2m,ges_howv)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    gsi_fv3ncdf2d_read       
> > !   prgmmr: wu w             org: np22                date: 2017-10-17
> > !
> > ! abstract: read in 2d fields from fv3_sfcdata file in mype_2d 
> > !                Scatter the field to each PE 
> > ! program history log:
> > !   2023-02-14  Hu   -  Bug fix for read in subdomain surface restart files
> > !   2023-07-30  Zhao -  added IO to read significant wave height (howv) from 2D FV3-LAM
> > !                         firstguess file (fv3_sfcdata)
> > !
> > !   input argument list:
> > !     it    - time index for 2d fields
> > !
> > !   output argument list:
> > !     ges_z - surface elevation
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$  end documentation block
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: ierror,mpi_comm_world,npe,mpi_rtype,mype,mpi_itype
> >     use mpeu_util, only: die
> >     use guess_grids, only: fact10,soil_type,veg_frac,veg_type,sfc_rough, &
> >          sfct,sno,soil_temp,soil_moi,isli
> >     use gridmod, only: lat2,lon2,itotsub,ijn_s
> >     use general_commvars_mod, only: ltosi_s,ltosj_s
> >     use netcdf, only: nf90_open,nf90_close,nf90_get_var,nf90_noerr
> >     use netcdf, only: nf90_nowrite,nf90_inquire,nf90_inquire_dimension
> >     use netcdf, only: nf90_inquire_variable
> >     use netcdf, only: nf90_inq_varid
> >     use netcdf, only: nf90_noerr
> >     use mod_fv3_lola, only: fv3_h_to_ll,nxa,nya
> >     use constants, only: grav
> >     use constants, only: zero
> > 
> >     implicit none
> > 
> >     integer(i_kind),            intent(in) :: it   
> >     real(r_kind),               intent(in),dimension(:,:),pointer::ges_z
> >     real(r_kind),               intent(in),dimension(:,:),pointer::ges_t2m
> >     real(r_kind),               intent(in),dimension(:,:),pointer::ges_q2m
> >     real(r_kind),               intent(in),dimension(:,:),pointer::ges_howv
> >     type (type_fv3regfilenameg),intent(in) :: fv3filenamegin
> > 
> >     character(len=max_varname_length) :: name
> >     integer(i_kind),allocatable,dimension(:):: dim
> >     real(r_kind),allocatable,dimension(:):: work
> >     real(r_kind),allocatable,dimension(:,:):: a
> >     real(r_kind),allocatable,dimension(:,:,:):: sfcn2d
> >     real(r_kind),allocatable,dimension(:,:,:):: sfc
> >     real(r_kind),allocatable,dimension(:,:):: sfc1
> >     integer(i_kind) iret,gfile_loc,i,k,len,ndim
> >     integer(i_kind) ndimensions,nvariables,nattributes,unlimiteddimid
> >     integer(i_kind) kk,n,ns,j,ii,jj,mm1
> >       character(len=:),allocatable :: sfcdata   !='fv3_sfcdata'
> >       character(len=:),allocatable :: dynvars   !='fv3_dynvars'
> > ! for checking the existence of howv in firstguess file
> >     integer(i_kind) id_howv
> >     integer(i_kind) iret_bcast
> > 
> > ! for io_layout > 1
> >     real(r_kind),allocatable,dimension(:,:):: sfc_fulldomain
> >     integer(i_kind) :: nio
> >     integer(i_kind),allocatable :: gfile_loc_layout(:)
> >     character(len=180)  :: filename_layout
> > 
> > ! for sfc 2d vaiable exist or not
> >     logical, dimension(n2d) :: sfc_var_exist
> > 
> >     sfcdata= fv3filenamegin%sfcdata
> >     dynvars= fv3filenamegin%dynvars
> > 
> >     mm1=mype+1
> >     allocate(a(nya,nxa))
> >     allocate(work(itotsub*n2d))
> >     allocate( sfcn2d(lat2,lon2,n2d))
> > 
> > !-- initialisation of the array for howv
> >     sfcn2d(:,:,k_howv) = zero
> > 
> > !-- initialisation of the array for sfc_var_exist 
> >     sfc_var_exist = .false.
> > 
> >     if(mype==mype_2d ) then
> >        allocate(sfc_fulldomain(nx,ny))
> > 
> >        if(fv3_io_layout_y > 1) then
> >          allocate(gfile_loc_layout(0:fv3_io_layout_y-1))
> >          do nio=0,fv3_io_layout_y-1
> >            write(filename_layout,'(a,a,I4.4)') trim(sfcdata),'.',nio
> >            iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio))
> >            if(iret/=nf90_noerr) then
> >              write(6,*)' problem opening3 ',trim(filename_layout),', Status = ',iret
> >              return
> >            endif
> >          enddo
> >          gfile_loc=gfile_loc_layout(0)
> >        else
> >          iret=nf90_open(sfcdata,nf90_nowrite,gfile_loc)
> >          if(iret/=nf90_noerr) then
> >             write(6,*)' problem opening3 ',trim(sfcdata),', Status = ',iret
> >             return
> >          endif
> >        endif
> >        iret=nf90_inquire(gfile_loc,ndimensions,nvariables,nattributes,unlimiteddimid)
> >        allocate(dim(ndimensions))
> >        do k=1,ndimensions
> >           iret=nf90_inquire_dimension(gfile_loc,k,name,len)
> >           dim(k)=len
> >        enddo
> > 
> > !---   check the existence of significant wave height (howv) in 2D FV3-LAM firstguess file
> > !      if howv is set in anavinfo (as i_howv_3dda=1), then check its existence in firstguess,
> > !      but if it is not found in firstguess, then stop GSI run and set i_howv_3dda = 0.
> >        if ( i_howv_3dda == 1 ) then
> >          iret = nf90_inq_varid(gfile_loc,'howv',id_howv)
> >          if ( iret /= nf90_noerr ) then
> >            iret = nf90_inq_varid(gfile_loc,'HOWV',id_howv) ! double check with name in uppercase
> >          end if
> >          if ( iret /= nf90_noerr ) then
> >            i_howv_3dda = 0                ! howv does not exist in firstguess, then stop GSI run.
> >            call die('gsi_fv3ncdf2d_read','Warning: CANNOT find howv in firstguess, aborting..., iret = ', iret)
> >          else
> >            write(6,'(1x,A,1x,A,1x,A,1x,I4,1x,I4,1x,A,1x,I4.4,A)') 'gsi_fv3ncdf2d_read:: Found howv in firstguess ',  &
> >              trim(sfcdata), ', iret, varid = ',iret, id_howv,' (on pe: ', mype,').'
> >          end if
> >        end if
> > 
> >    !!!!!!!!!!!! read in 2d variables !!!!!!!!!!!!!!!!!!!!!!!!!!
> >        do i=ndimensions+1,nvariables
> >           iret=nf90_inquire_variable(gfile_loc,i,name,len)
> >           if( trim(name)=='f10m'.or.trim(name)=='F10M' ) then
> >              k=k_f10m
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='stype'.or.trim(name)=='STYPE' ) then
> >              k=k_stype
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='vfrac'.or.trim(name)=='VFRAC' ) then
> >              k=k_vfrac
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='vtype'.or.trim(name)=='VTYPE' ) then
> >              k=k_vtype
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='zorl'.or.trim(name)=='ZORL' ) then
> >              k=k_zorl
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='tsea'.or.trim(name)=='TSEA' ) then
> >              k=k_tsea
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='sheleg'.or.trim(name)=='SHELEG' ) then
> >              k=k_snwdph
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='stc'.or.trim(name)=='tslb' ) then
> >              k=k_stc 
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='smc'.or.trim(name)=='smois' ) then
> >              k=k_smc
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='SLMSK'.or.trim(name)=='slmsk' ) then
> >              k=k_slmsk
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='T2M'.or.trim(name)=='t2m' ) then
> >              k=k_t2m
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='Q2M'.or.trim(name)=='q2m' ) then
> >              k=k_q2m
> >              sfc_var_exist(k) = .true.
> >           else if( trim(name)=='HOWV'.or.trim(name)=='howv' ) then
> >              k=k_howv
> >              sfc_var_exist(k) = .true.
> >           else
> >              cycle 
> >           endif
> >           iret=nf90_inquire_variable(gfile_loc,i,ndims=ndim)
> >           if(ndim < 2) then
> >              write(*,*) "wrong dimension number ndim =",ndim
> >              call stop2(119)
> >           endif
> >           if(fv3_io_layout_y > 1) then
> >              do nio=0,fv3_io_layout_y-1
> >                 if(allocated(sfc       )) deallocate(sfc       )
> >                 allocate(sfc(nx,ny_layout_len(nio),1))
> >                 if(ndim >=3) then
> >                    iret=nf90_get_var(gfile_loc_layout(nio),i,sfc)
> >                 else if (ndim == 2) then
> >                    iret=nf90_get_var(gfile_loc_layout(nio),i,sfc(:,:,1))
> >                 endif
> >                 sfc_fulldomain(:,ny_layout_b(nio):ny_layout_e(nio))=sfc(:,:,1)
> >              enddo
> >           else
> >              if(allocated(sfc       )) deallocate(sfc       )
> >              allocate(sfc(nx,ny,1))
> >              if(ndim >=3) then 
> >                 iret=nf90_get_var(gfile_loc,i,sfc)
> >              else if (ndim == 2) then
> >                 iret=nf90_get_var(gfile_loc,i,sfc(:,:,1))
> >              endif
> >              sfc_fulldomain(:,:)=sfc(:,:,1)
> >           endif
> >           call fv3_h_to_ll(sfc_fulldomain,a,nx,ny,nxa,nya,grid_reverse_flag)
> > 
> >           kk=0
> >           do n=1,npe
> >              ns=displss2d(n)+(k-1)*ijn_s(n)
> >              do j=1,ijn_s(n)
> >                 ns=ns+1
> >                 kk=kk+1
> >                 ii=ltosi_s(kk)
> >                 jj=ltosj_s(kk)
> >                 work(ns)=a(ii,jj)
> >              end do
> >           end do
> >        enddo ! i
> >        if(fv3_io_layout_y > 1) then
> >          do nio=0,fv3_io_layout_y-1
> >            iret=nf90_close(gfile_loc_layout(nio))
> >          enddo
> >          deallocate (gfile_loc_layout)
> >        else
> >          iret=nf90_close(gfile_loc)
> >        endif
> > 
> >    !!!! read in orog from dynam !!!!!!!!!!!!
> >        if(fv3_io_layout_y > 1) then
> >          allocate(gfile_loc_layout(0:fv3_io_layout_y-1))
> >          do nio=0,fv3_io_layout_y-1
> >            write(filename_layout,'(a,a,I4.4)') trim(dynvars),'.',nio
> >            iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio))
> >            if(iret/=nf90_noerr) then
> >              write(6,*)' problem opening4 ',trim(filename_layout),', Status =',iret
> >              return
> >            endif
> >          enddo
> >          gfile_loc=gfile_loc_layout(0)
> >                   
> >        else
> >          iret=nf90_open(dynvars,nf90_nowrite,gfile_loc)
> >          if(iret/=nf90_noerr) then
> >             write(6,*)' problem opening4 ',trim(dynvars ),gfile_loc,', Status = ',iret
> >             return
> >          endif
> >        endif
> > 
> >        iret=nf90_inquire(gfile_loc,ndimensions,nvariables,nattributes,unlimiteddimid)
> >        if(allocated(dim    )) deallocate(dim    )
> >        allocate(dim(ndimensions))
> > 
> >        do k=1,ndimensions
> >           iret=nf90_inquire_dimension(gfile_loc,k,name,len)
> >           dim(k)=len
> >        enddo
> > 
> > 
> >        do k=ndimensions+1,nvariables
> >           iret=nf90_inquire_variable(gfile_loc,k,name,len)
> >           if(trim(name)=='PHIS'   .or. trim(name)=='phis'  ) then
> >              sfc_var_exist(k_orog) = .true.
> >              iret=nf90_inquire_variable(gfile_loc,k,ndims=ndim)
> >              if(fv3_io_layout_y > 1) then
> >                 do nio=0,fv3_io_layout_y-1
> >                   if(allocated(sfc1       )) deallocate(sfc1       )
> >                   allocate(sfc1(nx,ny_layout_len(nio)) )
> >                   iret=nf90_get_var(gfile_loc_layout(nio),k,sfc1)
> >                   sfc_fulldomain(:,ny_layout_b(nio):ny_layout_e(nio))=sfc1
> >                 enddo
> >              else
> >                 if(allocated(sfc1       )) deallocate(sfc1       )
> >                 allocate(sfc1(nx,ny) )
> >                 iret=nf90_get_var(gfile_loc,k,sfc1)
> >                 sfc_fulldomain=sfc1
> >              endif
> >              exit
> >           endif
> >        enddo     !   k
> >        if(fv3_io_layout_y > 1) then
> >          do nio=0,fv3_io_layout_y-1
> >            iret=nf90_close(gfile_loc_layout(nio))
> >          enddo
> >          deallocate(gfile_loc_layout)
> >        else
> >          iret=nf90_close(gfile_loc)
> >        endif
> > 
> >        k=k_orog
> >        call fv3_h_to_ll(sfc_fulldomain,a,nx,ny,nxa,nya,grid_reverse_flag)
> > 
> >        kk=0
> >        do n=1,npe
> >           ns=displss2d(n)+(k-1)*ijn_s(n)
> >           do j=1,ijn_s(n)
> >              ns=ns+1
> >              kk=kk+1
> >              ii=ltosi_s(kk)
> >              jj=ltosj_s(kk)
> >              work(ns)=a(ii,jj)
> >           end do
> >        end do
> > 
> >        if(allocated(sfc1) .and. allocated(sfc)) deallocate (sfc,sfc1)
> >        if(allocated(dim)) deallocate (dim)
> >        if(allocated(sfc_fulldomain)) deallocate (sfc_fulldomain)
> >     endif  ! mype
> > 
> > !-- broadcast the updated i_howv_3dda to all tasks (!!!!)
> >     call mpi_bcast(i_howv_3dda, 1, mpi_itype, mype_2d, mpi_comm_world, iret_bcast)
> > 
> > !-- broadcast the updated sfc_var_exist to all tasks (!!!!)
> >     call mpi_bcast(sfc_var_exist, n2d, mpi_itype, mype_2d, mpi_comm_world, iret_bcast)
> > 
> > !!!!!!! scatter !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
> >     call mpi_scatterv(work,ijns2d,displss2d,mpi_rtype,&
> >       sfcn2d,ijns2d(mm1),mpi_rtype,mype_2d,mpi_comm_world,ierror)
> > 
> >     deallocate ( work )
> > 
> >     if ( sfc_var_exist(k_f10m)  ) fact10(:,:,it)=sfcn2d(:,:,k_f10m)
> >     if ( sfc_var_exist(k_stype) ) soil_type(:,:,it)=sfcn2d(:,:,k_stype)
> >     if ( sfc_var_exist(k_vfrac) ) veg_frac(:,:,it)=sfcn2d(:,:,k_vfrac)
> >     if ( sfc_var_exist(k_vtype) ) veg_type(:,:,it)=sfcn2d(:,:,k_vtype)
> >     if ( sfc_var_exist(k_zorl)  ) sfc_rough(:,:,it)=sfcn2d(:,:,k_zorl)
> >     if ( sfc_var_exist(k_tsea)  ) sfct(:,:,it)=sfcn2d(:,:,k_tsea)
> >     if ( sfc_var_exist(k_snwdph)) sno(:,:,it)=sfcn2d(:,:,k_snwdph)
> >     if ( sfc_var_exist(k_stc)   ) soil_temp(:,:,it)=sfcn2d(:,:,k_stc)
> >     if ( sfc_var_exist(k_smc)   ) soil_moi(:,:,it)=sfcn2d(:,:,k_smc)
> >     if ( sfc_var_exist(k_orog)  ) ges_z(:,:)=sfcn2d(:,:,k_orog)/grav
> >     if ( sfc_var_exist(k_slmsk) ) isli(:,:,it)=nint(sfcn2d(:,:,k_slmsk))
> >     if(i_use_2mq4b > 0 .and. i_use_2mt4b > 0 ) then
> >        if ( sfc_var_exist(k_t2m) ) ges_t2m(:,:)=sfcn2d(:,:,k_t2m)
> >        if ( sfc_var_exist(k_q2m)   ) ges_q2m(:,:)=sfcn2d(:,:,k_q2m)
> >     endif
> >     if ( i_howv_3dda == 1 ) then
> >        if ( sfc_var_exist(k_howv)  ) ges_howv(:,:)=sfcn2d(:,:,k_howv)
> >     endif
> >     deallocate (sfcn2d,a)
> >     return
> > end subroutine gsi_fv3ncdf2d_read
> 700,701c2346,2347
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: ierror,gsi_mpi_comm_world,npe,mpi_rtype,mype
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: ierror,mpi_comm_world,npe,mpi_rtype,mype
> 767c2413
> <        work_sub,ijn_s(mm1),mpi_rtype,mype_io,gsi_mpi_comm_world,ierror)
> ---
> >        work_sub,ijn_s(mm1),mpi_rtype,mype_io,mpi_comm_world,ierror)
> 799,801c2445,2447
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: gsi_mpi_comm_world,mpi_rtype,mype,npe,setcomm,mpi_integer,mpi_max
> <     use m_mpimod, only:  MPI_INFO_NULL
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: mpi_comm_world,mpi_rtype,mype,npe,setcomm,mpi_integer,mpi_max
> >     use mpimod, only:  MPI_INFO_NULL
> 863c2509
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 985c2631
> <     call mpi_barrier(gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_barrier(mpi_comm_world,ierror)
> 1021,1023c2667,2669
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only:  npe,mpi_rtype,gsi_mpi_comm_world,mype,MPI_INFO_NULL
> <     use m_mpimod, only: gsi_mpi_comm_world,mpi_rtype,mype,setcomm,mpi_integer,mpi_max
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only:  npe,mpi_rtype,mpi_comm_world,mype,MPI_INFO_NULL
> >     use mpimod, only: mpi_comm_world,mpi_rtype,mype,setcomm,mpi_integer,mpi_max
> 1080c2726
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 1160,1161c2806,2807
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: gsi_mpi_comm_world,mpi_rtype,mype,mpi_info_null,npe,setcomm,mpi_integer,mpi_max
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: mpi_comm_world,mpi_rtype,mype,mpi_info_null,npe,setcomm,mpi_integer,mpi_max
> 1230c2876
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 1362c3008
> <     call mpi_barrier(gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_barrier(mpi_comm_world,ierror)
> 1393,1394c3039,3040
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: setcomm,mpi_integer,mpi_max, npe,gsi_mpi_comm_world,mpi_rtype,mype,mpi_info_null
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: setcomm,mpi_integer,mpi_max, npe,mpi_comm_world,mpi_rtype,mype,mpi_info_null
> 1454c3100
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 1557,1559c3203,3205
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: gsi_mpi_comm_world,mpi_rtype,mype
> <     use m_mpimod, only:  MPI_INFO_NULL
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: mpi_comm_world,mpi_rtype,mype
> >     use mpimod, only:  MPI_INFO_NULL
> 1636c3282
> <              iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio),comm=gsi_mpi_comm_world,info=MPI_INFO_NULL)
> ---
> >              iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio),comm=mpi_comm_world,info=MPI_INFO_NULL)
> 1784,1785c3430,3431
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: gsi_mpi_comm_world,mpi_rtype,mype,mpi_info_null
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: mpi_comm_world,mpi_rtype,mype,mpi_info_null
> 1838c3484
> <             iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio),comm=gsi_mpi_comm_world,info=MPI_INFO_NULL)
> ---
> >             iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio),comm=mpi_comm_world,info=MPI_INFO_NULL)
> 1926a3573,3976
> > subroutine wrfv3_netcdf(fv3filenamegin)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    wrfv3_netcdf           write out FV3 analysis increments
> > !   prgmmr: wu               org: np22                date: 2017-10-23
> > !
> > ! abstract:  write FV3 analysis  in netcdf format
> > !
> > ! program history log:
> > !   2019-04-18  CAPS(C. Tong) - import direct reflectivity DA capabilities
> > !   2019-11-22  CAPS(C. Tong) - modify "add_saved" to properly output analyses
> > !   2021-01-05  x.zhang/lei  - add code for updating delz analysis in regional da
> > !   2022-04-01  Y. Wang and X. Wang - add code for updating reflectivity
> > !   2023-07-30  Zhao         - added code for the output of the analysis of
> > !                                significant wave height (howv)
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$
> >     use kinds, only: r_kind,i_kind
> >     use guess_grids, only: ntguessig,ges_tsen
> >     use gsi_metguess_mod, only: gsi_metguess_bundle
> >     use gsi_chemguess_mod, only: gsi_chemguess_bundle
> >     use gsi_bundlemod, only: gsi_bundlegetpointer,gsi_bundleputvar
> >     use mpeu_util, only: die
> >     use gridmod, only: lat2,lon2,nsig
> > 
> >     use gridmod,only: l_reg_update_hydro_delz
> >     use guess_grids, only:geom_hgti,geom_hgti_bg
> > 
> >     use directDA_radaruse_mod, only: l_use_cvpqx, cvpqx_pval, cld_nt_updt
> >     use directDA_radaruse_mod, only: l_use_dbz_directDA
> >     use directDA_radaruse_mod, only: l_cvpnr, cvpnr_pval
> >     use gridmod,  only: eta1_ll,eta2_ll
> >     use constants, only: one
> >     use obsmod, only: if_model_dbz,if_model_fed
> > 
> > 
> >     implicit none
> >     type (type_fv3regfilenameg),intent(in) :: fv3filenamegin
> > 
> > ! Declare local constants
> >     logical add_saved
> >  ! variables for cloud info
> >     integer(i_kind) ier,istatus,it
> >     real(r_kind),pointer,dimension(:,:  ):: ges_ps  =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_u   =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_v   =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_q   =>NULL()
> >     real(r_kind),pointer,dimension(:,:  ):: ges_t2m =>NULL()
> >     real(r_kind),pointer,dimension(:,:  ):: ges_q2m  =>NULL()
> >     real(r_kind),pointer,dimension(:,:  ):: ges_howv =>NULL()
> >    
> >     integer(i_kind) i,k
> > 
> >     real(r_kind),pointer,dimension(:,:,:):: ges_ql  =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_qi  =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_qr  =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_qs  =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_qg  =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_qnr =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_w   =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_dbz   =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_fed   =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_delzinc   =>NULL()
> >     real(r_kind),pointer,dimension(:,:,:):: ges_delp  =>NULL()
> >     real(r_kind),dimension(:,:  ),allocatable:: ges_ps_write
> > 
> > 
> >     real(r_kind), dimension(lat2,lon2,nsig) :: io_arr_qr, io_arr_qs
> >     real(r_kind), dimension(lat2,lon2,nsig) :: io_arr_qg, io_arr_qnr
> >     real(r_kind), dimension(:,:,:),allocatable ::g_prsi 
> > 
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_aalj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_acaj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_acli=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aclj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aclk=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_acors=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aeci=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aecj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_afej=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aivpo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_akj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo2i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvpo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvpo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_amgj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_amnj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anai=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anaj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anh4i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anh4j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_anh4k=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_ano3i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_ano3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_ano3k=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aothri=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aothrj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aseacat=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asij=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aso4i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aso4j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aso4k=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asoil=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo2i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo1i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo2i=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvpo3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atij=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atol1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atol2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atol3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_abnz1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_abnz2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_abnz3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aiso1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aiso2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aiso3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atrp1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_atrp2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asqtj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aalk1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aalk2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apah1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apah2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apah3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aorgcj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aolgbj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_aolgaj=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_alvoo2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_asvoo3j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_apcsoj=>NULL()
> > 
> >     real(r_kind),dimension(:,:,:),pointer::ges_axyl1j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_axyl2j=>NULL()
> >     real(r_kind),dimension(:,:,:),pointer::ges_axyl3j=>NULL()
> > 
> > 
> >     it=ntguessig
> >     ier=0
> >     call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'ps' ,ges_ps ,istatus );ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'u' , ges_u ,istatus);ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'v' , ges_v ,istatus);ier=ier+istatus
> >     call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'q'  ,ges_q ,istatus);ier=ier+istatus
> >     if (l_use_dbz_directDA .or. if_model_dbz .or.if_model_fed) then
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'ql' ,ges_ql ,istatus);ier=ier+istatus
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qi' ,ges_qi ,istatus);ier=ier+istatus
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qr' ,ges_qr ,istatus);ier=ier+istatus
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qs' ,ges_qs ,istatus);ier=ier+istatus
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qg' ,ges_qg ,istatus);ier=ier+istatus
> >        if (l_use_dbz_directDA) &
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'qnr',ges_qnr,istatus);ier=ier+istatus
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'w' , ges_w ,istatus);ier=ier+istatus
> >        if( if_model_dbz )&
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'dbz' , ges_dbz ,istatus);ier=ier+istatus
> >        if( if_model_fed )&
> >        call GSI_BundleGetPointer ( GSI_MetGuess_Bundle(it), 'fed' , ges_fed ,istatus);ier=ier+istatus
> >     end if
> >     if(i_use_2mq4b > 0 .and. i_use_2mt4b > 0 ) then
> >        call GSI_BundleGetPointer (GSI_MetGuess_Bundle(it),'q2m',ges_q2m,istatus); ier=ier+istatus
> >        call GSI_BundleGetPointer (GSI_MetGuess_Bundle(it),'t2m',ges_t2m,istatus );ier=ier+istatus
> >     endif
> >     if ( i_howv_3dda == 1 ) then
> >        call GSI_BundleGetPointer (GSI_MetGuess_Bundle(it),'howv',ges_howv,istatus); ier=ier+istatus
> >     endif
> >     if (ier/=0) call die('wrfv3_netcdf','cannot get pointers for fv3 met-fields, ier =',ier)
> > 
> >     if (laeroana_fv3cmaq) then
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aalj',ges_aalj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'acaj',ges_acaj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'acli',ges_acli,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aclj',ges_aclj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aclk',ges_aclk,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'acors',ges_acors,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aeci',ges_aeci,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aecj',ges_aecj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'afej',ges_afej,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aivpo1j',ges_aivpo1j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'akj',ges_akj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo1i',ges_alvoo1i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo2i',ges_alvoo2i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvpo1i',ges_alvpo1i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvpo1j',ges_alvpo1j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amgj',ges_amgj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'amnj',ges_amnj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anai',ges_anai,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anaj',ges_anaj,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anh4i',ges_anh4i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anh4j',ges_anh4j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'anh4k',ges_anh4k,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'ano3i',ges_ano3i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'ano3j',ges_ano3j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'ano3k',ges_ano3k,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aothri',ges_aothri,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aothrj',ges_aothrj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aseacat',ges_aseacat,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asij',ges_asij,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aso4i',ges_aso4i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aso4j',ges_aso4j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aso4k',ges_aso4k,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asoil',ges_asoil,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo1i',ges_asvoo1i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo2i',ges_asvoo2i,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo1i',ges_asvpo1i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo1j',ges_asvpo1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo2i',ges_asvpo2i,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo2j',ges_asvpo2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvpo3j',ges_asvpo3j,istatus );ier=ier+istatus
> > 
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atij',ges_atij,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atol1j',ges_atol1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atol2j',ges_atol2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atol3j',ges_atol3j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'abnz1j',ges_abnz1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'abnz2j',ges_abnz2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'abnz3j',ges_abnz3j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aiso1j',ges_aiso1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aiso2j',ges_aiso2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aiso3j',ges_aiso3j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atrp1j',ges_atrp1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'atrp2j',ges_atrp2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asqtj' ,ges_asqtj,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aalk1j',ges_aalk1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aalk2j',ges_aalk2j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apah1j',ges_apah1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apah2j',ges_apah2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apah3j',ges_apah3j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aorgcj',ges_aorgcj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aolgbj',ges_aolgbj,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'aolgaj',ges_aolgaj,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo1j',ges_alvoo1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'alvoo2j',ges_alvoo2j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo1j',ges_asvoo1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo2j',ges_asvoo2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'asvoo3j',ges_asvoo3j,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'apcsoj',ges_apcsoj,istatus );ier=ier+istatus
> > 
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'axyl1j',ges_axyl1j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'axyl2j',ges_axyl2j,istatus );ier=ier+istatus
> >       call GSI_BundleGetPointer ( GSI_ChemGuess_Bundle(it), 'axyl3j',ges_axyl3j,istatus );ier=ier+istatus
> >     end if
> > 
> >     if(l_reg_update_hydro_delz) then
> >       allocate(ges_delzinc(lat2,lon2,nsig))
> >       do k=1,nsig
> >         ges_delzinc(:,:,k)=geom_hgti(:,:,k+1,it)-geom_hgti_bg(:,:,k+1,it)-geom_hgti(:,:,k,it)+geom_hgti_bg(:,:,k,it)
> >       enddo
> >       call gsi_bundleputvar (gsibundle_fv3lam_dynvar_nouv,'delzinc',ges_delzinc,istatus)
> >     endif
> > ! additional I/O for direct reflectivity DA capabilities
> >     if (l_use_dbz_directDA) then
> >       if( fv3sar_bg_opt == 0) then
> >         write(6,*) "FV3 IO Write for 'fv3sar_bg_opt == 0 is only available for now in direct relfectivity DA"
> >       endif
> >  
> >       io_arr_qr=ges_qr
> >       io_arr_qs=ges_qs
> >       io_arr_qg=ges_qg
> >       io_arr_qnr=ges_qnr
> > 
> >       call convert_cvpqx_to_qx(io_arr_qr, io_arr_qs, io_arr_qg, l_use_cvpqx, cvpqx_pval)  ! Convert Qx back
> >       call convert_cvpnx_to_nx(io_arr_qnr, l_cvpnr, cvpnr_pval, cld_nt_updt, ges_q, io_arr_qr, ges_ps) ! Convert Nx back 
> >       ges_qr=io_arr_qr
> >       ges_qs=io_arr_qs
> >       ges_qg=io_arr_qg
> >       ges_qnr=io_arr_qnr
> >     endif
> > 
> >     call gsi_copy_bundle(GSI_MetGuess_Bundle(it),gsibundle_fv3lam_dynvar_nouv) 
> >     call gsi_copy_bundle(GSI_MetGuess_Bundle(it),gsibundle_fv3lam_tracer_nouv) 
> >     if( if_model_dbz .or. if_model_fed )  call gsi_copy_bundle(GSI_MetGuess_Bundle(it),gsibundle_fv3lam_phyvar_nouv)
> >     if (laeroana_fv3cmaq) then
> >       call gsi_copy_bundle(GSI_ChemGuess_Bundle(it),gsibundle_fv3lam_tracerchem_nouv)
> >     end if
> >     if (laeroana_fv3smoke) then
> >       call gsi_copy_bundle(GSI_ChemGuess_Bundle(it),gsibundle_fv3lam_tracersmoke_nouv)
> >     end if
> > 
> >     call gsi_bundleputvar (gsibundle_fv3lam_dynvar_nouv,'tsen',ges_tsen(:,:,:,it),istatus)
> > 
> >     if( fv3sar_bg_opt == 0) then
> >       call GSI_BundleGetPointer ( gsibundle_fv3lam_dynvar_nouv, 'delp'  ,ges_delp ,istatus );ier=ier+istatus
> >       allocate(g_prsi(lat2,lon2,nsig+1))
> >       allocate(ges_ps_inc(lat2,lon2))
> >       ges_ps_inc=ges_ps-ges_ps_bg 
> >       g_prsi(:,:,nsig+1)=eta1_ll(nsig+1)
> >       do i=nsig,1,-1
> >         g_prsi(:,:,i)=ges_delp_bg(:,:,i)+g_prsi(:,:,i+1) 
> >       enddo
> >       do i=1,nsig+1
> >         g_prsi(:,:,i)=g_prsi(:,:,i)+eta2_ll(i)*ges_ps_inc
> >       enddo
> >       do i=1,nsig
> >         ges_delp(:,:,i)=g_prsi(:,:,i)-g_prsi(:,:,i+1)
> >       enddo
> >       ges_delp=ges_delp*1000.0_r_kind
> >       deallocate(g_prsi,ges_ps_inc)
> >     
> >     else
> >       allocate(ges_ps_write(lat2,lon2))
> >       ges_ps_write=ges_ps*1000.0_r_kind
> >       call gsi_bundleputvar (gsibundle_fv3lam_dynvar_nouv,'ps',ges_ps_write,istatus)
> >       deallocate(ges_ps_write)
> >     endif
> > !   write out
> >     if (ier/=0) call die('get ges','cannot get pointers for fv3 met-fields, ier =',ier)
> > 
> >     if(i_use_2mq4b > 0 .and. i_use_2mt4b > 0 ) then
> > ! Convert 2m guess specific humidity to mixing ratio
> >       ges_q2m = ges_q2m/(one-ges_q2m)
> >     endif
> > 
> >     add_saved=.true.
> > !   write out
> >     if(fv3sar_bg_opt == 0) then
> >       call gsi_fv3ncdf_write(grd_fv3lam_dynvar_ionouv,gsibundle_fv3lam_dynvar_nouv,&
> >                              add_saved,fv3filenamegin%dynvars,fv3filenamegin)
> >       call gsi_fv3ncdf_write(grd_fv3lam_tracer_ionouv,gsibundle_fv3lam_tracer_nouv, &
> >                              add_saved,fv3filenamegin%tracers,fv3filenamegin)
> >       if( if_model_dbz .or. if_model_fed ) then
> >          call gsi_fv3ncdf_write(grd_fv3lam_phyvar_ionouv,gsibundle_fv3lam_phyvar_nouv,&
> >                                 add_saved,fv3filenamegin%phyvars,fv3filenamegin)
> >       end if
> > 
> >       call gsi_fv3ncdf_writeuv(grd_fv3lam_uv,ges_u,ges_v,add_saved,fv3filenamegin)
> >       if (laeroana_fv3cmaq) then
> >         call gsi_fv3ncdf_write(grd_fv3lam_tracerchem_ionouv,gsibundle_fv3lam_tracerchem_nouv, &
> >                              add_saved,fv3filenamegin%tracers,fv3filenamegin)
> >       endif
> >       if (laeroana_fv3smoke) then
> >         call gsi_fv3ncdf_write(grd_fv3lam_tracersmoke_ionouv,gsibundle_fv3lam_tracersmoke_nouv,&
> >                              add_saved,fv3filenamegin%tracers,fv3filenamegin)
> >       endif
> > 
> >     else
> >       call gsi_fv3ncdf_write_v1(grd_fv3lam_dynvar_ionouv,gsibundle_fv3lam_dynvar_nouv,& 
> >                                 add_saved,fv3filenamegin%dynvars,fv3filenamegin)
> >       call gsi_fv3ncdf_write_v1(grd_fv3lam_tracer_ionouv,gsibundle_fv3lam_tracer_nouv,&
> >                                 add_saved,fv3filenamegin%tracers,fv3filenamegin)
> >       call gsi_fv3ncdf_writeuv_v1(grd_fv3lam_uv,ges_u,ges_v,add_saved,fv3filenamegin)
> >       if (laeroana_fv3cmaq) then
> >         call gsi_fv3ncdf_write_v1(grd_fv3lam_tracerchem_ionouv,gsibundle_fv3lam_tracerchem_nouv,&
> >                                 add_saved,fv3filenamegin%tracers,fv3filenamegin)
> >       endif
> >       if (laeroana_fv3smoke) then
> >         call gsi_fv3ncdf_write_v1(grd_fv3lam_tracersmoke_ionouv,gsibundle_fv3lam_tracersmoke_nouv,&
> >                                 add_saved,fv3filenamegin%tracers,fv3filenamegin)
> >       endif
> > 
> >     endif
> > 
> >     if(i_use_2mq4b > 0 .and. i_use_2mt4b > 0 ) then
> >       call gsi_fv3ncdf_write_sfc(fv3filenamegin,'t2m',ges_t2m,add_saved)
> >       call gsi_fv3ncdf_write_sfc(fv3filenamegin,'q2m',ges_q2m,add_saved)
> >     endif
> > !-- output analysis of howv
> >     if ( i_howv_3dda == 1 ) then
> >       call gsi_fv3ncdf_write_sfc(fv3filenamegin,'howv',ges_howv,add_saved)
> >     endif
> > 
> >     if(allocated(g_prsi)) deallocate(g_prsi)
> > 
> >     deallocate(ny_layout_len)
> >     deallocate(ny_layout_b)
> >     deallocate(ny_layout_e)
> > ! additional I/O for direct reflectivity DA capabilities
> >     
> > end subroutine wrfv3_netcdf
> > 
> 1952c4002
> <     use m_mpimod, only:  mpi_rtype,gsi_mpi_comm_world,mype,mpi_info_null,npe,setcomm,mpi_integer,mpi_max
> ---
> >     use mpimod, only:  mpi_rtype,mpi_comm_world,mype,mpi_info_null,npe,setcomm,mpi_integer,mpi_max
> 2029c4079
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 2164c4214
> <     call mpi_barrier(gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_barrier(mpi_comm_world,ierror)
> 2198c4248
> <     use m_mpimod, only:  npe, setcomm,mpi_integer,mpi_max,mpi_rtype,gsi_mpi_comm_world,mype,mpi_info_null
> ---
> >     use mpimod, only:  npe, setcomm,mpi_integer,mpi_max,mpi_rtype,mpi_comm_world,mype,mpi_info_null
> 2278c4328
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 2450c4500
> <     use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,mype
> ---
> >     use mpimod, only: ierror,mpi_comm_world,mpi_rtype,mype
> 2487c4537
> <           work,ijn,displs_g,mpi_rtype,0,gsi_mpi_comm_world,ierror)
> ---
> >           work,ijn,displs_g,mpi_rtype,0,mpi_comm_world,ierror)
> 2585c4635
> <     use m_mpimod, only: mpi_rtype,gsi_mpi_comm_world,mype,mpi_info_null,npe,setcomm,mpi_integer,mpi_max
> ---
> >     use mpimod, only: mpi_rtype,mpi_comm_world,mype,mpi_info_null,npe,setcomm,mpi_integer,mpi_max
> 2651c4701
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 2803c4853
> <     call mpi_barrier(gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_barrier(mpi_comm_world,ierror)
> 2810c4860
> <     use m_kinds, only: i_kind
> ---
> >     use kinds, only: i_kind
> 2843c4893
> <     use m_mpimod, only: npe, setcomm,mpi_integer,mpi_max,mpi_rtype,gsi_mpi_comm_world,mype,mpi_info_null
> ---
> >     use mpimod, only: npe, setcomm,mpi_integer,mpi_max,mpi_rtype,mpi_comm_world,mype,mpi_info_null
> 2900c4950
> <     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(members,members_read,npe,mpi_integer,mpi_max,mpi_comm_world,ierror)
> 2971c5021
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 2995c5045
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 3045c5095
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 3048c5098
> <     use m_mpimod, only: mype
> ---
> >     use mpimod, only: mype
> 3166c5216
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 3168c5218
> <     use m_mpimod, only: mype
> ---
> >     use mpimod, only: mype
> 3228c5278
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 3231c5281
> <     use m_mpimod, only: mype
> ---
> >     use mpimod, only: mype
> 3405c5455
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 3407c5457
> <     use m_mpimod, only: mype
> ---
> >     use mpimod, only: mype
> 3576,3847d5625
> < subroutine m_gsi_rfv3io_get_grid_specs(gsi_lats,gsi_lons,ierr)
> < !$$$  subprogram documentation block
> < !                .      .    .                                        .
> < ! subprogram:    gsi_rfv3io_get_grid_specs
> < !   pgrmmr: parrish     org: np22                date: 2017-04-03
> < !
> < ! abstract:  obtain grid dimensions nx,ny and grid definitions
> < !                grid_x,grid_xt,grid_y,grid_yt,grid_lon,grid_lont,grid_lat,grid_latt
> < !                nz,ak(nz),bk(nz)
> < !
> < ! program history log:
> < !   2017-04-03  parrish - initial documentation
> < !   2017-10-10  wu - setup A grid and interpolation coeff with generate_anl_grid
> < !   2018-02-16  wu - read in time info from file coupler.res
> < !                    read in lat, lon at the center and corner of the grid cell
> < !                    from file fv3_grid_spec, and vertical grid infor from file fv3_akbk
> < !                    setup A grid and interpolation/rotation coeff
> < !   input argument list:
> < !    grid_spec
> < !    ak_bk
> < !    lendian_out
> < !
> < !   output argument list:
> < !    ierr
> < !
> < ! attributes:
> < !   language: f90
> < !   machine:
> < !
> < !$$$ end documentation block
> < 
> <   use netcdf, only: nf90_open,nf90_close,nf90_get_var,nf90_noerr
> <   use netcdf, only: nf90_nowrite,nf90_inquire,nf90_inquire_dimension
> <   use netcdf, only: nf90_inquire_variable
> <   use m_mpimod, only: mype
> <   use mod_fv3_lola, only: m_generate_anl_grid
> <   use gridmod,  only:nsig,regional_time,regional_fhr,regional_fmin,aeta1_ll,aeta2_ll
> <   use gridmod,  only:nlon_regional,nlat_regional,eta1_ll,eta2_ll
> <   use gridmod,  only:grid_type_fv3_regional
> <   use m_kinds, only: i_kind,r_kind
> <   use constants, only: half,zero
> <   use m_mpimod, only: gsi_mpi_comm_world,mpi_itype,mpi_rtype
> < 
> <   implicit none
> <   integer(i_kind),intent(  out) :: ierr
> <   real(r_kind),intent(inout) :: gsi_lats(:,:),gsi_lons(:,:)
> < 
> <   integer(i_kind) gfile_grid_spec
> <   character(:),allocatable    :: grid_spec
> <   character(:),allocatable    :: ak_bk
> <   character(len=:),allocatable :: coupler_res_filenam 
> <   integer(i_kind) i,k,ndimensions,iret,nvariables,nattributes,unlimiteddimid
> <   integer(i_kind) len,gfile_loc
> <   character(len=max_varname_length) :: name
> <   integer(i_kind) myear,mmonth,mday,mhour,mminute,msecond
> <   real(r_kind),allocatable:: abk_fv3(:)
> <   integer(i_kind) imiddle,jmiddle
> < ! if fv3_io_layout_y > 1
> <   integer(i_kind) :: nio,nylen
> <   integer(i_kind),allocatable :: gfile_loc_layout(:)
> <   character(len=180)  :: filename_layout
> < 
> <     !coupler_res_filenam='/home/masanori/da/RDASApp_gsib/jedi-assim_test_gsib/rrfs-data_fv3jedi_2022052619/Data/gsibec/coupler.res'
> <     !grid_spec='/home/masanori/da/RDASApp_gsib/jedi-assim_test_gsib/rrfs-data_fv3jedi_2022052619/Data/gsibec/fv3_grid_spec'
> <     !ak_bk='/home/masanori/da/RDASApp_gsib/jedi-assim_test_gsib/rrfs-data_fv3jedi_2022052619/Data/gsibec/fv3_akbk'
> < 
> <     coupler_res_filenam='coupler.res'
> <     grid_spec='fv3_grid_spec'
> <     ak_bk='fv3_akbk'
> < 
> < !!!!! set regional_time
> <     open(24,file=trim(coupler_res_filenam),form='formatted')
> <     read(24,*)
> <     read(24,*)
> <     read(24,*)myear,mmonth,mday,mhour,mminute,msecond
> <     close(24)
> <   !  if(mype==0)  write(6,*)' myear,mmonth,mday,mhour,mminute,msecond=', myear,mmonth,mday,mhour,mminute,msecond
> <     regional_time(1)=myear
> <     regional_time(2)=mmonth
> <     regional_time(3)=mday
> <     regional_time(4)=mhour
> <     regional_time(5)=mminute
> <     regional_time(6)=msecond
> <     regional_fhr=zero          ! forecast hour set zero for now
> <     regional_fmin=zero          ! forecast min set zero for now
> < 
> < !!!!!!!!!!    grid_spec  !!!!!!!!!!!!!!!
> <     ierr=0
> <     iret=nf90_open(trim(grid_spec),nf90_nowrite,gfile_grid_spec)
> <     if(iret/=nf90_noerr) then
> <        write(6,*)' gsi_rfv3io_get_grid_specs: problem opening ',trim(grid_spec),', Status = ',iret
> <        ierr=1
> <        return
> <     endif
> < 
> <     iret=nf90_inquire(gfile_grid_spec,ndimensions,nvariables,nattributes,unlimiteddimid)
> <     gfile_loc=gfile_grid_spec
> <     do k=1,ndimensions
> <        iret=nf90_inquire_dimension(gfile_loc,k,name,len)
> <        if(trim(name)=='grid_xt') nx=len
> <        if(trim(name)=='grid_yt') ny=len
> <     enddo
> <     nlon_regional=nx
> <     nlat_regional=ny
> < 
> <     if(.not.allocated(ny_layout_len)) allocate(ny_layout_len(0:fv3_io_layout_y-1))
> <     if(.not.allocated(ny_layout_b)) allocate(ny_layout_b(0:fv3_io_layout_y-1))
> <     if(.not.allocated(ny_layout_e)) allocate(ny_layout_e(0:fv3_io_layout_y-1))
> <     ny_layout_len=ny
> <     ny_layout_b=0
> <     ny_layout_e=0
> <     if(fv3_io_layout_y > 1) then
> <        if(.not.allocated(gfile_loc_layout)) allocate(gfile_loc_layout(0:fv3_io_layout_y-1))
> <        do nio=0,fv3_io_layout_y-1
> <           write(filename_layout,'(a,a,I4.4)') trim(grid_spec),'.',nio
> <           iret=nf90_open(filename_layout,nf90_nowrite,gfile_loc_layout(nio))
> <           if(iret/=nf90_noerr) then
> <              write(6,*)' problem opening ',trim(filename_layout),', Status =',iret
> <              ierr=1
> <              return
> <           endif
> <           iret=nf90_inquire(gfile_loc_layout(nio),ndimensions,nvariables,nattributes,unlimiteddimid)
> <           do k=1,ndimensions
> <               iret=nf90_inquire_dimension(gfile_loc_layout(nio),k,name,len)
> <               if(trim(name)=='grid_yt') ny_layout_len(nio)=len
> <           enddo
> <           iret=nf90_close(gfile_loc_layout(nio))
> <        enddo
> <        deallocate(gfile_loc_layout)
> < ! figure out begin and end of each subdomain restart file
> <        nylen=0
> <        do nio=0,fv3_io_layout_y-1
> <           ny_layout_b(nio)=nylen + 1
> <           nylen=nylen+ny_layout_len(nio)
> <           ny_layout_e(nio)=nylen
> <        enddo
> <     endif
> <    ! if(mype==0)write(6,*),'nx,ny=',nx,ny
> <    ! if(mype==0)write(6,*),'ny_layout_len=',ny_layout_len
> <    ! if(mype==0)write(6,*),'ny_layout_b=',ny_layout_b
> <    ! if(mype==0)write(6,*),'ny_layout_e=',ny_layout_e
> < 
> < !!!    get nx,ny,grid_lon,grid_lont,grid_lat,grid_latt,nz,ak,bk
> < 
> <     if(.not.allocated(grid_lat)) allocate(grid_lat(nx+1,ny+1))
> <     if(.not.allocated(grid_lon)) allocate(grid_lon(nx+1,ny+1))
> <     if(.not.allocated(grid_latt)) allocate(grid_latt(nx,ny))
> <     if(.not.allocated(grid_lont)) allocate(grid_lont(nx,ny))
> < 
> <     do k=ndimensions+1,nvariables
> <        iret=nf90_inquire_variable(gfile_loc,k,name,len)
> <        if(trim(name)=='grid_lat') then
> <           iret=nf90_get_var(gfile_loc,k,grid_lat)
> <        endif
> <        if(trim(name)=='grid_lon') then
> <           iret=nf90_get_var(gfile_loc,k,grid_lon)
> <        endif
> <        if(trim(name)=='grid_latt') then
> <           iret=nf90_get_var(gfile_loc,k,grid_latt)
> <        endif
> <        if(trim(name)=='grid_lont') then
> <           iret=nf90_get_var(gfile_loc,k,grid_lont)
> <        endif
> <     enddo
> < !
> < !  need to decide the grid orientation of the FV regional model    
> < !
> < !   grid_type_fv3_regional = 0 : decide grid orientation based on
> < !                                grid_lat/grid_lon
> < !                            1 : input is E-W N-S grid
> < !                            2 : input is W-E S-N grid
> < !
> <     if(grid_type_fv3_regional == 0) then
> <         imiddle=nx/2
> <         jmiddle=ny/2
> <         if( (grid_latt(imiddle,1) < grid_latt(imiddle,ny)) .and. &
> <             (grid_lont(1,jmiddle) < grid_lont(nx,jmiddle)) ) then 
> <             grid_type_fv3_regional = 2
> <         else
> <             grid_type_fv3_regional = 1
> <         endif
> <     endif
> < ! check the grid type
> <     if( grid_type_fv3_regional == 1 ) then
> <        !if(mype==0) write(6,*) 'FV3 regional input grid is  E-W N-S grid'
> <        grid_reverse_flag=.true.    ! grid is revered comparing to usual map view
> <     else if(grid_type_fv3_regional == 2) then
> <        !if(mype==0) write(6,*) 'FV3 regional input grid is  W-E S-N grid'
> <        grid_reverse_flag=.false.   ! grid orientated just like we see on map view    
> <     else
> <        write(6,*) 'Error: FV3 regional input grid is unknown grid'
> <        call stop2(678)
> <     endif
> < !
> <     if(grid_type_fv3_regional == 2) then
> <        call reverse_grid_r(grid_lont,nx,ny,1)
> <        call reverse_grid_r(grid_latt,nx,ny,1)
> <        call reverse_grid_r(grid_lon,nx+1,ny+1,1)
> <        call reverse_grid_r(grid_lat,nx+1,ny+1,1)
> <     endif
> < 
> <     iret=nf90_close(gfile_loc)
> < 
> <     iret=nf90_open(ak_bk,nf90_nowrite,gfile_loc)
> <     if(iret/=nf90_noerr) then
> <        write(6,*)'gsi_rfv3io_get_grid_specs: problem opening ',trim(ak_bk),', Status = ',iret
> <        ierr=1
> <        return
> <     endif
> <     iret=nf90_inquire(gfile_loc,ndimensions,nvariables,nattributes,unlimiteddimid)
> <     do k=1,ndimensions
> <        iret=nf90_inquire_dimension(gfile_loc,k,name,len)
> <        if(trim(name)=='xaxis_1') nz=len
> <     enddo
> <     !if(mype==0)write(6,'(" nz=",i5)') nz
> < 
> <     nsig=nz-1
> < 
> < !!!    get ak,bk
> < 
> <     if(.not.allocated(aeta1_ll)) allocate(aeta1_ll(nsig))
> <     if(.not.allocated(aeta2_ll)) allocate(aeta2_ll(nsig))
> <     if(.not.allocated(eta1_ll)) allocate(eta1_ll(nsig+1))
> <     if(.not.allocated(eta2_ll)) allocate(eta2_ll(nsig+1))
> <     if(.not.allocated(ak)) allocate(ak(nz))
> <     if(.not.allocated(bk)) allocate(bk(nz))
> <     if(.not.allocated(abk_fv3)) allocate(abk_fv3(nz))
> < 
> <     do k=ndimensions+1,nvariables
> <        iret=nf90_inquire_variable(gfile_loc,k,name,len)
> <        if(trim(name)=='ak'.or.trim(name)=='AK') then
> <           iret=nf90_get_var(gfile_loc,k,abk_fv3)
> <           do i=1,nz
> <              ak(i)=abk_fv3(nz+1-i)
> <           enddo
> <        endif
> <        if(trim(name)=='bk'.or.trim(name)=='BK') then
> <           iret=nf90_get_var(gfile_loc,k,abk_fv3)
> <           do i=1,nz
> <              bk(i)=abk_fv3(nz+1-i)
> <           enddo
> <        endif
> <     enddo
> <     iret=nf90_close(gfile_loc)
> < 
> < !!!!! change unit of ak 
> <     do i=1,nsig+1
> <        eta1_ll(i)=ak(i)*0.001_r_kind
> <        eta2_ll(i)=bk(i)
> <     enddo
> <     do i=1,nsig
> <        aeta1_ll(i)=half*(ak(i)+ak(i+1))*0.001_r_kind
> <        aeta2_ll(i)=half*(bk(i)+bk(i+1))
> <     enddo
> <     !if(mype==0)then
> <     !   do i=1,nz
> <     !      write(6,'(" ak,bk(",i3,") = ",2f17.6)') i,ak(i),bk(i)
> <     !   enddo
> <     !endif
> < 
> < !!!!!!! setup A grid and interpolation/rotation coeff.
> <     call m_generate_anl_grid(nx,ny,grid_lon,grid_lont,grid_lat,grid_latt,gsi_lats,gsi_lons)
> < 
> <     deallocate (grid_lon,grid_lat,grid_lont,grid_latt)
> <     deallocate (ak,bk,abk_fv3)
> < 
> <     deallocate(ny_layout_len,ny_layout_b,ny_layout_e)
> <     deallocate(aeta1_ll,aeta2_ll)
> <     deallocate(eta1_ll,eta2_ll)
> < 
> <     return
> < end subroutine m_gsi_rfv3io_get_grid_specs
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_rwOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_spdOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_sstOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsisub.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_swcpOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_tcamtOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_tcpOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_td2mOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_tOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_unformatted.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_uwnd10mOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_visOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_vwnd10mOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_wOper.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: gsi_wspd10mOper.F90
> Only in ./: guess_grids.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: guess_grids.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: half_nmm_grid2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: hdraobmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: hilbert_curve.f90
> diff -r ./hybrid_ensemble_isotropic.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/hybrid_ensemble_isotropic.F90
> 50a51,52
> > !   2022-09-15  yokota  - add scale/variable/time-dependent localization
> > !   2024-02-20  yokota  - add MGBF-based localization
> 90,91c92,93
> <   use m_kinds, only: r_kind,i_kind,r_single
> <   use m_mpimod, only: mype
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> >   use mpimod, only: mype
> 102c104,108
> <   use mpeu_util, only: StrUpCase
> ---
> >   use string_utility, only: StrUpCase
> > 
> > ! For MGBF
> >   use mg_intstate
> >   use mg_timers
> 129d134
> <   public :: destroy_sf_xy
> 144,146d148
> < #ifdef USE_ALL_ORIGINAL
> <   public :: ens_iterate_update
> < #endif /* USE_ALL_ORIGINAL */
> 165,173c167,175
> <   real(r_kind),allocatable:: fmatz(:,:,:,:)
> <   real(r_kind),allocatable:: fmat0z(:,:,:)
> <   real(r_kind),allocatable:: fmatx(:,:,:,:,:)
> <   real(r_kind),allocatable:: fmat0x(:,:,:,:)
> <   real(r_kind),allocatable:: fmaty(:,:,:,:)
> <   real(r_kind),allocatable:: fmat0y(:,:,:)
> <   real(r_kind),allocatable:: znorm_new(:,:)
> <   real(r_kind),allocatable:: xnorm_new(:,:,:)
> <   real(r_kind),allocatable:: ynorm_new(:,:)
> ---
> >   real(r_kind),allocatable:: fmatz(:,:,:,:,:)
> >   real(r_kind),allocatable:: fmat0z(:,:,:,:)
> >   real(r_kind),allocatable:: fmatx(:,:,:,:,:,:)
> >   real(r_kind),allocatable:: fmat0x(:,:,:,:,:)
> >   real(r_kind),allocatable:: fmaty(:,:,:,:,:)
> >   real(r_kind),allocatable:: fmat0y(:,:,:,:)
> >   real(r_kind),allocatable:: znorm_new(:,:,:)
> >   real(r_kind),allocatable:: xnorm_new(:,:,:,:)
> >   real(r_kind),allocatable:: ynorm_new(:,:,:)
> 177c179
> <   real(r_kind),allocatable,dimension(:,:)  :: spectral_filter,sqrt_spectral_filter
> ---
> >   real(r_kind),allocatable,dimension(:,:,:)  :: spectral_filter,sqrt_spectral_filter
> 180,181c182,186
> <   real(r_kind),allocatable,dimension(:,:,:)   :: spread2d
> <   real(r_kind),allocatable,dimension(:,:,:,:) :: spread3d
> ---
> >   integer(r_kind) :: nval_loc_en
> > 
> > ! For MGBF
> >   type (mg_intstate_type), allocatable, dimension(:) :: obj_mgbf
> >   real(r_kind), allocatable, dimension(:,:,:) :: work_mgbf
> 192,193d196
> <   logical,parameter:: lsqrtb=.false. ! _RT: deactivated
> < 
> 236,238c239
> <   use gridmod, only: nsig,ak5,bk5,eta1_ll,eta2_ll,pt_ll,pdtop_ll
> < #ifdef USE_ALL_ORIGINAL
> <   use gridmod, only: twodvar_regional, &
> ---
> >   use gridmod, only: nsig,ak5,bk5,eta1_ll,eta2_ll,pt_ll,pdtop_ll,twodvar_regional, &
> 241d241
> < #endif /* USE_ALL_ORIGINAL */
> 244a245
> >   use hybrid_ensemble_parameters, only: naensloc
> 248c249
> <   real(r_kind)   ,intent(in) :: z_len(grd_ens%nsig)
> ---
> >   real(r_kind)   ,intent(in) :: z_len(grd_ens%nsig,naensloc)
> 250c251
> <   integer(i_kind) k,nxy,i,ii,jj,j,l
> ---
> >   integer(i_kind) k,nxy,i,ii,jj,j,l,ig
> 259c260
> <   rnsig=float(nsig)
> ---
> >   rnsig=real(nsig,r_kind)
> 263,264c264,265
> <   if(.not.allocated(fmatz))  allocate(fmatz(nxy,2,nsig,2))
> <   if(.not.allocated(fmat0z)) allocate(fmat0z(nxy,nsig,2))
> ---
> >   if(.not.allocated(fmatz))  allocate(fmatz(nxy,2,nsig,2,naensloc))
> >   if(.not.allocated(fmat0z)) allocate(fmat0z(nxy,nsig,2,naensloc))
> 265a267,268
> > 
> >   do ig=1,naensloc
> 267c270
> <   if(maxval(z_len) > zero) then
> ---
> >   if(maxval(z_len(:,ig)) > zero) then
> 271c274
> <         aspect(k)=z_len(k)**2
> ---
> >         aspect(k)=z_len(k,ig)**2
> 279c282
> <              fmatz(i,j,k,l)=fmatz_tmp(j,k,l)
> ---
> >              fmatz(i,j,k,l,ig)=fmatz_tmp(j,k,l)
> 285c288
> <            fmat0z(i,k,l)=fmat0z_tmp(k,l)
> ---
> >            fmat0z(i,k,l,ig)=fmat0z_tmp(k,l)
> 303d305
> < #ifdef USE_ALL_ORIGINAL
> 327d328
> < #endif /* USE_ALL_ORIGINAL  */
> 332d332
> < #ifdef USE_ALL_ORIGINAL
> 334d333
> < #endif /* USE_ALL_ORIGINAL  */
> 338c337
> <               d1=abs(z_len(k))/dlnp
> ---
> >               d1=abs(z_len(k,ig))/dlnp
> 349c348
> <                  fmatz(i,j,k,l)=fmatz_tmp(j,k,l)
> ---
> >                  fmatz(i,j,k,l,ig)=fmatz_tmp(j,k,l)
> 355c354
> <                fmat0z(i,k,l)=fmat0z_tmp(k,l)
> ---
> >                fmat0z(i,k,l,ig)=fmat0z_tmp(k,l)
> 360a360
> >   enddo !ig loop
> 393a394
> >   use hybrid_ensemble_parameters, only: naensloc
> 398c399
> <   real(r_kind),intent(in   ) :: x_len(kl)
> ---
> >   real(r_kind),intent(in   ) :: x_len(kl,naensloc)
> 401c402
> <   integer(i_kind) i,j,k,l,kk
> ---
> >   integer(i_kind) i,j,k,l,kk,ig
> 408,415c409,412
> <   allocate(fmatx(grd_loc%nlat,2,grd_loc%nlon,2,kl),fmat0x(grd_loc%nlat,grd_loc%nlon,2,kl))
> <   do k=1,kl
> <      do i=1,grd_loc%nlat
> <         do j=1,grd_loc%nlon
> <            aspect(j)=(x_len(k)*region_dy_ens(grd_loc%nlat/2,grd_loc%nlon/2)/region_dx_ens(i,j))**2 ! only works for rotated lat-lon grids
> <         enddo
> <         call get_new_alpha_beta(aspect,grd_loc%nlon,fmatc,fmat0c)
> <         do kk=1,2
> ---
> >   allocate(fmatx(grd_loc%nlat,2,grd_loc%nlon,2,kl,naensloc),fmat0x(grd_loc%nlat,grd_loc%nlon,2,kl,naensloc))
> >   do ig=1,naensloc
> >      do k=1,kl
> >         do i=1,grd_loc%nlat
> 417,418c414,423
> <               do l=1,2
> <                  fmatx(i,l,j,kk,k)=fmatc(l,j,kk)
> ---
> >               ! only works for rotated lat-lon grids
> >               aspect(j)=(x_len(k,ig)*region_dy_ens(grd_loc%nlat/2,grd_loc%nlon/2)/region_dx_ens(i,j))**2
> >            enddo
> >            call get_new_alpha_beta(aspect,grd_loc%nlon,fmatc,fmat0c)
> >            do kk=1,2
> >               do j=1,grd_loc%nlon
> >                  do l=1,2
> >                     fmatx(i,l,j,kk,k,ig)=fmatc(l,j,kk)
> >                  enddo
> >                  fmat0x(i,j,kk,k,ig)=fmat0c(j,kk)
> 420d424
> <               fmat0x(i,j,kk,k)=fmat0c(j,kk)
> 424c428
> <   enddo
> ---
> >   enddo !ig loop
> 455a460
> >   use hybrid_ensemble_parameters, only: naensloc
> 460c465
> <   real(r_kind),intent(in   ) :: y_len(kl)
> ---
> >   real(r_kind),intent(in   ) :: y_len(kl,naensloc)
> 464c469
> <   integer(i_kind) i,k
> ---
> >   integer(i_kind) i,k,ig
> 469,472c474,480
> <   allocate(fmaty(2,grd_loc%nlat,2,kl),fmat0y(grd_loc%nlat,2,kl))
> <   do k=1,kl
> <      do i=1,grd_loc%nlat
> <         aspect(i)=y_len(k)**2
> ---
> >   allocate(fmaty(2,grd_loc%nlat,2,kl,naensloc),fmat0y(grd_loc%nlat,2,kl,naensloc))
> >   do ig=1,naensloc
> >      do k=1,kl
> >         do i=1,grd_loc%nlat
> >            aspect(i)=y_len(k,ig)**2
> >         enddo
> >         call get_new_alpha_beta(aspect,grd_loc%nlat,fmaty(1,1,1,k,ig),fmat0y(1,1,k,ig))
> 474,475c482
> <      call get_new_alpha_beta(aspect,grd_loc%nlat,fmaty(1,1,1,k),fmat0y(1,1,k))
> <   enddo
> ---
> >   enddo !ig loop
> 480c487
> < subroutine new_factorization_rf_z(f,iadvance,iback)
> ---
> > subroutine new_factorization_rf_z(f,iadvance,iback,ig)
> 497a505
> > !     ig       - number for smoothing scales
> 511c519
> <   integer(i_kind),intent(in   ) :: iadvance,iback
> ---
> >   integer(i_kind),intent(in   ) :: iadvance,iback,ig
> 520c528
> <            f(i,k)=znorm_new(i,k)*f(i,k)
> ---
> >            f(i,k)=znorm_new(i,k,ig)*f(i,k)
> 527c535
> <            f(i,k)=f(i,k)-fmatz(i,l,k,iadvance)*f(i,k-l)
> ---
> >            f(i,k)=f(i,k)-fmatz(i,l,k,iadvance,ig)*f(i,k-l)
> 531c539
> <         f(i,k)=fmat0z(i,k,iadvance)*f(i,k)
> ---
> >         f(i,k)=fmat0z(i,k,iadvance,ig)*f(i,k)
> 537c545
> <            f(i,k)=f(i,k)-fmatz(i,l,k+l,iback)*f(i,k+l)
> ---
> >            f(i,k)=f(i,k)-fmatz(i,l,k+l,iback,ig)*f(i,k+l)
> 541c549
> <         f(i,k)=fmat0z(i,k,iback)*f(i,k)
> ---
> >         f(i,k)=fmat0z(i,k,iback,ig)*f(i,k)
> 547c555
> <            f(i,k)=znorm_new(i,k)*f(i,k)
> ---
> >            f(i,k)=znorm_new(i,k,ig)*f(i,k)
> 555c563
> < subroutine new_factorization_rf_x(f,iadvance,iback,nlevs)
> ---
> > subroutine new_factorization_rf_x(f,iadvance,iback,nlevs,ig)
> 573a582,583
> > !     nlevs    - number of vertical levels for smoothing
> > !     ig       - number for smoothing scales
> 586c596
> <   integer(i_kind),intent(in   ) :: iadvance,iback,nlevs
> ---
> >   integer(i_kind),intent(in   ) :: iadvance,iback,nlevs,ig
> 594c604
> < !$omp parallel do schedule(dynamic,1) private(k,j,i,l)
> ---
> > !$omp parallel do schedule(static,1) private(k,j,i,l)
> 600c610
> <                  f(i,j,k)=xnorm_new(i,j,k)*f(i,j,k)
> ---
> >                  f(i,j,k)=xnorm_new(i,j,k,ig)*f(i,j,k)
> 608c618
> <                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j,iadvance,k)*f(i,j-l,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j,iadvance,k,ig)*f(i,j-l,k)
> 612c622
> <               f(i,j,k)=fmat0x(i,j,iadvance,k)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0x(i,j,iadvance,k,ig)*f(i,j,k)
> 619c629
> <                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j+l,iback,k)*f(i,j+l,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j+l,iback,k,ig)*f(i,j+l,k)
> 623c633
> <               f(i,j,k)=fmat0x(i,j,iback,k)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0x(i,j,iback,k,ig)*f(i,j,k)
> 630c640
> <                  f(i,j,k)=xnorm_new(i,j,k)*f(i,j,k)
> ---
> >                  f(i,j,k)=xnorm_new(i,j,k,ig)*f(i,j,k)
> 637c647
> < !$omp parallel do schedule(dynamic,1) private(k,j,i,l)
> ---
> > !$omp parallel do schedule(static,1) private(k,j,i,l)
> 643c653
> <                  f(i,j,k)=xnorm_new(i,j,1)*f(i,j,k)
> ---
> >                  f(i,j,k)=xnorm_new(i,j,1,ig)*f(i,j,k)
> 651c661
> <                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j,iadvance,1)*f(i,j-l,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j,iadvance,1,ig)*f(i,j-l,k)
> 655c665
> <               f(i,j,k)=fmat0x(i,j,iadvance,1)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0x(i,j,iadvance,1,ig)*f(i,j,k)
> 662c672
> <                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j+l,iback,1)*f(i,j+l,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmatx(i,l,j+l,iback,1,ig)*f(i,j+l,k)
> 666c676
> <               f(i,j,k)=fmat0x(i,j,iback,1)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0x(i,j,iback,1,ig)*f(i,j,k)
> 673c683
> <                  f(i,j,k)=xnorm_new(i,j,1)*f(i,j,k)
> ---
> >                  f(i,j,k)=xnorm_new(i,j,1,ig)*f(i,j,k)
> 683c693
> < subroutine new_factorization_rf_y(f,iadvance,iback,nlevs)
> ---
> > subroutine new_factorization_rf_y(f,iadvance,iback,nlevs,ig)
> 701a712,713
> > !     nlevs    - number of vertical levels for smoothing
> > !     ig       - number for smoothing scales
> 712c724
> <                       !                  use m_mpimod, only: mype
> ---
> >                       !                  use mpimod, only: mype
> 715c727
> <   integer(i_kind),intent(in   ) :: iadvance,iback,nlevs
> ---
> >   integer(i_kind),intent(in   ) :: iadvance,iback,nlevs,ig
> 728c740
> <                  f(i,j,k)=ynorm_new(i,k)*f(i,j,k)
> ---
> >                  f(i,j,k)=ynorm_new(i,k,ig)*f(i,j,k)
> 734c746
> <                  f(i,j,k)=f(i,j,k)-fmaty(l,i,iadvance,k)*f(i-l,j,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmaty(l,i,iadvance,k,ig)*f(i-l,j,k)
> 736c748
> <               f(i,j,k)=fmat0y(i,iadvance,k)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0y(i,iadvance,k,ig)*f(i,j,k)
> 741c753
> <                  f(i,j,k)=f(i,j,k)-fmaty(l,i+l,iback,k)*f(i+l,j,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmaty(l,i+l,iback,k,ig)*f(i+l,j,k)
> 743c755
> <               f(i,j,k)=fmat0y(i,iback,k)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0y(i,iback,k,ig)*f(i,j,k)
> 748c760
> <                  f(i,j,k)=ynorm_new(i,k)*f(i,j,k)
> ---
> >                  f(i,j,k)=ynorm_new(i,k,ig)*f(i,j,k)
> 760c772
> <                  f(i,j,k)=ynorm_new(i,1)*f(i,j,k)
> ---
> >                  f(i,j,k)=ynorm_new(i,1,ig)*f(i,j,k)
> 766c778
> <                  f(i,j,k)=f(i,j,k)-fmaty(l,i,iadvance,1)*f(i-l,j,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmaty(l,i,iadvance,1,ig)*f(i-l,j,k)
> 768c780
> <               f(i,j,k)=fmat0y(i,iadvance,1)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0y(i,iadvance,1,ig)*f(i,j,k)
> 773c785
> <                  f(i,j,k)=f(i,j,k)-fmaty(l,i+l,iback,1)*f(i+l,j,k)
> ---
> >                  f(i,j,k)=f(i,j,k)-fmaty(l,i+l,iback,1,ig)*f(i+l,j,k)
> 775c787
> <               f(i,j,k)=fmat0y(i,iback,1)*f(i,j,k)
> ---
> >               f(i,j,k)=fmat0y(i,iback,1,ig)*f(i,j,k)
> 780c792
> <                  f(i,j,k)=ynorm_new(i,1)*f(i,j,k)
> ---
> >                  f(i,j,k)=ynorm_new(i,1,ig)*f(i,j,k)
> 814c826
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 815a828
> >   use hybrid_ensemble_parameters, only: naensgrp,naensloc
> 819c832
> <   integer(i_kind) k,iadvance,iback,nxy
> ---
> >   integer(i_kind) k,iadvance,iback,nxy,ig
> 823c836
> <   allocate(znorm_new(grd_ens%latlon11,grd_ens%nsig))
> ---
> >   allocate(znorm_new(grd_ens%latlon11,grd_ens%nsig,naensloc))
> 829,836c842,845
> <   do k=1,grd_ens%nsig
> <       f=zero
> <       f(:,k)=one
> < 
> <       iadvance=1 ; iback=2
> <       call new_factorization_rf_z(f,iadvance,iback)
> <       iadvance=2 ; iback=1
> <       call new_factorization_rf_z(f,iadvance,iback)
> ---
> >   do ig=1,naensgrp
> >      do k=1,grd_ens%nsig
> >         f=zero
> >         f(:,k)=one
> 838,839c847,853
> <       diag(:,k)=sqrt(one/f(:,k))
> <   enddo
> ---
> >         iadvance=1 ; iback=2
> >         call new_factorization_rf_z(f,iadvance,iback,ig)
> >         iadvance=2 ; iback=1
> >         call new_factorization_rf_z(f,iadvance,iback,ig)
> >         
> >         diag(:,k)=sqrt(one/f(:,k))
> >      enddo
> 841,843c855,858
> <   do k=1,grd_ens%nsig
> <       znorm_new(:,k)=diag(:,k)
> <   enddo
> ---
> >      do k=1,grd_ens%nsig
> >         znorm_new(:,k,ig)=diag(:,k)
> >      enddo
> >   enddo !ig loop
> 852c867
> <        call new_factorization_rf_z(f,iadvance,iback)
> ---
> >        call new_factorization_rf_z(f,iadvance,iback,1)
> 854c869
> <        call new_factorization_rf_z(f,iadvance,iback)
> ---
> >        call new_factorization_rf_z(f,iadvance,iback,1)
> 892c907
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 893a909
> >   use hybrid_ensemble_parameters, only: naensgrp,naensloc
> 898c914
> <   integer(i_kind) i,j,k,iadvance,iback,kl
> ---
> >   integer(i_kind) i,j,k,iadvance,iback,kl,ig
> 914c930
> <   allocate(xnorm_new(grd_loc%nlat,grd_loc%nlon,kl))
> ---
> >   allocate(xnorm_new(grd_loc%nlat,grd_loc%nlon,kl,naensloc))
> 919,923c935,941
> <   do j=1,grd_loc%nlon
> <      f=zero
> <      do k=1,kl
> <         do i=1,grd_loc%nlat
> <            f(i,j,k)=one
> ---
> >   do ig=1,naensgrp
> >      do j=1,grd_loc%nlon
> >         f=zero
> >         do k=1,kl
> >            do i=1,grd_loc%nlat
> >               f(i,j,k)=one
> >            enddo
> 925,932c943,950
> <      enddo
> <      iadvance=1 ; iback=2
> <      call new_factorization_rf_x(f,iadvance,iback,kl)
> <      iadvance=2 ; iback=1
> <      call new_factorization_rf_x(f,iadvance,iback,kl)
> <      do k=1,kl
> <         do i=1,grd_loc%nlat
> <            diag(i,j,k)=sqrt(one/f(i,j,k))
> ---
> >         iadvance=1 ; iback=2
> >         call new_factorization_rf_x(f,iadvance,iback,kl,ig)
> >         iadvance=2 ; iback=1
> >         call new_factorization_rf_x(f,iadvance,iback,kl,ig)
> >         do k=1,kl
> >            do i=1,grd_loc%nlat
> >               diag(i,j,k)=sqrt(one/f(i,j,k))
> >            enddo
> 935,939c953,957
> <   enddo
> <   do k=1,kl
> <      do j=1,grd_loc%nlon
> <         do i=1,grd_loc%nlat
> <            xnorm_new(i,j,k)=diag(i,j,k)
> ---
> >      do k=1,kl
> >         do j=1,grd_loc%nlon
> >            do i=1,grd_loc%nlat
> >               xnorm_new(i,j,k,ig)=diag(i,j,k)
> >            enddo
> 942c960
> <   enddo
> ---
> >   enddo !ig loop
> 953c971
> <         call new_factorization_rf_x(f,iadvance,iback,kl)
> ---
> >         call new_factorization_rf_x(f,iadvance,iback,kl,1)
> 955c973
> <         call new_factorization_rf_x(f,iadvance,iback,kl)
> ---
> >         call new_factorization_rf_x(f,iadvance,iback,kl,1)
> 993c1011
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 994a1013
> >   use hybrid_ensemble_parameters, only: naensgrp,naensloc
> 998c1017
> <   integer(i_kind) i,k,lend,lcount,iadvance,iback,kl,loop,ll,iend
> ---
> >   integer(i_kind) i,k,lend,lcount,iadvance,iback,kl,loop,ll,iend,ig
> 1015c1034
> <   allocate(ynorm_new(grd_loc%nlat,kl))
> ---
> >   allocate(ynorm_new(grd_loc%nlat,kl,naensloc))
> 1030,1037c1049,1058
> <   do loop=1,lend
> <      ll=(loop-1)*iend
> <      f=zero
> <      do k=1,kl
> <         do i=1,iend
> <         lcount=ll+i
> <         f(lcount,i,k)=one
> <         if(lcount == grd_loc%nlat) exit
> ---
> >   do ig=1,naensgrp
> >      do loop=1,lend
> >         ll=(loop-1)*iend
> >         f=zero
> >         do k=1,kl
> >            do i=1,iend
> >               lcount=ll+i
> >               f(lcount,i,k)=one
> >               if(lcount == grd_loc%nlat) exit
> >            enddo
> 1039d1059
> <      enddo
> 1041,1044c1061,1064
> <      iadvance=1 ; iback=2
> <      call new_factorization_rf_y(f,iadvance,iback,kl)
> <      iadvance=2 ; iback=1
> <      call new_factorization_rf_y(f,iadvance,iback,kl)
> ---
> >         iadvance=1 ; iback=2
> >         call new_factorization_rf_y(f,iadvance,iback,kl,ig)
> >         iadvance=2 ; iback=1
> >         call new_factorization_rf_y(f,iadvance,iback,kl,ig)
> 1046,1051c1066,1072
> <      do k=1,kl
> <         do i=1,iend
> <            lcount=ll+i
> <            diag(lcount,k)=sqrt(one/f(lcount,i,k))
> <            ynorm_new(lcount,k)=diag(lcount,k)
> <            if(lcount == grd_loc%nlat) exit
> ---
> >         do k=1,kl
> >            do i=1,iend
> >               lcount=ll+i
> >               diag(lcount,k)=sqrt(one/f(lcount,i,k))
> >               ynorm_new(lcount,k,ig)=diag(lcount,k)
> >               if(lcount == grd_loc%nlat) exit
> >            enddo
> 1054c1075
> <   enddo
> ---
> >   enddo !ig loop
> 1069c1090
> <         call new_factorization_rf_y(f,iadvance,iback,kl)
> ---
> >         call new_factorization_rf_y(f,iadvance,iback,kl,1)
> 1071c1092
> <         call new_factorization_rf_y(f,iadvance,iback,kl) 
> ---
> >         call new_factorization_rf_y(f,iadvance,iback,kl,1) 
> 1111a1133
> >     use hybrid_ensemble_parameters, only: ntotensgrp
> 1117c1139
> <     integer(i_kind) n,istatus,m
> ---
> >     integer(i_kind) n,istatus,m,ig
> 1123c1145
> <     allocate(en_perts(n_ens,ntlevs_ens))
> ---
> >     allocate(en_perts(n_ens,ntotensgrp,ntlevs_ens))
> 1127,1133c1149,1157
> <        do n=1,n_ens
> <           call gsi_bundlecreate(en_perts(n,m),grid_ens,'ensemble perts',istatus, &
> <                                 names2d=cvars2d,names3d=cvars3d,bundle_kind=r_single)
> <           if(istatus/=0) then
> <              write(6,*)trim(myname_),': trouble creating en_perts bundle'
> <              call stop2(999)
> <           endif
> ---
> >        do ig=1,ntotensgrp
> >           do n=1,n_ens
> >              call gsi_bundlecreate(en_perts(n,ig,m),grid_ens,'ensemble perts',istatus, &
> >                                    names2d=cvars2d,names3d=cvars3d,bundle_kind=r_single)
> >              if(istatus/=0) then
> >                 write(6,*)trim(myname_),': trouble creating en_perts bundle'
> >                 call stop2(999)
> >              endif
> >           enddo
> 1140,1142c1164,1166
> <        write(6,*)' in create_ensemble, grd_ens%latlon11,grd_ens%latlon1n,n_ens,ntlevs_ens=', &
> <                                  grd_ens%latlon11,grd_ens%latlon1n,n_ens,ntlevs_ens
> <        write(6,*)' in create_ensemble, total bytes allocated=',4*nelen*n_ens*ntlevs_ens
> ---
> >        write(6,*)' in create_ensemble, grd_ens%latlon11,grd_ens%latlon1n,n_ens,ntotensgrp,ntlevs_ens=', &
> >                                  grd_ens%latlon11,grd_ens%latlon1n,n_ens,ntotensgrp,ntlevs_ens
> >        write(6,*)' in create_ensemble, total bytes allocated=',4*nelen*n_ens*ntotensgrp*ntlevs_ens
> 1148c1172
> <   subroutine load_ensemble (tau)
> ---
> >   subroutine load_ensemble
> 1187,1188c1211
> <     use hybrid_ensemble_parameters, only: write_ens_sprd
> <     use hybrid_ensemble_parameters, only: nymd,nhms
> ---
> >     use hybrid_ensemble_parameters, only: l_both_fv3sar_gfs_ens 
> 1190c1213
> <     use m_mpimod, only: mype
> ---
> >     use mpimod, only: mype
> 1192d1214
> < #ifdef USE_ALL_ORIGINAL
> 1193a1216
> >     use get_fv3_regional_ensperts_mod, only: get_fv3_regional_ensperts_class
> 1196c1219
> < #endif /* USE_ALL_ORIGINAL */
> ---
> >     use mpimod, only: mpi_comm_world
> 1200,1206c1223,1226
> <     integer,intent(in) :: tau
> < 
> <     type(get_pseudo_ensperts_class) :: pseudo_enspert
> < #ifdef USE_ALL_ORIGINAL
> <     type(get_wrf_mass_ensperts_class) :: wrf_mass_enspert
> <     type(get_wrf_nmm_ensperts_class) :: wrf_nmm_enspert
> < #endif /* USE_ALL_ORIGINAL */
> ---
> >    type(get_pseudo_ensperts_class) :: pseudo_enspert
> >    type(get_wrf_mass_ensperts_class) :: wrf_mass_enspert
> >    type(get_wrf_nmm_ensperts_class) :: wrf_nmm_enspert
> >    type(get_fv3_regional_ensperts_class) :: fv3_regional_enspert
> 1267c1287
> <                 en_perts(n,m)%valuesr4(ii)=bundle_ens%values(ii)
> ---
> >                 en_perts(n,1,m)%valuesr4(ii)=bundle_ens%values(ii)
> 1298c1318
> <                 en_perts(n,m)%valuesr4(ii)=(en_perts(n,m)%valuesr4(ii)-en_bar(m)%values(ii)*bar_norm)*sig_norm
> ---
> >                 en_perts(n,1,m)%valuesr4(ii)=(en_perts(n,1,m)%valuesr4(ii)-en_bar(m)%values(ii)*bar_norm)*sig_norm
> 1300c1320
> <              call gsi_enscoupler_put_gsi_ens(grd_ens,n,m,en_perts(n,m),istatus)
> ---
> >              call gsi_enscoupler_put_gsi_ens(grd_ens,n,m,en_perts(n,1,m),istatus)
> 1307,1308d1326
> <           if (write_ens_sprd)  call ens_spread_dualres(en_bar(m),m,nymd(m),nhms(m))
> < 
> 1324c1342
> <           call get_gefs_ensperts_dualres(tau)
> ---
> >           call get_gefs_ensperts_dualres
> 1328c1346
> <           if(regional_ensemble_option < 1 .or. regional_ensemble_option > 4) then
> ---
> >           if(regional_ensemble_option < 1 .or. regional_ensemble_option > 5) then
> 1345d1362
> < 
> 1357d1373
> < #ifdef USE_ALL_ORIGINAL
> 1359d1374
> < #endif /* USE_ALL_ORIGINAL */
> 1372d1386
> < #ifdef USE_ALL_ORIGINAL
> 1374d1387
> < #endif /* USE_ALL_ORIGINAL */
> 1380d1392
> < #ifdef USE_ALL_ORIGINAL
> 1382d1393
> < #endif /* USE_ALL_ORIGINAL */
> 1388d1398
> < #ifdef USE_ALL_ORIGINAL
> 1390c1400,1407
> < #endif /* USE_ALL_ORIGINAL */
> ---
> >              case(5)
> >                 if (l_both_fv3sar_gfs_ens) then ! first read in gfs ensembles for regional 
> >                    call get_gefs_for_regional
> >                 endif
> >     
> > !     regional_ensemble_option = 5: ensembles are fv3 regional.
> >                 call fv3_regional_enspert%get_fv3_regional_ensperts(en_perts,nelen,ps_bar)
> >    
> 1452c1469
> <     use m_kinds, only: r_kind,i_kind,i_llong
> ---
> >     use kinds, only: r_kind,i_kind,i_llong
> 1454c1471
> <     use m_mpimod, only: mype,mpi_rtype,gsi_mpi_comm_world,ierror
> ---
> >     use mpimod, only: mype,mpi_rtype,mpi_comm_world,ierror
> 1471d1487
> <     integer(i_kind) istat_uu,istat_vv
> 1494c1510
> <        call mpi_bcast(seed,nval2f*nscl,mpi_rtype,0,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_bcast(seed,nval2f*nscl,mpi_rtype,0,mpi_comm_world,ierror)
> 1535a1552,1555
> >        allocate(ua(grd_anl%lat2,grd_anl%lon2,grd_anl%nsig))
> >        allocate(va(grd_anl%lat2,grd_anl%lon2,grd_anl%nsig))
> >        istat_st=-999
> >        istat_vp=-999
> 1537,1538c1557,1558
> <           if(trim(cvars3d(ic3))=='u') call gsi_bundlegetpointer (bundle_anl, cvars3d(ic3),st, istat_uu)
> <           if(trim(cvars3d(ic3))=='v') call gsi_bundlegetpointer (bundle_anl, cvars3d(ic3),vp, istat_vv)
> ---
> >           if(trim(cvars3d(ic3))=='sf') call gsi_bundlegetpointer (bundle_anl, cvars3d(ic3),st, istat_st)
> >           if(trim(cvars3d(ic3))=='vp') call gsi_bundlegetpointer (bundle_anl, cvars3d(ic3),vp, istat_vp)
> 1540,1555c1560,1562
> <        if(istat_uu+istat_vv/=0) then
> <          allocate(ua(grd_anl%lat2,grd_anl%lon2,grd_anl%nsig))
> <          allocate(va(grd_anl%lat2,grd_anl%lon2,grd_anl%nsig))
> <          do ic3=1,nc3d
> <             if(trim(cvars3d(ic3))=='sf') call gsi_bundlegetpointer (bundle_anl, cvars3d(ic3),st, istat_st)
> <             if(trim(cvars3d(ic3))=='vp') call gsi_bundlegetpointer (bundle_anl, cvars3d(ic3),vp, istat_vp)
> <          enddo
> <          if(istat_st/=0.or.istat_vp/=0) then
> <             write(6,*) myname_,': error getting sf/vp pointers, aborting ...'
> <             call stop2(999)
> <          endif
> <          call getuv(ua,va,st,vp,0)
> <          st=ua
> <          vp=va
> <          deallocate(va)
> <          deallocate(ua)
> ---
> >        if(istat_st/=0.or.istat_vp/=0) then
> >           write(6,*) myname_,': error getting sf/vp pointers, aborting ...'
> >           call stop2(999)
> 1556a1564,1568
> >        call getuv(ua,va,st,vp,0)
> >        st=ua
> >        vp=va
> >        deallocate(va)
> >        deallocate(ua)
> 1597c1609
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 1608c1620
> < !$omp parallel do schedule(dynamic,1) private(j,k,i,jj,ii,zloc1)
> ---
> > !$omp parallel do schedule(static,1) private(j,k,i,jj,ii,zloc1)
> 1660c1672
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 1663a1676
> >     use hybrid_ensemble_parameters, only: ntotensgrp
> 1668c1681
> <     integer(i_kind) i,j,k,n,istatus,m
> ---
> >     integer(i_kind) i,j,k,n,istatus,m,ig
> 1672c1685
> <     call gsi_bundlegetpointer(en_perts(1,1),'q',w3,istatus)
> ---
> >     call gsi_bundlegetpointer(en_perts(1,1,1),'q',w3,istatus)
> 1685,1695c1698,1710
> < !$omp parallel do schedule(dynamic,1) private(n,i,j,k,w3,istatus)
> <        do n=1,n_ens
> <           call gsi_bundlegetpointer(en_perts(n,m),'q',w3,istatus)
> <           if(istatus/=0) then
> <              write(6,*)' error retrieving pointer to rh variable for ensemble number ',n
> <              call stop2(999)
> <           end if
> <           do k=1,grd_ens%nsig
> <              do j=1,grd_ens%lon2
> <                 do i=1,grd_ens%lat2
> <                    w3(i,j,k)=qvar3d_ens(i,j,k,1)*w3(i,j,k)
> ---
> >        do ig=1,ntotensgrp
> > !$omp parallel do schedule(static,1) private(n,i,j,k,w3,istatus)
> >           do n=1,n_ens
> >              call gsi_bundlegetpointer(en_perts(n,ig,m),'q',w3,istatus)
> >              if(istatus/=0) then
> >                 write(6,*)' error retrieving pointer to rh variable for ensemble number ',n
> >                 call stop2(999)
> >              end if
> >              do k=1,grd_ens%nsig
> >                 do j=1,grd_ens%lon2
> >                    do i=1,grd_ens%lat2
> >                       w3(i,j,k)=qvar3d_ens(i,j,k,1)*w3(i,j,k)
> >                    enddo
> 1728a1744,1745
> >     use hybrid_ensemble_parameters, only: ntotensgrp
> >     use hybrid_ensemble_parameters, only: l_mgbf_loc
> 1731c1748
> <     integer(i_kind) istatus,n,m
> ---
> >     integer(i_kind) istatus,n,m,ig
> 1735,1740c1752,1759
> <           do n=1,n_ens
> <              call gsi_bundleunset(en_perts(n,m),istatus)
> <              if(istatus/=0) then
> <                 write(6,*)'in destroy_ensemble: trouble destroying en_perts bundle'
> <                 call stop2(999)
> <              endif
> ---
> >           do ig=1,ntotensgrp
> >              do n=1,n_ens
> >                 call gsi_bundleunset(en_perts(n,ig,m),istatus)
> >                 if(istatus/=0) then
> >                    write(6,*)'in destroy_ensemble: trouble destroying en_perts bundle'
> >                    call stop2(999)
> >                 endif
> >              enddo
> 1744a1764
> >        if(l_mgbf_loc) call print_mg_timers("mgbf_timing_cpu.csv", print_cpu, mype)
> 1788a1809,1810
> >     use hybrid_ensemble_parameters, only: ntotensgrp,naensgrp
> >     use hybrid_ensemble_parameters, only: ensgrp2aensgrp
> 1793c1815
> <     type(gsi_bundle),intent(in)    :: a_en(n_ens)
> ---
> >     type(gsi_bundle),intent(in)    :: a_en(naensgrp,n_ens)
> 1799c1821
> <     integer(i_kind) :: ipc3d(nc3d),ipc2d(nc2d),istatus
> ---
> >     integer(i_kind) :: ipc3d(nc3d),ipc2d(nc2d),istatus,ig,iaens
> 1806c1828
> <     nogood=im/=a_en(1)%grid%im.or.jm/=a_en(1)%grid%jm.or.km/=a_en(1)%grid%km
> ---
> >     nogood=im/=a_en(1,1)%grid%im.or.jm/=a_en(1,1)%grid%jm.or.km/=a_en(1,1)%grid%km
> 1828c1850
> < !$omp parallel do schedule(dynamic,1) private(j,n,ic3,k,i,ipic)
> ---
> > !$omp parallel do schedule(static,1) private(j,n,ic3,k,i,ipic,ig,iaens)
> 1837,1841c1859,1868
> <           do n=1,n_ens
> <              do j=1,jm
> <                 do i=1,im
> <                    cvec%r3(ipic)%q(i,j,k)=cvec%r3(ipic)%q(i,j,k) &
> <                          +a_en(n)%r3(ipx)%q(i,j,k)*en_perts(n,ibin)%r3(ipic)%qr4(i,j,k)
> ---
> >           do ig=1,ntotensgrp
> >              iaens=ensgrp2aensgrp(ig,ic3,ibin)
> >              if(iaens>0) then
> >                 do n=1,n_ens
> >                    do j=1,jm
> >                       do i=1,im
> >                          cvec%r3(ipic)%q(i,j,k)=cvec%r3(ipic)%q(i,j,k) &
> >                               +a_en(iaens,n)%r3(ipx)%q(i,j,k)*en_perts(n,ig,ibin)%r3(ipic)%qr4(i,j,k)
> >                       enddo
> >                    enddo
> 1843c1870
> <              enddo
> ---
> >              endif ! iaens>0
> 1848d1874
> < !$omp parallel do schedule(dynamic,1) private(j,n,k,i,ic2,ipic)
> 1867,1872c1893,1903
> <              do n=1,n_ens
> <                 do j=1,jm
> <                    do k=1,km_tmp
> <                       do i=1,im
> <                          cvec%r2(ipic)%q(i,j)=cvec%r2(ipic)%q(i,j) &
> <                             +a_en(n)%r3(ipx)%q(i,j,k)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> ---
> >              do ig=1,ntotensgrp
> >                 iaens=ensgrp2aensgrp(ig,ic2+nc3d,ibin)
> >                 if(iaens>0) then
> >                    do n=1,n_ens
> >                       do k=1,km_tmp
> >                          do j=1,jm
> >                             do i=1,im
> >                                cvec%r2(ipic)%q(i,j)=cvec%r2(ipic)%q(i,j) &
> >                                     +a_en(iaens,n)%r3(ipx)%q(i,j,k)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> >                             enddo
> >                          enddo
> 1874,1876c1905,1907
> <                    enddo
> <                 enddo
> <              enddo ! enddo n_ens
> ---
> >                    enddo ! enddo n_ens
> >                 endif ! iaens>0
> >              enddo
> 1880,1887c1911,1923
> <              do n=1,n_ens
> <                 do j=1,jm
> <                    do i=1,im
> <                       cvec%r2(ipic)%q(i,j)=cvec%r2(ipic)%q(i,j) &
> <                          +a_en(n)%r3(ipx)%q(i,j,1)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)
> <                    enddo
> <                 enddo
> <              enddo ! enddo n_ens
> ---
> >              do ig=1,ntotensgrp
> >                 iaens=ensgrp2aensgrp(ig,ic2+nc3d,ibin)
> >                 if(iaens>0) then
> >                    do n=1,n_ens
> >                       do j=1,jm
> >                          do i=1,im
> >                             cvec%r2(ipic)%q(i,j)=cvec%r2(ipic)%q(i,j) &
> >                                  +a_en(iaens,n)%r3(ipx)%q(i,j,1)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)
> >                          enddo
> >                       enddo
> >                    enddo ! enddo n_ens
> >                 endif ! iaens>0
> >              enddo
> 1938a1975,1976
> >     use hybrid_ensemble_parameters, only: ntotensgrp,naensgrp
> >     use hybrid_ensemble_parameters, only: ensgrp2aensgrp
> 1945c1983
> <     type(gsi_bundle),intent(in)    :: a_en(n_ens)
> ---
> >     type(gsi_bundle),intent(in)    :: a_en(naensgrp,n_ens)
> 1952c1990
> <     integer(i_kind) :: ipc2d(nc2d),ipc3d(nc3d),istatus
> ---
> >     integer(i_kind) :: ipc2d(nc2d),ipc3d(nc3d),istatus,ig,iaens
> 1988c2026
> < !$omp parallel do schedule(dynamic,1) private(j,n,ic3,k,i,ipic)
> ---
> > !$omp parallel do schedule(static,1) private(j,n,ic3,k,i,ipic,ig,iaens)
> 1997,2001c2035,2044
> <           do n=1,n_ens
> <              do j=1,jm
> <                 do i=1,im
> <                    work_ens%r3(ipic)%q(i,j,k)=work_ens%r3(ipic)%q(i,j,k) &
> <                       +a_en(n)%r3(ipx)%q(i,j,k)*en_perts(n,ibin)%r3(ipic)%qr4(i,j,k)
> ---
> >           do ig=1,ntotensgrp
> >              iaens=ensgrp2aensgrp(ig,ic3,ibin)
> >              if(iaens>0) then
> >                 do n=1,n_ens
> >                    do j=1,jm
> >                       do i=1,im
> >                          work_ens%r3(ipic)%q(i,j,k)=work_ens%r3(ipic)%q(i,j,k) &
> >                               +a_en(iaens,n)%r3(ipx)%q(i,j,k)*en_perts(n,ig,ibin)%r3(ipic)%qr4(i,j,k)
> >                       enddo
> >                    enddo
> 2003c2046
> <              enddo
> ---
> >              endif ! iaens>0
> 2007d2049
> < !$omp parallel do schedule(dynamic,1) private(j,n,k,i,ic2,ipic)
> 2026,2031c2068,2078
> <              do n=1,n_ens
> <                 do k=1,km_tmp
> <                    do j=1,jm
> <                       do i=1,im
> <                          work_ens%r2(ipic)%q(i,j)=work_ens%r2(ipic)%q(i,j) &
> <                             +a_en(n)%r3(ipx)%q(i,j,k)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> ---
> >              do ig=1,ntotensgrp
> >                 iaens=ensgrp2aensgrp(ig,ic2+nc3d,ibin)
> >                 if(iaens>0) then
> >                    do n=1,n_ens
> >                       do k=1,km_tmp
> >                          do j=1,jm
> >                             do i=1,im
> >                                work_ens%r2(ipic)%q(i,j)=work_ens%r2(ipic)%q(i,j) &
> >                                     +a_en(iaens,n)%r3(ipx)%q(i,j,k)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> >                             enddo
> >                          enddo
> 2033,2035c2080,2082
> <                    enddo
> <                 enddo
> <              enddo ! enddo n_ens
> ---
> >                    enddo ! enddo n_ens
> >                 endif ! iaens>0
> >              enddo
> 2039,2046c2086,2098
> <              do n=1,n_ens
> <                 do j=1,jm
> <                    do i=1,im
> <                       work_ens%r2(ipic)%q(i,j)=work_ens%r2(ipic)%q(i,j) &
> <                          +a_en(n)%r3(ipx)%q(i,j,1)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)
> <                    enddo
> <                 enddo
> <              enddo ! enddo n_ens
> ---
> >              do ig=1,ntotensgrp
> >                 iaens=ensgrp2aensgrp(ig,ic2+nc3d,ibin)
> >                 if(iaens>0) then
> >                    do n=1,n_ens
> >                       do j=1,jm
> >                          do i=1,im
> >                             work_ens%r2(ipic)%q(i,j)=work_ens%r2(ipic)%q(i,j) &
> >                                  +a_en(iaens,n)%r3(ipx)%q(i,j,1)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)
> >                          enddo
> >                       enddo
> >                    enddo ! enddo n_ens
> >                 endif ! iaens>0
> >              enddo
> 2111a2164,2165
> >     use hybrid_ensemble_parameters, only: ntotensgrp,naensgrp
> >     use hybrid_ensemble_parameters, only: ensgrp2aensgrp
> 2115c2169
> <     type(gsi_bundle),intent(inout) :: a_en(n_ens)
> ---
> >     type(gsi_bundle),intent(inout) :: a_en(naensgrp,n_ens)
> 2121c2175
> <     integer(i_kind) :: ipc3d(nc3d),ipc2d(nc2d),istatus
> ---
> >     integer(i_kind) :: ipc3d(nc3d),ipc2d(nc2d),istatus,ig,iaens
> 2127c2181
> <     nogood=im/=a_en(1)%grid%im.or.jm/=a_en(1)%grid%jm.or.km/=a_en(1)%grid%km
> ---
> >     nogood=im/=a_en(1,1)%grid%im.or.jm/=a_en(1,1)%grid%jm.or.km/=a_en(1,1)%grid%km
> 2148c2202
> < !$omp parallel do schedule(dynamic,1) private(j,n,ic3,k,i,ic2,ipic)
> ---
> > !$omp parallel do schedule(static,1) private(j,n,ic3,k,i,ic2,ipic,ig,iaens)
> 2150,2156c2204,2215
> <        do ic3=1,nc3d
> <           ipic=ipc3d(ic3)
> <           do k=1,km
> <              do j=1,jm
> <                 do i=1,im
> <                       a_en(n)%r3(ipx)%q(i,j,k)=a_en(n)%r3(ipx)%q(i,j,k) &
> <                             +cvec%r3(ipic)%q(i,j,k)*en_perts(n,ibin)%r3(ipic)%qr4(i,j,k)
> ---
> >        do ig=1,ntotensgrp
> >           do ic3=1,nc3d
> >              iaens=ensgrp2aensgrp(ig,ic3,ibin)
> >              if(iaens>0) then
> >                 ipic=ipc3d(ic3)
> >                 do k=1,km
> >                    do j=1,jm
> >                       do i=1,im
> >                          a_en(iaens,n)%r3(ipx)%q(i,j,k)=a_en(iaens,n)%r3(ipx)%q(i,j,k) &
> >                               +cvec%r3(ipic)%q(i,j,k)*en_perts(n,ig,ibin)%r3(ipic)%qr4(i,j,k)
> >                       enddo
> >                    enddo
> 2158c2217
> <              enddo
> ---
> >              endif ! iaens>0
> 2160,2161d2218
> <        enddo
> <        do ic2=1,nc2d
> 2163,2164c2220,2224
> <           ipic=ipc2d(ic2)
> <           select case ( trim(StrUpCase(cvars2d(ic2))) )
> ---
> >           do ic2=1,nc2d
> >              iaens=ensgrp2aensgrp(ig,ic2+nc3d,ibin)
> >              if(iaens>0) then
> >                 ipic=ipc2d(ic2)
> >                 select case ( trim(StrUpCase(cvars2d(ic2))) )
> 2166c2226
> <              case('PS')
> ---
> >                    case('PS')
> 2168,2178c2228,2240
> <                 if ( pwgtflg ) then
> <                    km_tmp = km
> <                 else
> <                    km_tmp = 1
> <                 endif
> < 
> <                 do k=1,km_tmp
> <                    do j=1,jm
> <                       do i=1,im
> <                          a_en(n)%r3(ipx)%q(i,j,k)=a_en(n)%r3(ipx)%q(i,j,k) &
> <                             +cvec%r2(ipic)%q(i,j)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> ---
> >                       if ( pwgtflg ) then
> >                          km_tmp = km
> >                       else
> >                          km_tmp = 1
> >                       endif
> > 
> >                       do k=1,km_tmp
> >                          do j=1,jm
> >                             do i=1,im
> >                                a_en(iaens,n)%r3(ipx)%q(i,j,k)=a_en(iaens,n)%r3(ipx)%q(i,j,k) &
> >                                     +cvec%r2(ipic)%q(i,j)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> >                             enddo
> >                          enddo
> 2180,2181d2241
> <                    enddo
> <                 enddo
> 2183c2243
> <              case('SST')
> ---
> >                    case('SST')
> 2185,2190c2245,2250
> <                 do j=1,jm
> <                    do i=1,im
> <                       a_en(n)%r3(ipx)%q(i,j,1)=a_en(n)%r3(ipx)%q(i,j,1) &
> <                          +cvec%r2(ipic)%q(i,j)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)
> <                    enddo
> <                 enddo
> ---
> >                       do j=1,jm
> >                          do i=1,im
> >                             a_en(iaens,n)%r3(ipx)%q(i,j,1)=a_en(iaens,n)%r3(ipx)%q(i,j,1) &
> >                                  +cvec%r2(ipic)%q(i,j)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)
> >                          enddo
> >                       enddo
> 2192c2252,2254
> <           end select
> ---
> >                 end select
> >              endif ! iaens>0
> >           enddo
> 2241a2304,2305
> >     use hybrid_ensemble_parameters, only: ntotensgrp,naensgrp
> >     use hybrid_ensemble_parameters, only: ensgrp2aensgrp
> 2248c2312
> <     type(gsi_bundle),intent(inout) :: a_en(n_ens)
> ---
> >     type(gsi_bundle),intent(inout) :: a_en(naensgrp,n_ens)
> 2255c2319
> <     integer(i_kind) :: ipc2d(nc2d),ipc3d(nc3d),istatus
> ---
> >     integer(i_kind) :: ipc2d(nc2d),ipc3d(nc3d),istatus,ig,iaens
> 2301,2304c2365,2368
> <     im=a_en(1)%grid%im
> <     jm=a_en(1)%grid%jm
> <     km=a_en(1)%grid%km
> < !$omp parallel do schedule(dynamic,1) private(j,n,ic3,k,i,ic2,ipic)
> ---
> >     im=a_en(1,1)%grid%im
> >     jm=a_en(1,1)%grid%jm
> >     km=a_en(1,1)%grid%km
> > !$omp parallel do schedule(static,1) private(j,n,ic3,k,i,ic2,ipic,ig,iaens)
> 2306,2330c2370,2375
> <        do ic3=1,nc3d
> <           ipic=ipc3d(ic3)
> <           do k=1,km
> <              do j=1,jm
> <                 do i=1,im
> <                    a_en(n)%r3(ipx)%q(i,j,k)=a_en(n)%r3(ipx)%q(i,j,k) &
> <                             +work_ens%r3(ipic)%q(i,j,k)*en_perts(n,ibin)%r3(ipic)%qr4(i,j,k)
> <                 enddo
> <              enddo
> <           enddo
> <        enddo
> <        do ic2=1,nc2d
> < 
> <           ipic=ipc2d(ic2)
> <           select case ( trim(StrUpCase(cvars2d(ic2))) )
> < 
> <              case('PS')
> < 
> <                 if ( pwgtflg ) then
> <                    km_tmp = km
> <                 else
> <                    km_tmp = 1
> <                 endif
> < 
> <                 do k=1,km_tmp
> ---
> >        do ig=1,ntotensgrp
> >           do ic3=1,nc3d
> >              iaens=ensgrp2aensgrp(ig,ic3,ibin)
> >              if(iaens>0) then
> >                 ipic=ipc3d(ic3)
> >                 do k=1,km
> 2333,2334c2378,2379
> <                          a_en(n)%r3(ipx)%q(i,j,k)=a_en(n)%r3(ipx)%q(i,j,k) &
> <                             +work_ens%r2(ipic)%q(i,j)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> ---
> >                          a_en(iaens,n)%r3(ipx)%q(i,j,k)=a_en(iaens,n)%r3(ipx)%q(i,j,k) &
> >                               +work_ens%r3(ipic)%q(i,j,k)*en_perts(n,ig,ibin)%r3(ipic)%qr4(i,j,k)
> 2337a2383,2406
> >              endif ! iaens>0
> >           enddo
> >           do ic2=1,nc2d
> >              iaens=ensgrp2aensgrp(ig,ic2+nc3d,ibin)
> >              if(iaens>0) then
> >                 ipic=ipc2d(ic2)
> >                 select case ( trim(StrUpCase(cvars2d(ic2))) )
> > 
> >                    case('PS')
> > 
> >                       if ( pwgtflg ) then
> >                          km_tmp = km
> >                       else
> >                          km_tmp = 1
> >                       endif
> > 
> >                       do k=1,km_tmp
> >                          do j=1,jm
> >                             do i=1,im
> >                                a_en(iaens,n)%r3(ipx)%q(i,j,k)=a_en(iaens,n)%r3(ipx)%q(i,j,k) &
> >                                     +work_ens%r2(ipic)%q(i,j)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)*pwgt(i,j,k)
> >                             enddo
> >                          enddo
> >                       enddo
> 2339c2408
> <              case('SST')
> ---
> >                    case('SST')
> 2341,2346c2410,2415
> <                 do j=1,jm
> <                    do i=1,im
> <                       a_en(n)%r3(ipx)%q(i,j,1)=a_en(n)%r3(ipx)%q(i,j,1) &
> <                          +work_ens%r2(ipic)%q(i,j)*en_perts(n,ibin)%r2(ipic)%qr4(i,j)
> <                    enddo
> <                 enddo
> ---
> >                       do j=1,jm
> >                          do i=1,im
> >                             a_en(iaens,n)%r3(ipx)%q(i,j,1)=a_en(iaens,n)%r3(ipx)%q(i,j,1) &
> >                                  +work_ens%r2(ipic)%q(i,j)*en_perts(n,ig,ibin)%r2(ipic)%qr4(i,j)
> >                          enddo
> >                       enddo
> 2348c2417,2419
> <           end select
> ---
> >                 end select
> >              endif ! iaens>0
> >           enddo
> 2383,2384c2454,2455
> <     use m_kinds, only: r_kind,i_kind
> <     use m_mpimod, only: npe,mype,gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use kinds, only: r_kind,i_kind
> >     use mpimod, only: npe,mype,mpi_comm_world,ierror,mpi_rtype
> 2482c2553
> <                        z,nrecv_sd2h,ndrecv_sd2h,mpi_rtype,gsi_mpi_comm_world,ierror)
> ---
> >                        z,nrecv_sd2h,ndrecv_sd2h,mpi_rtype,mpi_comm_world,ierror)
> 2493c2564
> <                        z,nrecv_sd2h,ndrecv_sd2h,mpi_rtype,gsi_mpi_comm_world,ierror)
> ---
> >                        z,nrecv_sd2h,ndrecv_sd2h,mpi_rtype,mpi_comm_world,ierror)
> 2528c2599
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 2531c2602
> <   use m_mpimod, only: mpi_rtype,ierror,gsi_mpi_comm_world
> ---
> >   use mpimod, only: mpi_rtype,ierror,mpi_comm_world
> 2554c2625
> <                         work,nrecv_sd2h,ndrecv_sd2h,mpi_rtype,gsi_mpi_comm_world,ierror)
> ---
> >                         work,nrecv_sd2h,ndrecv_sd2h,mpi_rtype,mpi_comm_world,ierror)
> 2591c2662
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 2599d2669
> < #ifdef USE_ALL_ORIGINAL
> 2601d2670
> < #endif /* USE_ALL_ORIGINAL */
> 2616d2684
> < #ifdef USE_ALL_ORIGINAL
> 2618d2685
> < #endif /* USE_ALL_ORIGINAL */
> 2632d2698
> < !$omp parallel do schedule(dynamic,1) private(ic3,ic2,k,j,i,ii)
> 2633a2700
> > !$omp parallel do schedule(static,1) private(ic3,ic2,k,j,i,ii)
> 2662d2728
> < #ifdef USE_ALL_ORIGINAL
> 2664d2729
> < #endif /* USE_ALL_ORIGINAL */
> 2696c2761
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 2703d2767
> < #ifdef USE_ALL_ORIGINAL
> 2705d2768
> < #endif /* USE_ALL_ORIGINAL */
> 2720d2782
> < #ifdef USE_ALL_ORIGINAL
> 2722d2783
> < #endif /* USE_ALL_ORIGINAL */
> 2736d2796
> < !$omp parallel do schedule(dynamic,1) private(ic3,ic2,k,j,i)
> 2737a2798
> > !$omp parallel do schedule(static,1) private(ic3,ic2,k,j,i)
> 2764d2824
> < #ifdef USE_ALL_ORIGINAL
> 2766d2825
> < #endif /* USE_ALL_ORIGINAL */
> 2797c2856
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 2799a2859
> >   use hybrid_ensemble_parameters, only: naensgrp
> 2801d2860
> < #ifdef USE_ALL_ORIGINAL
> 2803d2861
> < #endif /* USE_ALL_ORIGINAL */
> 2814c2872
> <   integer(i_kind) :: i,j,k,ii,nn
> ---
> >   integer(i_kind) :: i,j,k,ii,nn,ig
> 2817d2874
> < #ifdef USE_ALL_ORIGINAL
> 2819d2875
> < #endif /* USE_ALL_ORIGINAL */
> 2821d2876
> < !$omp parallel do schedule(dynamic,1) private(nn,k,j,i,ii)
> 2823c2878,2879
> <   do j=1,grd_ens%lon2
> ---
> > !$omp parallel do schedule(static,1) private(nn,k,j,i,ii,ig)
> >   do nn=1,n_ens
> 2825c2881
> <         do nn=1,n_ens
> ---
> >         do ig=1,naensgrp
> 2827,2828c2883,2886
> <               do i=1,grd_ens%lat2
> <                  grady%aens(ii,nn)%r3(1)%q(i,j,k) = sqrt_beta_e(k)*grady%aens(ii,nn)%r3(1)%q(i,j,k)
> ---
> >               do j=1,grd_ens%lon2
> >                  do i=1,grd_ens%lat2
> >                     grady%aens(ii,ig,nn)%r3(1)%q(i,j,k) = sqrt_beta_e(k)*grady%aens(ii,ig,nn)%r3(1)%q(i,j,k)
> >                  enddo
> 2836d2893
> < #ifdef USE_ALL_ORIGINAL
> 2838d2894
> < #endif /* USE_ALL_ORIGINAL */
> 2869c2925
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 2870a2927
> >   use hybrid_ensemble_parameters, only: naensgrp
> 2872d2928
> < #ifdef USE_ALL_ORIGINAL
> 2874d2929
> < #endif /* USE_ALL_ORIGINAL */
> 2880c2935
> <   type(gsi_bundle),intent(inout) :: aens(n_ens)
> ---
> >   type(gsi_bundle),intent(inout) :: aens(naensgrp,n_ens)
> 2884c2939
> <   integer(i_kind) :: i,j,k,nn
> ---
> >   integer(i_kind) :: i,j,k,nn,ig
> 2887d2941
> < #ifdef USE_ALL_ORIGINAL
> 2889d2942
> < #endif /* USE_ALL_ORIGINAL */
> 2891d2943
> < !$omp parallel do schedule(dynamic,1) private(nn,k,j,i)
> 2893,2894c2945,2947
> <   do j=1,grd_ens%lon2
> <      do nn=1,n_ens
> ---
> > !$omp parallel do schedule(static,1) private(nn,k,j,i,ig)
> >   do nn=1,n_ens
> >      do ig=1,naensgrp
> 2896,2897c2949,2952
> <            do i=1,grd_ens%lat2
> <               aens(nn)%r3(1)%q(i,j,k) = sqrt_beta_e(k)*aens(nn)%r3(1)%q(i,j,k)
> ---
> >            do j=1,grd_ens%lon2
> >               do i=1,grd_ens%lat2
> >                  aens(ig,nn)%r3(1)%q(i,j,k) = sqrt_beta_e(k)*aens(ig,nn)%r3(1)%q(i,j,k)
> >               enddo
> 2904d2958
> < #ifdef USE_ALL_ORIGINAL
> 2906d2959
> < #endif /* USE_ALL_ORIGINAL */
> 2911,2915d2963
> < subroutine destroy_sf_xy
> <     deallocate(nsend_sd2h,ndsend_sd2h,nrecv_sd2h,ndrecv_sd2h)
> <     deallocate(i_recv,k_recv)
> < end subroutine destroy_sf_xy
> < 
> 2941c2989
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> 2943a2992
> >   use hybrid_ensemble_parameters,only: naensgrp,naensloc
> 2948c2997
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 2958,2959c3007,3008
> <   integer(i_kind) i,ii,j,k,l,n,jcap,kk,nsigend
> <   real(r_kind),allocatable::g(:),gsave(:)
> ---
> >   integer(i_kind) i,ii,j,igg,k,l,n,jcap,kk,nsigend,ig
> >   real(r_kind),allocatable::g(:),gtemp(:)
> 2964c3013
> <   real(r_single),allocatable::pn0_npole(:)
> ---
> >   real(r_single) pn0_npole
> 2968c3017
> <   character(8) mapname
> ---
> >   character(5) mapname
> 2970d3018
> <   logical,allocatable,dimension(:)::ksame
> 2984,2993c3032,3043
> <      if(s_ens_hv(k) <  s_ens_h_min) then
> <         if(mype == 0) write(6,*)' s_ens_hv(',k,') = ',s_ens_hv(k),' km--too small, min value = ', &
> <                                         s_ens_h_min,' km.'
> <         if(mype == 0) write(6,*)' s_ens_hv(',k,') reset to min value'
> <         s_ens_hv(k)=s_ens_h_min
> <      else if(s_ens_hv(k) >  5500._r_kind) then
> <         if(mype == 0) write(6,*)' s_ens_hv(',k,') = ',s_ens_hv(k),' km--too large, max value = 5500 km.'
> <         if(mype == 0) write(6,*)' s_ens_hv(',k,') reset to max value'
> <         s_ens_hv(k)=5500._r_kind
> <      end if
> ---
> >      do ig=1,naensloc
> >         if(s_ens_hv(k,ig) <  s_ens_h_min) then
> >            if(mype == 0) write(6,*)' s_ens_hv(',k,') = ',s_ens_hv(k,ig),' km--too small, min value = ', &
> >                                            s_ens_h_min,' km.'
> >            if(mype == 0) write(6,*)' s_ens_hv(',k,') reset to min value'
> >            s_ens_hv(k,ig)=s_ens_h_min
> >         else if(s_ens_hv(k,ig) >  5500._r_kind) then
> >            if(mype == 0) write(6,*)' s_ens_hv(',k,') = ',s_ens_hv(k,ig),' km--too large, max value = 5500 km.'
> >            if(mype == 0) write(6,*)' s_ens_hv(',k,') reset to max value'
> >            s_ens_hv(k,ig)=5500._r_kind
> >         end if
> >      enddo
> 3118,3131c3168,3190
> <   if(.not.allocated(spectral_filter)) allocate(spectral_filter(sp_loc%nc,grd_sploc%nsig))
> <   if(.not.allocated(sqrt_spectral_filter)) allocate(sqrt_spectral_filter(sp_loc%nc,grd_sploc%nsig))
> <   allocate(g(sp_loc%nc),gsave(sp_loc%nc))
> <   allocate(pn0_npole(0:sp_loc%jcap))
> <   allocate(ksame(grd_sploc%nsig))
> <   ksame=.false.
> <   do k=2,grd_sploc%nsig
> <      if(s_ens_hv(k) == s_ens_hv(k-1))ksame(k)=.true.
> <   enddo
> <   spectral_filter=zero
> <   do k=1,grd_sploc%nsig
> <      if(ksame(k))then
> <         spectral_filter(:,k)=spectral_filter(:,k-1)
> <      else
> ---
> >   if(.not.allocated(spectral_filter)) allocate(spectral_filter(naensloc,sp_loc%nc,grd_sploc%nsig))
> >   if(.not.allocated(sqrt_spectral_filter)) allocate(sqrt_spectral_filter(naensloc,sp_loc%nc,grd_sploc%nsig))
> >   allocate(g(sp_loc%nc),gtemp(sp_loc%nc))
> >   do ig=1,naensloc
> >      spectral_filter(ig,:,:)=zero
> >      level_loop: do k=1,grd_sploc%nsig
> >         do kk=1,k-1
> >            if(s_ens_hv(k,ig) == s_ens_hv(kk,ig))then
> >               spectral_filter(ig,:,k)=spectral_filter(ig,:,k-1)
> >               cycle level_loop
> >            end if
> >         end do
> >         if(ig > 1)then
> >            do igg=1,ig-1
> >               do kk=1,grd_sploc%nsig
> >                  if(s_ens_hv(k,ig) == s_ens_hv(kk,igg))then
> >                     spectral_filter(ig,:,k)=spectral_filter(igg,:,kk)
> >                     cycle level_loop
> >                  end if
> >               end do
> >            end do
> >         end if
> > 
> 3133c3192
> <            f0(i,1)=exp(-half*(rkm(i)/s_ens_hv(k))**2)
> ---
> >            f0(i,1)=exp(-half*(rkm(i)/s_ens_hv(k,ig))**2)
> 3135a3195
> > 
> 3140c3200,3201
> <         enddo
> ---
> >         end do
> > 
> 3154c3215
> <               if(s_ens_hv(kk) /= s_ens_hv(k))exit
> ---
> >               if(s_ens_hv(kk,ig) /= s_ens_hv(k,ig))exit
> 3157,3159c3218,3220
> <            write(6,900)k,nsigend,sp_loc%jcap,s_ens_hv(k),maxval(abs(f0-f))
> <   900      format(' in init_sf_xy, jcap,s_ens_hv(',i5,1x,'-',i5,'), max diff(f0-f)=', &
> <                                         i10,f10.2,e20.10)
> ---
> >            write(6,900)k,nsigend,sp_loc%jcap,s_ens_hv(k,ig),maxval(abs(f0-f))
> > 900        format(' in init_sf_xy, jcap,s_ens_hv(',i5,1x,'-',i5,'), max diff(f0-f)=', &
> >                                            i10,f10.2,e20.10)
> 3162,3163c3223
> < !            correct spectrum by dividing by pn0_npole
> <         gsave=g
> ---
> > !       correct spectrum by dividing by pn0_npole
> 3165a3226
> > !$omp parallel do schedule(static,1) private(n,gtemp,f)
> 3167,3170c3228,3232
> <            g=zero
> <            g(2*n+1)=one
> <            call general_s2g0(grd_sploc,sp_loc,g,f)
> <            pn0_npole(n)=f(grd_sploc%nlat,1)
> ---
> >            gtemp=zero
> >            gtemp(2*n+1)=one
> >            call general_s2g0(grd_sploc,sp_loc,gtemp,f)
> >            pn0_npole=f(grd_sploc%nlat,1)
> >            g(2*n+1)=g(2*n+1)/pn0_npole
> 3173,3176d3234
> <         g=zero
> <         do n=0,sp_loc%jcap
> <            g(2*n+1)=gsave(2*n+1)/pn0_npole(n)
> <         enddo
> 3182,3183c3240,3245
> <            factor=one
> <            if(l >  0) factor=half
> ---
> >            if(ig>naensgrp) then
> >               factor=one/g(1)
> >            else
> >               factor=one
> >               if(l>0) factor=half
> >            end if
> 3187c3249
> <                  spectral_filter(ii,k)=zero
> ---
> >                  spectral_filter(ig,ii,k)=zero
> 3189c3251
> <                  spectral_filter(ii,k)=factor*g(2*n+1)
> ---
> >                  spectral_filter(ig,ii,k)=factor*g(2*n+1)
> 3193c3255
> <                  spectral_filter(ii,k)=zero
> ---
> >                  spectral_filter(ig,ii,k)=zero
> 3195c3257
> <                  spectral_filter(ii,k)=factor*g(2*n+1)
> ---
> >                  spectral_filter(ig,ii,k)=factor*g(2*n+1)
> 3199,3201c3261,3263
> <      end if
> <   enddo
> <   deallocate(g,gsave,pn0_npole,ksame)
> ---
> >      enddo level_loop
> >   enddo !ig loop
> >   deallocate(g,gtemp)
> 3204,3208c3266,3272
> < !$omp parallel do schedule(dynamic,1) private(k,i)
> <   do k=1,grd_sploc%nsig
> <      do i=1,sp_loc%nc
> <         if (spectral_filter(i,k) < zero) spectral_filter(i,k)=zero
> <         sqrt_spectral_filter(i,k) = sqrt(spectral_filter(i,k))
> ---
> > !$omp parallel do schedule(static,1) private(k,i)
> >   do ig=1,naensloc
> >      do k=1,grd_sploc%nsig
> >         do i=1,sp_loc%nc
> >            spectral_filter(ig,i,k) = max(spectral_filter(ig,i,k),zero)
> >            sqrt_spectral_filter(ig,i,k) = sqrt(spectral_filter(ig,i,k))
> >         end do
> 3210c3274
> <   end do
> ---
> >   enddo !ig loop
> 3226c3290
> <    call sf_xy(ftest,grd_loc%kbegin_loc,grd_loc%kend_loc)
> ---
> >    call sf_xy(1,ftest,grd_loc%kbegin_loc,grd_loc%kend_loc)
> 3233c3297
> <      write(mapname,'("out_",i4.4)')1+mod(grd_loc%kbegin_loc-1,grd_ens%nsig)
> ---
> >      write(mapname,'("out_",i2.2)')1+mod(grd_loc%kbegin_loc-1,grd_ens%nsig)
> 3242c3306
> < subroutine sf_xy(f,k_start,k_end)
> ---
> > subroutine sf_xy(ig,f,k_start,k_end)
> 3256a3321
> > !     ig       - number for smoothing scales
> 3272c3337
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3275c3340,3341
> <   use egrid2agrid_mod,only: g_egrid2agrid,g_egrid2agrid_ad  
> ---
> >   use hybrid_ensemble_parameters,only: naensgrp
> >   use egrid2agrid_mod,only: g_egrid2agrid,g_egrid2agrid_ad,g_agrid2egrid
> 3277a3344
> >   integer(i_kind),intent(in   ) :: ig
> 3280a3348
> >   real(r_kind) g(sp_loc%nc)
> 3287,3290c3355,3367
> < !$omp parallel do schedule(dynamic,1) private(k)
> <     do k=k_start,k_end
> <        call sfilter(grd_ens,sp_loc,spectral_filter(1,k_index(k)),f(1,1,k))
> <     enddo
> ---
> >     if(ig>naensgrp) then
> > !$omp parallel do schedule(static,1) private(k,g)
> >        do k=k_start,k_end
> >           call general_g2s0(grd_ens,sp_loc,g,f(:,:,k))
> >           g(:)=g(:)*spectral_filter(ig,:,k_index(k))
> >           call general_s2g0(grd_ens,sp_loc,g,f(:,:,k))
> >        enddo
> >     else
> > !$omp parallel do schedule(static,1) private(k)
> >        do k=k_start,k_end
> >           call sfilter(grd_ens,sp_loc,spectral_filter(ig,:,k_index(k)),f(1,1,k))
> >        enddo
> >     endif
> 3295,3300c3372,3388
> < !$omp parallel do schedule(dynamic,1) private(k,work)
> <     do k=k_start,k_end
> <        call g_egrid2agrid_ad(p_sploc2ens,work,f(:,:,k:k),k,k,vector(k:k))
> <        call sfilter(grd_ens,sp_loc,spectral_filter(:,k_index(k)),f(1,1,k))
> <        call g_egrid2agrid(p_sploc2ens,work,f(:,:,k:k),k,k,vector(k:k))
> <     enddo
> ---
> >     if(ig>naensgrp) then
> > !$omp parallel do schedule(static,1) private(k,g,work)
> >        do k=k_start,k_end
> >           call g_agrid2egrid(p_sploc2ens,work,f(:,:,k:k),k,k,vector(k:k))
> >           call general_g2s0(grd_ens,sp_loc,g,f(:,:,k))
> >           g(:)=g(:)*spectral_filter(ig,:,k_index(k))
> >           call general_s2g0(grd_ens,sp_loc,g,f(:,:,k))
> >           call g_egrid2agrid(p_sploc2ens,work,f(:,:,k:k),k,k,vector(k:k))
> >        enddo
> >     else
> > !$omp parallel do schedule(static,1) private(k,work)
> >        do k=k_start,k_end
> >           call g_egrid2agrid_ad(p_sploc2ens,work,f(:,:,k:k),k,k,vector(k:k))
> >           call sfilter(grd_ens,sp_loc,spectral_filter(ig,:,k_index(k)),f(1,1,k))
> >           call g_egrid2agrid(p_sploc2ens,work,f(:,:,k:k),k,k,vector(k:k))
> >        enddo
> >     end if
> 3307c3395
> < subroutine sqrt_sf_xy(z,f,k_start,k_end)
> ---
> > subroutine sqrt_sf_xy(ig,z,f,k_start,k_end)
> 3319a3408
> > !     ig       - number for smoothing scales
> 3335c3424
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3340a3430
> >   integer(i_kind),intent(in   ) :: ig
> 3351a3442
> > !$omp parallel do schedule(static,1) private(k,g)
> 3353c3444
> <        g(:)=z(:,k)*sqrt_spectral_filter(:,k_index(k))
> ---
> >        g(:)=z(:,k)*sqrt_spectral_filter(ig,:,k_index(k))
> 3359a3451
> > !$omp parallel do schedule(static,1) private(k,g,work)
> 3361c3453
> <         g(:)=z(:,k)*sqrt_spectral_filter(:,k_index(k))
> ---
> >         g(:)=z(:,k)*sqrt_spectral_filter(ig,:,k_index(k))
> 3371c3463
> < subroutine sqrt_sf_xy_ad(z,f,k_start,k_end)
> ---
> > subroutine sqrt_sf_xy_ad(ig,z,f,k_start,k_end)
> 3383a3476
> > !     ig       - number for smoothing scales
> 3399c3492
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3405a3499
> >   integer(i_kind),intent(in   ) :: ig
> 3416a3511
> > !$omp parallel do schedule(static,1) private(k,g)
> 3419c3514
> <        z(:,k)=g(:)*sqrt_spectral_filter(:,k_index(k))
> ---
> >        z(:,k)=g(:)*sqrt_spectral_filter(ig,:,k_index(k))
> 3424a3520
> > !$omp parallel do schedule(static,1) private(k,g,work)
> 3428c3524
> <         z(:,k)=g(:)*sqrt_spectral_filter(:,k_index(k))
> ---
> >         z(:,k)=g(:)*sqrt_spectral_filter(ig,:,k_index(k))
> 3465c3561
> <   use m_kinds, only: r_kind,i_kind,r_double
> ---
> >   use kinds, only: r_kind,i_kind,r_double
> 3494c3590
> < subroutine bkerror_a_en(gradx,grady)
> ---
> > subroutine bkerror_a_en(grady)
> 3505a3602
> > !   2022-09-15  yokota   add scale/variable/time-dependent localization
> 3508c3605
> < !     gradx    - input field  
> ---
> > !     grady    - input field  
> 3511c3608
> < !     grady    - background structure * gradx 
> ---
> > !     grady    - background structure * grady 
> 3518,3519c3615,3617
> <   use m_kinds, only: r_kind,i_kind
> <   use gsi_4dvar, only: nsubwin, lsqrtb
> ---
> >   use kinds, only: r_kind,i_kind
> >   use constants, only: zero
> >   use gsi_4dvar, only: nsubwin
> 3521d3618
> < #ifdef USE_ALL_ORIGINAL
> 3523d3619
> < #endif /* USE_ALL_ORIGINAL */
> 3524a3621,3622
> >   use hybrid_ensemble_parameters, only: naensgrp
> >   use hybrid_ensemble_parameters, only: alphacvarsclgrpmat
> 3529d3626
> <   type(control_vector),intent(inout) :: gradx
> 3533,3538c3630,3632
> <   integer(i_kind) ii,nn,ip,istatus
> < 
> <   if (lsqrtb) then
> <      write(6,*)'bkerror_a_en: not for use with lsqrtb'
> <      call stop2(317)
> <   end if
> ---
> >   integer(i_kind) ii,ip,istatus,k,ig,ig2
> >   real(r_kind),allocatable,dimension(:,:) :: z
> >   real(r_kind),allocatable,dimension(:) :: z2
> 3541d3634
> < #ifdef USE_ALL_ORIGINAL
> 3543d3635
> < #endif /* USE_ALL_ORIGINAL */
> 3546c3638
> <   call gsi_bundlegetpointer ( grady%aens(1,1),'a_en',ip,istatus)
> ---
> >   call gsi_bundlegetpointer ( grady%aens(1,1,1),'a_en',ip,istatus)
> 3551,3556d3642
> < !$omp parallel do schedule(dynamic,1) private(nn,ii)
> <   do nn=1,n_ens
> <      do ii=1,nsubwin
> <         grady%aens(ii,nn)%r3(ip)%q=gradx%aens(ii,nn)%r3(ip)%q
> <      enddo
> <   enddo
> 3562,3573c3648,3670
> <   do ii=1,nsubwin
> <     !if(test_sqrt_localization) then
> <     !        write(6,*)' using ckgcov_a_en_new_factorization'
> <     !   allocate(z(nval_lenz_en))
> <     !   call ckgcov_a_en_new_factorization_ad(z,grady%aens(ii,1:n_ens))
> <     !   call ckgcov_a_en_new_factorization   (z,grady%aens(ii,1:n_ens))
> <     !   deallocate(z)
> <     !else
> <     !        write(6,*)' using bkgcov_a_en_new_factorization'
> <         call bkgcov_a_en_new_factorization(grady%aens(ii,1:n_ens))
> <     !end if
> <   enddo
> ---
> >   if (naensgrp==1) then
> >      do ii=1,nsubwin
> >         call bkgcov_a_en_new_factorization(1,grady%aens(ii,1,1:n_ens))
> >      end do
> >   else
> >      allocate(z(nval_loc_en,naensgrp))
> >      allocate(z2(nval_loc_en))
> >      do ii=1,nsubwin
> >         do ig=1,naensgrp
> >            call ckgcov_a_en_new_factorization_ad(ig,z(1,ig),grady%aens(ii,ig,1:n_ens))
> >         enddo
> >         do ig=1,naensgrp
> >            z2=zero
> >            do ig2=1,naensgrp
> >               do k=1,nval_loc_en
> >                  z2(k) = z2(k) + z(k,ig2) * alphacvarsclgrpmat(ig,ig2)  
> >               enddo
> >            enddo
> >            call ckgcov_a_en_new_factorization(ig,z2,grady%aens(ii,ig,1:n_ens))
> >         enddo
> >      enddo
> >      deallocate(z,z2)
> >   endif
> 3579d3675
> < #ifdef USE_ALL_ORIGINAL
> 3581d3676
> < #endif /* USE_ALL_ORIGINAL */
> 3586c3681
> < subroutine bkgcov_a_en_new_factorization(a_en)
> ---
> > subroutine bkgcov_a_en_new_factorization(ig,a_en)
> 3602a3698
> > !     ig       - number for smoothing scales
> 3614c3710
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3616a3713
> >   use hybrid_ensemble_parameters, only: l_mgbf_loc,naensgrp
> 3619a3717
> >   use constants, only: zero
> 3624a3723
> >   integer(i_kind),intent(in   ) :: ig
> 3628c3727
> <   integer(i_kind) ii,k,iflg,iadvance,iback,is,ie,ipnt,istatus
> ---
> >   integer(i_kind) ii,k,iadvance,iback,is,ie,ipnt,istatus
> 3632c3731
> <   iflg=1
> ---
> >   ipnt=1
> 3634,3638c3733,3776
> <   call gsi_bundlegetpointer(a_en(1),'a_en',ipnt,istatus)
> <   if(istatus/=0) then
> <      write(6,*)'bkgcov_a_en_new_factorization: trouble getting pointer to ensemble CV'
> <      call stop2(999)
> <   endif
> ---
> > ! MGBF-based localization (now available only in regional=.true.)
> > !  (Note that MGBF is applied only in ig<=naensgrp
> > !   because recursive filter is applied for ig>naensgrp
> > !   to separate scales for scale-dependent localization
> > !   even in MGBF-based localization)
> >   if(l_mgbf_loc.and.ig<=naensgrp) then
> > 
> > ! Apply vertical smoother on each ensemble member
> >      allocate(work_mgbf(obj_mgbf(1)%km_a_all,obj_mgbf(1)%nm,obj_mgbf(1)%mm))
> >      work_mgbf=zero
> >      iadvance=1 ; iback=2
> > !$omp parallel do schedule(static,1) private(k,ii,is,ie)
> >      do k=1,n_ens
> >         ii=(k-1)*grd_loc%nsig
> >         is=ii+1
> >         ie=ii+grd_loc%nsig
> >         if(.not.obj_mgbf(1)%l_vertical_filter) call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,1)
> >         call map_work_mgbf(a_en(k)%r3(ipnt)%q,work_mgbf(is:ie,:,:),iadvance,1)
> >      enddo
> > 
> > ! Mapping from analysis grid to filter grid
> >      call obj_mgbf(1)%anal_to_filt_allmap(work_mgbf)
> > 
> > ! Apply horizontal smoother for number of horizontal scales
> >      call obj_mgbf(1)%filtering_procedure(obj_mgbf(1)%mgbf_proc,0)
> > 
> > ! Mapping from filter grid to analysis grid
> >      call obj_mgbf(1)%filt_to_anal_allmap(work_mgbf)
> > 
> > ! Apply vertical smoother on each ensemble member
> >      iadvance=2 ; iback=1
> > !$omp parallel do schedule(static,1) private(k,ii,is,ie)
> >      do k=1,n_ens
> >         ii=(k-1)*grd_loc%nsig
> >         is=ii+1
> >         ie=ii+grd_loc%nsig
> >         call map_work_mgbf(a_en(k)%r3(ipnt)%q,work_mgbf(is:ie,:,:),iadvance,1)
> >         if(.not.obj_mgbf(1)%l_vertical_filter) call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,1)
> >      enddo
> >      deallocate(work_mgbf)
> > 
> > ! Recursive/Spectral filter-based localization(ig<=naensgrp)
> > ! or scale-separation(ig>naensgrp)
> >   else
> 3643,3656c3781,3794
> <   allocate(a_en_work(n_ens*a_en(1)%ndim),stat=istatus)
> <   if(istatus/=0) then
> <      write(6,*)'bkgcov_a_en_new_factorization: trouble in alloc(a_en_work)'
> <      call stop2(999)
> <   endif
> <   iadvance=1 ; iback=2
> < !$omp parallel do schedule(dynamic,1) private(k,ii,is,ie)
> <   do k=1,n_ens
> <      call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback)
> <      ii=(k-1)*a_en(1)%ndim
> <      is=ii+1
> <      ie=ii+a_en(1)%ndim
> <      a_en_work(is:ie)=a_en(k)%values(1:a_en(k)%ndim)
> <   enddo
> ---
> >      allocate(a_en_work(n_ens*a_en(1)%ndim),stat=istatus)
> >      if(istatus/=0) then
> >         write(6,*)'bkgcov_a_en_new_factorization: trouble in alloc(a_en_work)'
> >         call stop2(999)
> >      endif
> >      iadvance=1 ; iback=2
> > !$omp parallel do schedule(static,1) private(k,ii,is,ie)
> >      do k=1,n_ens
> >         call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,ig)
> >         ii=(k-1)*a_en(1)%ndim
> >         is=ii+1
> >         ie=ii+a_en(1)%ndim
> >         a_en_work(is:ie)=a_en(k)%values(1:a_en(k)%ndim)
> >      enddo
> 3659c3797
> <   call general_sub2grid(grd_loc,a_en_work,hwork)
> ---
> >      call general_sub2grid(grd_loc,a_en_work,hwork)
> 3662,3671c3800,3809
> <   if(regional) then
> <      iadvance=1 ; iback=2
> <      call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <      call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <      iadvance=2 ; iback=1
> <      call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <      call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <   else
> <      call sf_xy(hwork,grd_loc%kbegin_loc,grd_loc%kend_loc)
> <   end if
> ---
> >      if(regional) then
> >         iadvance=1 ; iback=2
> >         call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >         call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >         iadvance=2 ; iback=1
> >         call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >         call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >      else
> >         call sf_xy(ig,hwork,grd_loc%kbegin_loc,grd_loc%kend_loc)
> >      end if
> 3674c3812
> <   call general_grid2sub(grd_loc,hwork,a_en_work)
> ---
> >      call general_grid2sub(grd_loc,hwork,a_en_work)
> 3678,3687c3816,3827
> <   iadvance=2 ; iback=1
> < !$omp parallel do schedule(dynamic,1) private(k,ii,is,ie)
> <   do k=1,n_ens
> <      ii=(k-1)*a_en(1)%ndim
> <      is=ii+1
> <      ie=ii+a_en(1)%ndim
> <      a_en(k)%values(1:a_en(k)%ndim)=a_en_work(is:ie)
> <      call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback)
> <   enddo
> <   deallocate(a_en_work)
> ---
> >      iadvance=2 ; iback=1
> > !$omp parallel do schedule(static,1) private(k,ii,is,ie)
> >      do k=1,n_ens
> >         ii=(k-1)*a_en(1)%ndim
> >         is=ii+1
> >         ie=ii+a_en(1)%ndim
> >         a_en(k)%values(1:a_en(k)%ndim)=a_en_work(is:ie)
> >         call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,ig)
> >      enddo
> >      deallocate(a_en_work)
> > 
> >   endif
> 3692c3832
> < subroutine ckgcov_a_en_new_factorization(z,a_en)
> ---
> > subroutine ckgcov_a_en_new_factorization(ig,z,a_en)
> 3703a3844
> > !     ig       - number for smoothing scales
> 3714c3855
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3718c3859
> <   use hybrid_ensemble_parameters, only: nval_lenz_en
> ---
> >   use hybrid_ensemble_parameters, only: l_mgbf_loc
> 3725a3867
> >   integer(i_kind),intent(in   ) :: ig
> 3727c3869,3881
> <   real(r_kind),dimension(nval_lenz_en),intent(in   ) :: z
> ---
> >   real(r_kind),dimension(nval_loc_en),intent(in   ) :: z
> > !NOTE:
> > ! nval_loc_en is the number of horizontally-filtered variables in the domain of each processor.
> > ! In MGBF-based localization, it is horizontally-local and vertically-global as
> > !   nval_loc_en = nhoriz * obj_mgbf(ig)%km_all
> > !      and nhoriz = ( obj_mgbf(ig)%im + obj_mgbf(ig)%hx*2 ) * ( obj_mgbf(ig)%jm + obj_mgbf(ig)%hy*2 )
> > ! In recursive/spectral filter-based localization, it is horizontally-global and vertically-local as
> > !   nval_loc_en = nhoriz * ( grd_loc%kend_alloc - grd_loc%kbegin_loc + 1 )
> > !      and nhoriz =  grd_loc%nlat     *  grd_loc%nlon     (for regional recursive filter)
> > !          nhoriz = ( sp_loc%jcap+1 ) * ( sp_loc%jcap+2 ) (for global spectral filter)
> > ! but internal array hwork always has
> > ! dimension grd_loc%nlat * grd_loc%nlon * ( grd_loc%kend_alloc - grd_loc%kbegin_loc + 1 )
> > ! which would be used as nval_loc_en when the recursive filter is used.
> 3730c3884
> <   integer(i_kind) ii,k,iadvance,iback,is,ie,ipnt,istatus
> ---
> >   integer(i_kind) ii,i,j,k,iadvance,iback,is,ie,ipnt,istatus
> 3732,3737d3885
> < !NOTE:   nval_lenz_en = nhoriz*(grd_loc%kend_alloc-grd_loc%kbegin_loc+1)
> < !      and nhoriz = grd_loc%nlat*grd_loc%nlon for regional,
> < !          nhoriz = (sp_loc%jcap+1)*(sp_loc%jcap+2) for global
> < !   but internal array hwork always has
> < !      dimension grd_loc%nlat*grd_loc%nlon*(grd_loc%kend_alloc-grd_loc%kbegin_loc+1)
> < !    which just happens to match up with nval_lenz_en for regional case, but not global.
> 3745a3894,3927
> > ! MGBF-based localization (now available only in regional=.true.)
> >   if(l_mgbf_loc) then
> > 
> > ! Apply horizontal smoother for number of horizontal scales
> >      ii=0
> >      do k=1,obj_mgbf(ig)%km_all
> >         do j=1-obj_mgbf(ig)%hy,obj_mgbf(ig)%jm+obj_mgbf(ig)%hy
> >            do i=1-obj_mgbf(ig)%hx,obj_mgbf(ig)%im+obj_mgbf(ig)%hx
> >               ii=ii+1
> >               obj_mgbf(ig)%VALL(k,i,j)=z(ii)
> >            enddo
> >         enddo
> >      enddo
> >      call obj_mgbf(ig)%filtering_procedure(obj_mgbf(ig)%mgbf_proc,1)
> > 
> > ! Mapping from filter grid to analysis grid
> >      allocate(work_mgbf(obj_mgbf(ig)%km_a_all,obj_mgbf(ig)%nm,obj_mgbf(ig)%mm))
> >      work_mgbf=zero
> >      call obj_mgbf(ig)%filt_to_anal_allmap(work_mgbf)
> > 
> > ! Apply vertical smoother on each ensemble member
> >      iadvance=2 ; iback=1
> > !$omp parallel do schedule(static,1) private(k,ii,is,ie)
> >      do k=1,n_ens
> >         ii=(k-1)*grd_loc%nsig
> >         is=ii+1
> >         ie=ii+grd_loc%nsig
> >         call map_work_mgbf(a_en(k)%r3(ipnt)%q,work_mgbf(is:ie,:,:),iadvance,ig)
> >         if(.not.obj_mgbf(ig)%l_vertical_filter) call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,ig)
> >      enddo
> >      deallocate(work_mgbf)
> > 
> > ! Recursive/Spectral filter-based localization
> >   else
> 3747c3929
> <   if(grd_loc%kend_loc+1-grd_loc%kbegin_loc==0) then
> ---
> >      if(grd_loc%kend_loc+1-grd_loc%kbegin_loc==0) then
> 3750,3751c3932,3933
> <      hwork=zero
> <   else
> ---
> >         hwork=zero
> >      else
> 3753c3935
> <      if(regional) then
> ---
> >         if(regional) then
> 3755,3759c3937,3941
> <         hwork=z
> <         iadvance=2 ; iback=1
> <         call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <         call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <      else
> ---
> >            hwork=z
> >            iadvance=2 ; iback=1
> >            call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >            call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >         else
> 3761c3943
> <         call sqrt_sf_xy(z,hwork,grd_loc%kbegin_loc,grd_loc%kend_loc)
> ---
> >            call sqrt_sf_xy(ig,z,hwork,grd_loc%kbegin_loc,grd_loc%kend_loc)
> 3763c3945
> <         write(6,*) ' problem with ibm compiler with "use hybrid_ensemble_isotropic, only: sqrt_sf_xy"'
> ---
> >            write(6,*) ' problem with ibm compiler with "use hybrid_ensemble_isotropic, only: sqrt_sf_xy"'
> 3764a3947
> >         end if
> 3766d3948
> <   end if
> 3769,3774c3951,3956
> <   allocate(a_en_work(n_ens*a_en(1)%ndim),stat=istatus)
> <   if(istatus/=0) then
> <      write(6,*)'ckgcov_a_en_new_factorization: trouble in alloc(a_en_work)'
> <      call stop2(999)
> <   endif
> <   call general_grid2sub(grd_loc,hwork,a_en_work)
> ---
> >      allocate(a_en_work(n_ens*a_en(1)%ndim),stat=istatus)
> >      if(istatus/=0) then
> >         write(6,*)'ckgcov_a_en_new_factorization: trouble in alloc(a_en_work)'
> >         call stop2(999)
> >      endif
> >      call general_grid2sub(grd_loc,hwork,a_en_work)
> 3777,3784c3959,3966
> <   ii=0
> <   do k=1,n_ens
> <      is=ii+1
> <      ie=ii+a_en(1)%ndim
> <      a_en(k)%values(1:a_en(k)%ndim)=a_en_work(is:ie)
> <      ii=ii+a_en(1)%ndim
> <   enddo
> <   deallocate(a_en_work)
> ---
> >      ii=0
> >      do k=1,n_ens
> >         is=ii+1
> >         ie=ii+a_en(1)%ndim
> >         a_en(k)%values(1:a_en(k)%ndim)=a_en_work(is:ie)
> >         ii=ii+a_en(1)%ndim
> >      enddo
> >      deallocate(a_en_work)
> 3787,3788d3968
> <   do k=1,n_ens
> < 
> 3790c3970,3971
> <      call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback)
> ---
> > !$omp parallel do schedule(static,1) private(k)
> >      do k=1,n_ens
> 3792c3973,3977
> <   enddo
> ---
> >         call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,ig)
> > 
> >      enddo
> > 
> >   endif
> 3797c3982
> < subroutine ckgcov_a_en_new_factorization_ad(z,a_en)
> ---
> > subroutine ckgcov_a_en_new_factorization_ad(ig,z,a_en)
> 3810a3996
> > !     ig       - number for smoothing scales
> 3824c4010
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3828c4014
> <   use hybrid_ensemble_parameters, only: nval_lenz_en
> ---
> >   use hybrid_ensemble_parameters, only: l_mgbf_loc
> 3835a4022
> >   integer(i_kind),intent(in   ) :: ig
> 3837c4024,4036
> <   real(r_kind),dimension(nval_lenz_en),intent(inout) :: z
> ---
> >   real(r_kind),dimension(nval_loc_en),intent(inout) :: z
> > !NOTE:
> > ! nval_loc_en is the number of horizontally-filtered variables in the domain of each processor.
> > ! In MGBF-based localization, it is horizontally-local and vertically-global as
> > !   nval_loc_en = nhoriz * obj_mgbf(ig)%km_all
> > !      and nhoriz = ( obj_mgbf(ig)%im + obj_mgbf(ig)%hx*2 ) * ( obj_mgbf(ig)%jm + obj_mgbf(ig)%hy*2 )
> > ! In recursive/spectral filter-based localization, it is horizontally-global and vertically-local as
> > !   nval_loc_en = nhoriz * ( grd_loc%kend_alloc - grd_loc%kbegin_loc + 1 )
> > !      and nhoriz =  grd_loc%nlat     *  grd_loc%nlon     (for regional recursive filter)
> > !          nhoriz = ( sp_loc%jcap+1 ) * ( sp_loc%jcap+2 ) (for global spectral filter)
> > ! but internal array hwork always has
> > ! dimension grd_loc%nlat * grd_loc%nlon * ( grd_loc%kend_alloc - grd_loc%kbegin_loc + 1 )
> > ! which would be used as nval_loc_en when the recursive filter is used.
> 3840c4039
> <   integer(i_kind) ii,k,iadvance,iback,is,ie,ipnt,istatus
> ---
> >   integer(i_kind) ii,i,j,k,iadvance,iback,is,ie,ipnt,istatus
> 3842,3847d4040
> < !NOTE:   nval_lenz_en = nhoriz*(grd_loc%kend_alloc-grd_loc%kbegin_loc+1)
> < !      and nhoriz = grd_loc%nlat*grd_loc%nlon for regional,
> < !          nhoriz = (sp_loc%jcap+1)*(sp_loc%jcap+2) for global
> < !   but internal array hwork always has
> < !      dimension grd_loc%nlat*grd_loc%nlon*(grd_loc%kend_alloc-grd_loc%kbegin_loc+1)
> < !    which just happens to match up with nval_lenz_en for regional case, but not global.
> 3855a4049,4051
> > ! MGBF-based localization (now available only in regional=.true.)
> >   if(l_mgbf_loc) then
> > 
> 3857c4053,4063
> <   do k=1,n_ens
> ---
> >      allocate(work_mgbf(obj_mgbf(ig)%km_a_all,obj_mgbf(ig)%nm,obj_mgbf(ig)%mm))
> >      work_mgbf=zero
> >      iadvance=1 ; iback=2
> > !$omp parallel do schedule(static,1) private(k,ii,is,ie)
> >      do k=1,n_ens
> >         ii=(k-1)*grd_loc%nsig
> >         is=ii+1
> >         ie=ii+grd_loc%nsig
> >         if(.not.obj_mgbf(ig)%l_vertical_filter) call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,ig)
> >         call map_work_mgbf(a_en(k)%r3(ipnt)%q,work_mgbf(is:ie,:,:),iadvance,ig)
> >      enddo
> 3858a4065,4084
> > ! Mapping from analysis grid to filter grid
> >      call obj_mgbf(ig)%anal_to_filt_allmap(work_mgbf)
> >      deallocate(work_mgbf)
> > 
> > ! Apply horizontal smoother for number of horizontal scales
> >      call obj_mgbf(ig)%filtering_procedure(obj_mgbf(ig)%mgbf_proc,-1)
> >      ii=0
> >      do k=1,obj_mgbf(ig)%km_all
> >         do j=1-obj_mgbf(ig)%hy,obj_mgbf(ig)%jm+obj_mgbf(ig)%hy
> >            do i=1-obj_mgbf(ig)%hx,obj_mgbf(ig)%im+obj_mgbf(ig)%hx
> >               ii=ii+1
> >               z(ii)=obj_mgbf(ig)%VALL(k,i,j)
> >            enddo
> >         enddo
> >      enddo
> > 
> > ! Recursive/Spectral filter-based localization
> >   else
> > 
> > ! Apply vertical smoother on each ensemble member
> 3860,3862c4086,4091
> <      call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback)
> <  
> <   enddo
> ---
> > !$omp parallel do schedule(static,1) private(k)
> >      do k=1,n_ens
> > 
> >         call new_factorization_rf_z(a_en(k)%r3(ipnt)%q,iadvance,iback,ig)
> > 
> >      enddo
> 3866,3877c4095,4106
> <   allocate(a_en_work(n_ens*a_en(1)%ndim),stat=istatus)
> <   if(istatus/=0) then
> <      write(6,*)'ckgcov_a_en_new_factorization_ad: trouble in alloc(a_en_work)'
> <      call stop2(999)
> <   endif
> <   ii=0
> <   do k=1,n_ens
> <      is=ii+1
> <      ie=ii+a_en(1)%ndim
> <      a_en_work(is:ie)=a_en(k)%values(1:a_en(k)%ndim)
> <      ii=ii+a_en(1)%ndim
> <   enddo
> ---
> >      allocate(a_en_work(n_ens*a_en(1)%ndim),stat=istatus)
> >      if(istatus/=0) then
> >         write(6,*)'ckgcov_a_en_new_factorization_ad: trouble in alloc(a_en_work)'
> >         call stop2(999)
> >      endif
> >      ii=0
> >      do k=1,n_ens
> >         is=ii+1
> >         ie=ii+a_en(1)%ndim
> >         a_en_work(is:ie)=a_en(k)%values(1:a_en(k)%ndim)
> >         ii=ii+a_en(1)%ndim
> >      enddo
> 3880,3881c4109,4110
> <   call general_sub2grid(grd_loc,a_en_work,hwork)
> <   deallocate(a_en_work)
> ---
> >      call general_sub2grid(grd_loc,a_en_work,hwork)
> >      deallocate(a_en_work)
> 3883c4112
> <   if(grd_loc%kend_loc+1-grd_loc%kbegin_loc==0) then
> ---
> >      if(grd_loc%kend_loc+1-grd_loc%kbegin_loc==0) then
> 3886,3893c4115
> <      z=zero
> <   else
> < ! Apply horizontal smoother for number of horizontal scales
> <      if(regional) then
> <         iadvance=1 ; iback=2
> <         call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <         call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc)
> <         z=hwork
> ---
> >         z=zero
> 3895c4117,4125
> <         call sqrt_sf_xy_ad(z,hwork,grd_loc%kbegin_loc,grd_loc%kend_loc)
> ---
> > ! Apply horizontal smoother for number of horizontal scales
> >         if(regional) then
> >            iadvance=1 ; iback=2
> >            call new_factorization_rf_x(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >            call new_factorization_rf_y(hwork,iadvance,iback,grd_loc%kend_loc+1-grd_loc%kbegin_loc,ig)
> >            z=hwork
> >         else
> >            call sqrt_sf_xy_ad(ig,z,hwork,grd_loc%kbegin_loc,grd_loc%kend_loc)
> >         end if
> 3897c4127,4128
> <   end if
> ---
> > 
> >   endif
> 3901a4133,4201
> > subroutine map_work_mgbf(f,g,iadvance,ig)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    map_work_mgbf
> > !   prgrmmr:  yokota         org: NCEP/EMC                          date: 2024-02-20
> > !
> > ! abstract:  mapping field for MGBF
> > !
> > ! program history log:
> > !
> > !   input argument list:
> > !     f        - field to be filtered
> > !     g        - field for MGBF
> > !     iadvance - =1  to map from f to g, =2 to map from g to f
> > !     ig       - number for smoothing scales
> > !
> > !   output argument list:
> > !     f        - field to be filtered
> > !     g        - field for MGBF
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> >   use constants, only: zero
> >   use hybrid_ensemble_parameters, only: grd_loc
> >   implicit none
> > 
> >   integer(i_kind),intent(in   ) :: iadvance,ig
> >   real(r_kind)   ,intent(inout) :: f(grd_loc%lat2,grd_loc%lon2,grd_loc%nsig)
> >   real(r_kind)   ,intent(inout) :: g(grd_loc%nsig,obj_mgbf(ig)%nm,obj_mgbf(ig)%mm)
> > 
> >   real(r_kind) :: work_tmp(grd_loc%lon2,grd_loc%lat2)
> >   integer(i_kind) i,j,k
> > 
> >   if(iadvance == 1) then
> >      do k=1,grd_loc%nsig
> >         do j=1,grd_loc%lat2
> >            do i=1,grd_loc%lon2
> >               work_tmp(i,j)=f(j,i,k)
> >            enddo
> >         enddo
> >         do j=1,obj_mgbf(ig)%mm
> >            do i=1,obj_mgbf(ig)%nm
> >               g(k,i,j)=work_tmp(i+1,j+1)
> >            enddo
> >         enddo
> >      enddo
> >   elseif(iadvance == 2) then
> >      do k=1,grd_loc%nsig
> >         work_tmp=zero
> >         do j=1,obj_mgbf(ig)%mm
> >            do i=1,obj_mgbf(ig)%nm
> >               work_tmp(i+1,j+1)=g(k,i,j)
> >            enddo
> >         enddo
> >         do j=1,grd_loc%lat2
> >            do i=1,grd_loc%lon2
> >               f(j,i,k)=work_tmp(i,j)
> >            enddo
> >         enddo
> >      enddo
> >   endif
> >   return
> > 
> > end subroutine map_work_mgbf
> > 
> 3918c4218,4219
> < !
> ---
> > ! 
> > !   2022-03-01  X.Lu & X.Wang - add vars for hafs dual ens.  POC: xuguang.wang@ou.edu
> 3928c4229
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3939c4240
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 3942a4244,4246
> >   use hybrid_ensemble_parameters, only:nsclgrp,spc_multwgt,spcwgt_params,global_spectral_filter_sd
> >   use hybrid_ensemble_parameters, only:regional_ensemble_option
> >   use gsi_rfv3io_mod,only:gsi_rfv3io_get_ens_grid_specs
> 3950a4255,4256
> >   character(:),allocatable:: fv3_ens_spec_grid_filename
> >   integer :: ierr
> 3976d4281
> < #ifdef USE_ALL_ORIGINAL
> 3995,3997c4300,4301
> < #endif /* USE_ALL_ORIGINAL */
> <                  if(mype==0) write(6,*)' dual_res,nlat,nlon,nlat_ens,nlon_ens,r_e,eps=',&
> <                                                      dual_res,nlat,nlon,nlat_ens,nlon_ens,r_e,eps
> ---
> >   if(mype==0) write(6,*)' dual_res,nlat,nlon,nlat_ens,nlon_ens,r_e,eps=',&
> >                                dual_res,nlat,nlon,nlat_ens,nlon_ens,r_e,eps
> 4032d4335
> < #ifdef USE_ALL_ORIGINAL
> 4034d4336
> < #endif /* USE_ALL_ORIGINAL */
> 4038d4339
> < #ifdef USE_ALL_ORIGINAL
> 4041a4343,4346
> >         if(regional_ensemble_option == 5) then
> >            fv3_ens_spec_grid_filename="fv3_ens_grid_spec"
> >            call gsi_rfv3io_get_ens_grid_specs(fv3_ens_spec_grid_filename,ierr)
> >         endif
> 4047c4352,4373
> < #endif /* USE_ALL_ORIGINAL */
> ---
> > 
> >   if(global_spectral_filter_sd .and. nsclgrp > 1)then
> >      allocate(spc_multwgt(sp_ens%nc,nsclgrp))
> >      allocate(spcwgt_params(4,nsclgrp))
> >      spc_multwgt=1.0
> > 
> >      ! The below parameters are used in Huang et al. (2021, MWR)
> >      spcwgt_params(1,1)=4000.0_r_kind
> >      spcwgt_params(2,1)=100000000.0_r_kind
> >      spcwgt_params(3,1)=1.0_r_kind
> >      spcwgt_params(4,1)=3000.0_r_kind
> > 
> >      if( nsclgrp >=3 )then
> >        spcwgt_params(1,3)=0.0_r_kind
> >        spcwgt_params(2,3)=500.0_r_kind
> >        spcwgt_params(3,3)=1.0_r_kind
> >        spcwgt_params(4,3)=500.0_r_kind
> >      end if
> > 
> >      call init_mult_spc_wgts(jcap_ens)
> > 
> >   end if
> 4066a4393,4395
> > !   2022-09-15  yokota - add scale/variable/time-dependent localization
> > !   2022-12-09  Y. Wang and X. Wang - add a variable-dependent localization option (assign_vdl_nml=.true.),
> > !                                     poc: xuguang.wang@ou.edu
> 4077,4079c4406,4408
> <    use m_kinds, only: r_kind,i_kind
> <    use constants, only: one,zero,half
> <    use m_mpimod, only: mype
> ---
> >    use kinds, only: r_kind,i_kind
> >    use constants, only: one,zero
> >    use mpimod, only: mype
> 4081d4409
> < #ifdef USE_ALL_ORIGINAL
> 4083,4084d4410
> <    use m_revBens, only: revBens_ensloc_refactor
> < #endif /* USE_ALL_ORIGINAL */
> 4087c4413
> <    use hybrid_ensemble_parameters, only: readin_beta,beta_s,beta_e,beta_s0,sqrt_beta_s,sqrt_beta_e
> ---
> >    use hybrid_ensemble_parameters, only: readin_beta,beta_s,beta_e,beta_s0,beta_e0,sqrt_beta_s,sqrt_beta_e
> 4089a4416,4419
> >    use hybrid_ensemble_parameters, only: ntotensgrp,naensgrp,naensloc,ntlevs_ens,nsclgrp,assign_vdl_nml
> >    use hybrid_ensemble_parameters, only: en_perts,vdl_scale,vloc_varlist,global_spectral_filter_sd
> >    use hybrid_ensemble_parameters, only: ngvarloc
> >    use hybrid_ensemble_parameters, only: l_mgbf_loc
> 4091c4421
> <    use guess_grids, only: gsiguess_get_ref_gesprs
> ---
> >    use string_utility, only: StrLowCase
> 4097a4428,4429
> >    integer(i_kind) :: n,nk,m,ig,ic3,ic2,ipic,istatus,ii
> >    integer(i_kind) :: ipc3d(nc3d),ipc2d(nc2d)
> 4099,4100c4431,4441
> <    real(r_kind),allocatable:: s_ens_h_gu_x(:),s_ens_h_gu_y(:)
> <    real(r_kind),allocatable:: prs(:)
> ---
> >    real(r_kind),allocatable:: s_ens_h_gu_x(:,:),s_ens_h_gu_y(:,:)
> >    logical :: l_read_success
> >    type(gsi_bundle) :: a_en(n_ens)
> >    type(gsi_bundle),allocatable :: en_pertstmp(:,:),en_pertstmp1(:,:)
> >    type(gsi_grid)  :: grid_ens
> >    real(r_kind), pointer :: values(:) => NULL()
> >    integer(i_kind) :: iscl, iv, smooth_scales_num
> >    character(len=*),parameter::myname_=myname//'*hybens_localization_setup'
> >    character(len=40) :: mgbfname='mgbf_locXX.nml'
> > 
> >    l_read_success=.false.
> 4125,4135d4465
> <          allocate(prs(grd_ens%nsig+1))
> <          call gsiguess_get_ref_gesprs(prs)
> <          do k = 1,grd_ens%nsig
> <             read(lunin,101) s_ens_hv(k), s_ens_vv(k), beta_s(k), beta_e(k)
> <          enddo
> <          close(lunin)
> < 
> < #ifdef USE_ALL_ORIGINAL
> <          call revBens_ensloc_refactor(s_ens_hv,s_ens_vv)
> < #endif /* USE_ALL_ORIGINAL */
> < 
> 4138c4468,4474
> <             if(mype==0) write(6,102) s_ens_hv(k), s_ens_vv(k), beta_s(k), beta_e(k), half*(prs(k)+prs(k+1))
> ---
> >             read(lunin,101) s_ens_hv(k,1), s_ens_vv(k,1), beta_s(k), beta_e(k)
> >             if(mype==0) write(6,101) s_ens_hv(k,1), s_ens_vv(k,1), beta_s(k), beta_e(k)
> >          enddo
> >          do ig=2,naensloc
> >             do k = 1,grd_ens%nsig
> >                read(lunin,101,end=300) s_ens_hv(k,ig),s_ens_vv(k,ig)
> >             enddo
> 4140c4476,4486
> <          deallocate(prs)
> ---
> >          l_read_success=.true.
> >          close(lunin)
> > 300      continue
> >          if(.not.l_read_success) then
> >             do ig=2,naensloc
> >                do k = 1,grd_ens%nsig
> >                   s_ens_hv(k,ig)=s_ens_hv(k,1)
> >                   s_ens_vv(k,ig)=s_ens_vv(k,1)
> >                enddo
> >             enddo
> >          endif
> 4153,4154d4498
> <          if(.not.allocated(s_ens_h_gu_x)) allocate(s_ens_h_gu_x(grd_loc%nsig*n_ens))
> <          if(.not.allocated(s_ens_h_gu_y)) allocate(s_ens_h_gu_y(grd_loc%nsig*n_ens))
> 4156a4501
> > 
> 4162d4506
> < 102 format(F8.1,3x,F8.3,F8.4,3x,F8.4,F10.4)
> 4166c4510,4514
> <       beta_e = one - beta_s0
> ---
> >       if (beta_e0 < 0) then
> >          beta_e = one - beta_s0
> >       else
> >          beta_e = beta_e0
> >       endif
> 4169d4516
> < #ifdef USE_ALL_ORIGINAL
> 4178d4524
> < #endif /* USE_ALL_ORIGINAL */
> 4183,4186c4529,4532
> <       if(.not.allocated(s_ens_h_gu_x)) allocate(s_ens_h_gu_x(1))
> <       if(.not.allocated(s_ens_h_gu_y)) allocate(s_ens_h_gu_y(1))
> <       s_ens_hv = s_ens_h
> <       s_ens_vv = s_ens_v
> ---
> >       do ig=1,naensloc
> >          s_ens_hv(:,ig) = s_ens_h(ig)
> >          s_ens_vv(:,ig) = s_ens_v(ig)
> >       enddo
> 4195,4201c4541,4574
> <       call convert_km_to_grid_units(s_ens_h_gu_x,s_ens_h_gu_y,nz)
> <       if ( vvlocal ) then
> <          call init_rf_x(s_ens_h_gu_x(grd_loc%kbegin_loc:grd_loc%kend_alloc),kl)
> <          call init_rf_y(s_ens_h_gu_y(grd_loc%kbegin_loc:grd_loc%kend_alloc),kl)
> <       else
> <          call init_rf_x(s_ens_h_gu_x,kl)
> <          call init_rf_y(s_ens_h_gu_y,kl)
> ---
> >       if ( l_mgbf_loc ) then
> >          allocate(obj_mgbf(naensgrp))
> >          do ig=1,naensgrp
> >             write(mgbfname(9:10),'(i2.2)') ig
> >             call obj_mgbf(ig)%mg_initialize(trim(mgbfname))
> >          enddo
> >       endif
> >       ! Even for MGBF-localization, recursive filter is applied for scale-separation
> >       ! in scale-dependent localization, so init_rf_[xy] should be called in nsclgrp>1
> >       if( .not. l_mgbf_loc .or. nsclgrp > 1 ) then
> >          if ( vvlocal ) then
> >             allocate(s_ens_h_gu_x(grd_loc%nsig*n_ens,naensloc))
> >             allocate(s_ens_h_gu_y(grd_loc%nsig*n_ens,naensloc))
> >             call convert_km_to_grid_units(s_ens_h_gu_x(1:nz,:),s_ens_h_gu_y(1:nz,:),nz)
> >             do n=2,n_ens
> >                nk=(n-1)*nz
> >                do k=1,nz
> >                   s_ens_h_gu_x(nk+k,:)=s_ens_h_gu_x(k,:)
> >                   s_ens_h_gu_y(nk+k,:)=s_ens_h_gu_y(k,:)
> >                enddo
> >             enddo
> >             call init_rf_x(s_ens_h_gu_x(grd_loc%kbegin_loc:grd_loc%kend_alloc,:),kl)
> >             call init_rf_y(s_ens_h_gu_y(grd_loc%kbegin_loc:grd_loc%kend_alloc,:),kl)
> >          else
> >             allocate(s_ens_h_gu_x(1,naensloc))
> >             allocate(s_ens_h_gu_y(1,naensloc))
> >             call convert_km_to_grid_units(s_ens_h_gu_x,s_ens_h_gu_y,nz)
> >             call init_rf_x(s_ens_h_gu_x,kl)
> >             call init_rf_y(s_ens_h_gu_y,kl)
> >          endif
> >          call normal_new_factorization_rf_x
> >          call normal_new_factorization_rf_y
> >          deallocate(s_ens_h_gu_x)
> >          deallocate(s_ens_h_gu_y)
> 4203,4204d4575
> <       call normal_new_factorization_rf_x
> <       call normal_new_factorization_rf_y
> 4208a4580,4751
> >    if(ntotensgrp>1 .and. (.not. global_spectral_filter_sd)) then
> >       call gsi_bundlegetpointer(en_perts(1,1,1),cvars3d,ipc3d,istatus)
> >       if(istatus/=0) then
> >          write(6,*) myname_,': cannot find 3d pointers'
> >          call stop2(999)
> >       endif
> >       call gsi_bundlegetpointer(en_perts(1,1,1),cvars2d,ipc2d,istatus)
> >       if(istatus/=0) then
> >          write(6,*) myname_,': cannot find 2d pointers'
> >          call stop2(999)
> >       endif
> >       if(nsclgrp>1) then
> >          call gsi_gridcreate(grid_ens,grd_ens%lat2,grd_ens%lon2,grd_ens%nsig)
> >          allocate(values(grd_ens%latlon11*grd_ens%nsig*n_ens))
> >          if( .not. assign_vdl_nml )then
> >             do ig=1,nsclgrp-1
> >                ii=0
> >                do n=1,n_ens
> >                   a_en(n)%values => values(ii+1:ii+grd_ens%latlon11*grd_ens%nsig)
> >                   call gsi_bundleset(a_en(n),grid_ens,'Ensemble Bundle',istatus,names3d=(/'a_en'/),bundle_kind=r_kind)
> >                   if (istatus/=0) then
> >                      write(6,*) myname_,': error alloc(ensemble bundle)'
> >                      call stop2(999)
> >                   endif
> >                   ii=ii+grd_ens%latlon11*grd_ens%nsig
> >                enddo
> >                do m=1,ntlevs_ens
> >                   do n=1,n_ens
> >                      en_perts(n,ig+1,m)%valuesr4=en_perts(n,ig,m)%valuesr4
> >                   enddo
> >                   do ic3=1,nc3d
> >                      ipic=ipc3d(ic3)
> >                      do n=1,n_ens
> >                         do k=1,grd_ens%nsig
> >                            a_en(n)%r3(1)%q(:,:,k)=en_perts(n,ig,m)%r3(ipic)%qr4(:,:,k)
> >                         enddo
> >                      enddo
> >                      call bkgcov_a_en_new_factorization(naensgrp+ig,a_en)
> >                      do n=1,n_ens
> >                         do k=1,grd_ens%nsig
> >                            en_perts(n,ig,m)%r3(ipic)%qr4(:,:,k)=a_en(n)%r3(1)%q(:,:,k)
> >                         enddo
> >                      enddo
> >                   enddo
> >                   do ic2=1,nc2d
> >                      ipic=ipc2d(ic2)
> >                      do n=1,n_ens
> >                         do k=1,grd_ens%nsig
> >                            a_en(n)%r3(1)%q(:,:,k)=en_perts(n,ig,m)%r2(ipic)%qr4(:,:)
> >                         enddo
> >                      enddo
> >                      call bkgcov_a_en_new_factorization(naensgrp+ig,a_en)
> >                      do n=1,n_ens
> >                         en_perts(n,ig,m)%r2(ipic)%qr4(:,:)=a_en(n)%r3(1)%q(:,:,1)
> >                      enddo
> >                   enddo
> >                   do n=1,n_ens
> >                      en_perts(n,ig+1,m)%valuesr4=en_perts(n,ig+1,m)%valuesr4-en_perts(n,ig,m)%valuesr4
> >                   enddo
> >                enddo
> >                do n=1,n_ens
> >                   call gsi_bundleunset(a_en(n),istatus)
> >                enddo
> >             enddo
> >          else ! assign_vdl_nml
> >             smooth_scales_num = naensloc - naensgrp
> >             ngvarloc = 1 ! forced to 1 in this option
> >             allocate(en_pertstmp(n_ens,ntlevs_ens))
> >             allocate(en_pertstmp1(n_ens,ntlevs_ens))
> >             do n = 1, n_ens
> >               do m = 1, ntlevs_ens
> >                  call gsi_bundlecreate(en_pertstmp(n,m),grid_ens,'ensemble2',istatus,names2d=cvars2d,names3d=cvars3d,bundle_kind=r_single)
> >                  call gsi_bundlecreate(en_pertstmp1(n,m),grid_ens,'ensemble1',istatus,names2d=cvars2d,names3d=cvars3d,bundle_kind=r_single)
> >               end do
> >             end do
> >             ig = 1
> >             do iscl=1,smooth_scales_num + 1
> >                ii=0
> >                do n=1,n_ens
> >                   a_en(n)%values => values(ii+1:ii+grd_ens%latlon11*grd_ens%nsig)
> >                   call gsi_bundleset(a_en(n),grid_ens,'Ensemble Bundle',istatus,names3d=(/'a_en'/),bundle_kind=r_kind)
> >                   if (istatus/=0) then
> >                      write(6,*) myname_,': error alloc(ensemble bundle)'
> >                      call stop2(999)
> >                   endif
> >                   ii=ii+grd_ens%latlon11*grd_ens%nsig
> >                enddo
> >            
> >                do m=1,ntlevs_ens
> >                   if( ig == 1 )then
> >                     do n=1,n_ens
> >                        en_pertstmp(n,m)%valuesr4=en_perts(n,ig,m)%valuesr4
> >                     enddo
> >                   end if
> >                   do ic3=1,nc3d
> >                      ipic=ipc3d(ic3)
> >                      do n=1,n_ens
> >                         do k=1,grd_ens%nsig
> >                            a_en(n)%r3(1)%q(:,:,k)=en_pertstmp(n,m)%r3(ipic)%qr4(:,:,k)
> >                         enddo
> >                      enddo
> >                      if(iscl <= smooth_scales_num) call bkgcov_a_en_new_factorization(naensgrp+iscl,a_en)
> >                      do n=1,n_ens
> >                         do k=1,grd_ens%nsig
> >                            en_pertstmp1(n,m)%r3(ipic)%qr4(:,:,k)=a_en(n)%r3(1)%q(:,:,k)
> >                            if( vdl_scale(ig) == 0 )then
> >                               en_perts(n,ig,m)%r3(ipic)%qr4(:,:,k)=a_en(n)%r3(1)%q(:,:,k)
> >                            else  ! VDL is activated
> >                              do iv = 1, vdl_scale(ig)
> >                                 en_perts(n,ig+iv-1,m)%r3(ipic)%qr4(:,:,k)=0.0_r_single
> >                                 if( any( trim(StrLowCase(cvars3d(ic3))) == vloc_varlist(ig+iv-1,:) ) ) then
> >                                    en_perts(n,ig+iv-1,m)%r3(ipic)%qr4(:,:,k)=a_en(n)%r3(1)%q(:,:,k)
> >                                 end if
> >                              end do
> >                            end if
> >                         enddo
> >                      enddo
> >                   enddo
> >                   do ic2=1,nc2d
> >                      ipic=ipc2d(ic2)
> >                      do n=1,n_ens
> >                         do k=1,grd_ens%nsig
> >                            a_en(n)%r3(1)%q(:,:,k)=en_pertstmp(n,m)%r2(ipic)%qr4(:,:)
> >                         enddo
> >                      enddo
> >                      if(iscl <= smooth_scales_num) call bkgcov_a_en_new_factorization(naensgrp+iscl,a_en)
> >                      do n=1,n_ens
> >                        en_pertstmp1(n,m)%r2(ipic)%qr4(:,:)=a_en(n)%r3(1)%q(:,:,1)
> >                        if( vdl_scale(ig) == 0 )then
> >                           en_perts(n,ig,m)%r2(ipic)%qr4(:,:)=a_en(n)%r3(1)%q(:,:,1)
> >                        else  ! VDL is activated
> >                           do iv = 1, vdl_scale(ig)
> >                              en_perts(n,ig+iv-1,m)%r2(ipic)%qr4(:,:)=0.0_r_single
> >                              if( any( trim(StrLowCase(cvars2d(ic2)))  == vloc_varlist(ig+iv-1,:) ) ) then
> >                                 en_perts(n,ig+iv-1,m)%r2(ipic)%qr4(:,:)=a_en(n)%r3(1)%q(:,:,1)
> >                              end if
> >                           end do
> >                        end if
> >                      enddo
> >                   enddo
> >                   do n=1,n_ens
> >                      en_pertstmp(n,m)%valuesr4=en_pertstmp(n,m)%valuesr4-en_pertstmp1(n,m)%valuesr4
> >                   enddo
> >                enddo
> >                do n=1,n_ens
> >                   call gsi_bundleunset(a_en(n),istatus)
> >                enddo
> >                if( vdl_scale(ig) == 0 )then
> >                   ig = ig + 1
> >                else
> >                   ig = ig + vdl_scale(ig)
> >                end if
> >             enddo
> >             do n=1,n_ens
> >               do m=1,ntlevs_ens
> >                  call gsi_bundledestroy(en_pertstmp(n,m),istatus)
> >                  call gsi_bundledestroy(en_pertstmp1(n,m),istatus)
> >               end do
> >             end do
> >             deallocate(en_pertstmp,en_pertstmp1)
> >           end if
> >           deallocate(values)
> >        endif
> >        do ig=nsclgrp+1,ntotensgrp
> >           do m=1,ntlevs_ens
> >              do n=1,n_ens
> >                 en_perts(n,ig,m)%valuesr4=en_perts(n,ig-nsclgrp,m)%valuesr4
> >              enddo
> >           enddo
> >        enddo
> >    endif
> > 
> 4223a4767,4776
> >    ! nval_loc_en is the number of horizontally-filtered variables in the domain of each processor,
> >    ! which is the same as nval_lenz_en (horizontally-global and vertically-local) in recursive/spectral filter
> >    ! but horizontally-local and vertically-global in MGBF.
> >    if ( l_mgbf_loc ) then
> >       nval_loc_en = maxval( obj_mgbf(1:naensgrp)%km_all &
> >            & * (obj_mgbf(1:naensgrp)%im + obj_mgbf(1:naensgrp)%hx*2) &
> >            & * (obj_mgbf(1:naensgrp)%jm + obj_mgbf(1:naensgrp)%hy*2) )
> >    else
> >       nval_loc_en = nval_lenz_en
> >    endif
> 4229,4233c4782,4783
> < !_RT_DEBUG   if ( print_verbose ) then
> <    allocate(prs(grd_ens%nsig+1))
> <    call gsiguess_get_ref_gesprs(prs)
> <    if ( mype==0 ) then
> <       write(6,*) 'HYBENS_LOCALIZATION_SETUP(FINAL): s_ens_hv,s_ens_vv,beta_s,beta_e'
> ---
> >    if ( print_verbose ) then
> >       write(6,*) 'HYBENS_LOCALIZATION_SETUP: s_ens_hv(:,1),s_ens_vv(:,1),beta_s,beta_e'
> 4235c4785
> <          write(6,102) s_ens_hv(k), s_ens_vv(k), beta_s(k), beta_e(k), half*(prs(k)+prs(k+1))
> ---
> >          write(6,101) s_ens_hv(k,1), s_ens_vv(k,1), beta_s(k), beta_e(k)
> 4238c4788,4789
> <    deallocate(prs)
> ---
> > 
> >    call setup_ensgrp2aensgrp
> 4244,4248d4794
> < subroutine hybens_localization_unsetup
> < implicit none
> < call destroy_sf_xy
> < end subroutine hybens_localization_unsetup
> < 
> 4274,4275c4820,4821
> <   use m_kinds, only: r_kind,i_kind
> <   use hybrid_ensemble_parameters, only: grd_loc,n_ens,s_ens_hv
> ---
> >   use kinds, only: r_kind,i_kind
> >   use hybrid_ensemble_parameters, only: s_ens_hv
> 4276a4823
> >   use hybrid_ensemble_parameters, only: naensloc
> 4281c4828
> <   real(r_kind),intent(  out) ::s_ens_h_gu_x(nz),s_ens_h_gu_y(nz)
> ---
> >   real(r_kind),intent(  out) ::s_ens_h_gu_x(nz,naensloc),s_ens_h_gu_y(nz,naensloc)
> 4284c4831
> <   integer(i_kind) k,n,nk
> ---
> >   integer(i_kind) k
> 4298,4302c4845,4848
> <      s_ens_h_gu_x(k)=s_ens_hv(k)/(.001_r_kind*dxmax)
> <      s_ens_h_gu_y(k)=s_ens_hv(k)/(.001_r_kind*dymax)
> <      if(print_verbose) write(6,*)' in convert_km_to_grid_units,s_ens_h,s_ens_h_gu_x,y=', &
> <                     s_ens_hv(k),s_ens_h_gu_x(k),s_ens_h_gu_y(k)
> < 
> ---
> >      s_ens_h_gu_x(k,:)=s_ens_hv(k,:)/(.001_r_kind*dxmax)
> >      s_ens_h_gu_y(k,:)=s_ens_hv(k,:)/(.001_r_kind*dymax)
> >      if(print_verbose) write(6,*)' in convert_km_to_grid_units,s_ens_h(k,1),s_ens_h_gu_x,y(k,1)=', &
> >                     s_ens_hv(k,1),s_ens_h_gu_x(k,1),s_ens_h_gu_y(k,1)
> 4305,4313d4850
> <   if(nz>1)then
> <   do n=2,n_ens
> <      nk=(n-1)*grd_loc%nsig
> <      do k=1,grd_loc%nsig
> <         s_ens_h_gu_x(nk+k)=s_ens_h_gu_x(k)
> <         s_ens_h_gu_y(nk+k)=s_ens_h_gu_y(k)
> <      enddo
> <   enddo
> <   endif
> 4316d4852
> < 
> 4345c4881
> <   use m_kinds, only: r_single,r_kind,i_kind
> ---
> >   use kinds, only: r_single,r_kind,i_kind
> 4456c4992
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4461c4997
> <   use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 4480c5016
> <                  gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                  gridpe,mpi_comm_world,ierror)
> 4516c5052
> <   use m_kinds, only: r_single,r_kind,i_kind
> ---
> >   use kinds, only: r_single,r_kind,i_kind
> 4624c5160
> <   use m_kinds, only: r_single,r_kind,i_kind
> ---
> >   use kinds, only: r_single,r_kind,i_kind
> 4733c5269
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4735c5271
> <   use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 4759c5295
> <                  gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                  gridpe,mpi_comm_world,ierror)
> 4796c5332
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4799c5335
> <   use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 4821c5357
> <                  gridpe,gsi_mpi_comm_world,ierror)
> ---
> >                  gridpe,mpi_comm_world,ierror)
> 4860c5396
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> 4865c5401
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 4950c5486
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> 4956c5492
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 5043c5579
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> 5082,5083c5618,5619
> <   use m_kinds, only: i_kind,i_llong
> <   use m_mpimod, only: mype
> ---
> >   use kinds, only: i_kind,i_llong
> >   use mpimod, only: mype
> 5153a5690
> >     deallocate(n_acceptable_table)
> 5183c5720
> <    use m_kinds, only: r_kind,i_kind
> ---
> >    use kinds, only: r_kind,i_kind
> 5185c5722
> <    use m_mpimod, only: mype,gsi_mpi_comm_world,mpi_rtype,mpi_sum
> ---
> >    use mpimod, only: mype,mpi_comm_world,mpi_rtype,mpi_sum
> 5247,5251c5784,5810
> < #ifdef USE_ALL_ORIGINAL
> < subroutine ens_iterate_update(jiter)
> <   use hybrid_ensemble_parameters, only: destroy_hybens_localization_parameters
> <   use hybrid_ensemble_parameters, only: bens_recenter
> <   use m_revBens, only: update_spread
> ---
> > subroutine setup_ensgrp2aensgrp
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    set a matrix of (naensgrp,naensgrp)
> > !
> > ! program history log:
> > !   2022-09-15  yokota  - add scale/variable/time-dependent localization
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !
> > ! remarks:
> > !    need to reconcile grid in gsi_bundle w/ grid_ens/grid_anl
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> >   use constants, only: zero,one
> >   use hybrid_ensemble_parameters, only: l_timloc_opt,r_ensloccov4tim,r_ensloccov4var,r_ensloccov4scl
> >   use hybrid_ensemble_parameters, only: ensloccov4tim,ensloccov4var,ensloccov4scl
> >   use hybrid_ensemble_parameters, only: ntotensgrp,naensgrp,ntlevs_ens,nsclgrp,ngvarloc
> >   use hybrid_ensemble_parameters, only: ensgrp2aensgrp
> >   use hybrid_ensemble_parameters, only: idaen2d,idaen3d
> >   use hybrid_ensemble_parameters, only: alphacvarsclgrpmat
> 5253d5811
> <   integer(i_kind),intent(in) :: jiter
> 5255c5813,5846
> <   if (jiter<2) return
> ---
> >   integer (i_kind):: i,j
> >   integer (i_kind):: ig,ibin,ic,iscl,itim1,itim2,igvar1,igvar2,iscl1,iscl2,ivargrp
> >   integer (i_kind):: ntimloc,interval4aens
> > 
> >   if (l_timloc_opt) then
> >      ntimloc=ntlevs_ens
> >      interval4aens=ntotensgrp
> >   else
> >      ntimloc=1
> >      interval4aens=0
> >   endif
> >   if(naensgrp/=ntimloc*ngvarloc*nsclgrp) then
> >      write(6,*)'setup_ensgrp2aensgrp: wrong naensgrp'
> >      call stop2(666)
> >   endif
> >   if(ntotensgrp/=ngvarloc*nsclgrp) then
> >      write(6,*)'setup_ensgrp2aensgrp: wrong ntotensgrp'
> >      call stop2(666)
> >   endif
> >   ensgrp2aensgrp=-999
> >   do ibin=1,ntlevs_ens
> >      do ic=1,nc3d+nc2d
> >         if(ngvarloc>1) then
> >            if(ic<=nc3d) ivargrp=idaen3d(ic)
> >            if(ic> nc3d) ivargrp=idaen2d(ic-nc3d)
> >         else
> >            ivargrp=1
> >         endif
> >         do iscl=1,nsclgrp
> >            ig=(ivargrp-1)*nsclgrp+iscl
> >            ensgrp2aensgrp(ig,ic,ibin)=(ibin-1)*interval4aens+(ivargrp-1)*nsclgrp+iscl
> >         enddo
> >      enddo
> >   enddo
> 5257,5269c5848,5871
> < ! unload ensemble
> <   call destroy_hybens_localization_parameters
> <   call hybens_localization_unsetup
> <   call destroy_ensemble
> < 
> < ! set recentering of ensemble around analysis
> <   bens_recenter = .true.   ! use alternative mean as ensemble mean to calc Bens
> <   update_spread = .true.   ! use analysis as recenter field, updating spread on the fly
> < 
> < ! reload ensemble but this time use analysis for recentering
> <   call create_ensemble
> <   call load_ensemble(-1)
> <   call hybens_localization_setup
> ---
> >   ensloccov4tim=r_ensloccov4tim
> >   ensloccov4tim(1)=one
> >   ensloccov4var=r_ensloccov4var
> >   ensloccov4var(1)=one
> >   ensloccov4scl=r_ensloccov4scl
> >   ensloccov4scl(1)=one
> > 
> >   do itim2=1,ntimloc
> >      do itim1=1,ntimloc
> >         do igvar1=1,ngvarloc
> >            do igvar2=1,ngvarloc
> >               do iscl1=1,nsclgrp
> >                  do iscl2=1,nsclgrp
> >                     i=(itim1-1)*interval4aens+(igvar1-1)*nsclgrp+iscl1
> >                     j=(itim2-1)*interval4aens+(igvar2-1)*nsclgrp+iscl2
> >                     alphacvarsclgrpmat(i,j)=ensloccov4tim(abs(itim1-itim2)+1) &
> >                                            *ensloccov4var(abs(igvar1-igvar2)+1) &
> >                                            *ensloccov4scl(abs(iscl1-iscl2)+1) !first for ttime covariance
> >                  enddo
> >               enddo
> >            enddo
> >         enddo
> >      enddo
> >   enddo
> 5271,5272c5873
> < end subroutine ens_iterate_update
> < #endif /* USE_ALL_ORIGINAL */
> ---
> > end subroutine setup_ensgrp2aensgrp
> diff -r ./hybrid_ensemble_parameters.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/hybrid_ensemble_parameters.f90
> 90,91c90,105
> < !      s_ens_h:    horizontal localization correlation length (units of km), default = 2828.0
> < !      s_ens_v:    vertical localization correlation length (grid units), default = 30.0
> ---
> > !      beta_e0 - default weight given to ensemble background error covariance
> > !                (if .not. readin_beta). if beta_e0<0, then it is set to
> > !                1.-beta_s0 (this is the default)
> > !      s_ens_h: horizontal localization correlation length of Gaussian exp(-0.5*(r/L)**2)
> > !               (units of km), default = 2828.0
> > !      s_ens_v: vertical localization correlation length of Gaussian exp(-0.5*(r/L)**2)
> > !               (grid units if s_ens_v>=0, or units of ln(p) if s_ens_v<0), default = 30.0
> > !                  in scale/variable/time-dependent localization (SDL/VDL/TDL),
> > !                  localization length for i-th scale, j-th variable, and k-th time is
> > !                     s_ens_[hv]( i + nsclgrp*(j-1) + nsclgrp*ngvarloc*(k-1) )
> > !                        in SDL(nsclgrp>1),         i = 1(largest scale)  .. nsclgrp(smallest scale)
> > !                        in VDL(ngvarloc=2),        j = 1(itracer<=10)    .. 2(itracer>=11)
> > !                        in TDL(l_timloc_opt=true), k = 1(first time bin) .. ntlevs_ens(last time bin)
> > !                  in SDL, scale separation length for i-th scale is also set here as
> > !                     s_ens_[hv]( naensgrp+i ) - naensgrp is the total number of localization lengths for SDL/VDL/TDL
> > !                        in applying SDL only horizontally, set s_ens_v(naensgrp+i)=0.0
> 116a131
> > !      parallelization_over_ensmembers: parallelly read ensemble members for FV3-LAM; default '.false'      
> 117a133,152
> > !      nsclgrp:         number of scale-dependent localization lengths
> > !      l_timloc_opt:    if true, then turn on time-dependent localization
> > !      ngvarloc:        number of variable-dependent localization lengths
> > !      naensloc:        total number of spatial localization lengths and scale separation lengths (should be naensgrp+nsclgrp-1)
> > !      r_ensloccov4tim: factor multiplying to cross-time covariance
> > !                         For example,
> > !                         =0.0: cross-time covariance is decreased to zero
> > !                         =0.5: cross-time covariance is decreased to half
> > !                         =1.0: cross-time covariance is retained
> > !      r_ensloccov4var: factor multiplying to cross-variable covariance
> > !                         For example,
> > !                         =0.0: cross-variable covariance is decreased to zero
> > !                         =0.5: cross-variable covariance is decreased to half
> > !                         =1.0: cross-variable covariance is retained
> > !      r_ensloccov4scl: factor multiplying to cross-scale covariance
> > !                         For example,
> > !                         =0.0: cross-scale covariance is decreased to zero
> > !                         =0.5: cross-scale covariance is decreased to half
> > !                         =1.0: cross-scale covariance is retained
> > !      l_mgbf_loc: if true, multi-grid beta filter is used for localization instead of recursive filter
> 151c186,187
> < !   2020-05-01  todling - allow for centering Bens around background/guess
> ---
> > !   2022-09-15  yokota  - add scale/variable/time-dependent localization
> > !   2024-02-20  yokota  - add MGBF-based localization
> 175,176c211,214
> < !   def s_ens_h             - homogeneous isotropic horizontal ensemble localization scale (km)
> < !   def s_ens_v             - vertical localization scale (grid units for now)
> ---
> > !   def s_ens_h             - horizontal localization correlation length of Gaussian exp(-0.5*(r/L)**2)
> > !                             (units of km), default = 2828.0
> > !   def s_ens_v             - vertical localization correlation length of Gaussian exp(-0.5*(r/L)**2)
> > !                             (grid units if s_ens_v>=0, or units of ln(p) if s_ens_v<0), default = 30.0
> 236,238d273
> < !   def bens_recenter        - center Bens around background/guess; default '.false.'
> < !   def upd_ens_spread       - update ens spread with first guess
> < !   def upd_ens_localization - update localization when upd_ens_spread=.t.
> 246c281
> <   use m_kinds, only: i_kind,r_kind,r_single
> ---
> >   use kinds, only: i_kind,r_kind,r_single
> 264c299
> <   public :: uv_hyb_ens,q_hyb_ens,s_ens_v,beta_s0,aniso_a_en,s_ens_hv,s_ens_vv
> ---
> >   public :: uv_hyb_ens,q_hyb_ens,s_ens_v,beta_s0,beta_e0,aniso_a_en,s_ens_hv,s_ens_vv
> 284a320,321
> >   public :: fv3sar_ensemble_opt 
> >   
> 291d327
> <   public :: ens_fname_tmpl
> 295a332,339
> >   public :: naensgrp,ntotensgrp,nsclgrp,naensloc,ngvarloc
> >   public :: ensgrp2aensgrp
> >   public :: ensloccov4tim,ensloccov4var,ensloccov4scl
> >   public :: alphacvarsclgrpmat
> >   public :: l_timloc_opt
> >   public :: r_ensloccov4tim,r_ensloccov4var,r_ensloccov4scl
> >   public :: l_mgbf_loc
> >   public :: idaen3d,idaen2d
> 296a341,342
> >   public :: parallelization_over_ensmembers
> >   public :: l_both_fv3sar_gfs_ens 
> 298,302c344,350
> <   public :: bens_recenter
> <   public :: upd_ens_spread
> <   public :: upd_ens_localization
> <   public :: EnsSource
> <   public :: nymd,nhms
> ---
> >   public :: limqens
> > 
> >   public :: spc_multwgt
> >   public :: spcwgt_params
> >   public :: vdl_scale,vloc_varlist
> >   public :: global_spectral_filter_sd
> >   public :: assign_vdl_nml
> 305c353,354
> <   logical bens_recenter,upd_ens_spread,upd_ens_localization
> ---
> >   logical l_timloc_opt
> >   logical l_mgbf_loc
> 320a370,371
> >   logical parallelization_over_ensmembers
> >   logical l_both_fv3sar_gfs_ens
> 325c376,380
> <   real(r_kind) beta_s0,s_ens_h,s_ens_v,grid_ratio_ens
> ---
> >   real(r_kind) beta_s0,beta_e0,grid_ratio_ens
> >   integer(i_kind),parameter::max_naensloc=20
> >   integer(i_kind),parameter::max_nvars=100
> >   real(r_kind) s_ens_h(max_naensloc)
> >   real(r_kind) s_ens_v(max_naensloc)
> 329c384,385
> <   real(r_kind),allocatable,dimension(:) :: s_ens_hv,s_ens_vv
> ---
> >   real(r_kind),allocatable,dimension(:,:) :: s_ens_vv
> >   real(r_kind),allocatable,dimension(:,:) :: s_ens_hv
> 341a398
> >   integer(i_kind) fv3sar_ensemble_opt 
> 343,346c400,418
> <   character(len=512),save :: ens_fname_tmpl
> <   character(len=80) :: EnsSource
> < 
> <   integer, allocatable :: nymd(:),nhms(:)
> ---
> >   real(r_kind),allocatable,dimension(:,:) :: alphacvarsclgrpmat
> >   integer(i_kind),allocatable,dimension(:,:,:) :: ensgrp2aensgrp
> >   real(r_kind),allocatable,dimension(:) :: ensloccov4tim,ensloccov4var,ensloccov4scl
> >   integer(i_kind) :: nsclgrp=1
> >   integer(i_kind) :: naensgrp=1
> >   integer(i_kind) :: ntotensgrp=1
> >   integer(i_kind) :: naensloc=1
> >   integer(i_kind) :: ngvarloc=1
> >   real(r_kind) :: r_ensloccov4tim
> >   real(r_kind) :: r_ensloccov4var
> >   real(r_kind) :: r_ensloccov4scl
> >   integer(i_kind),allocatable,dimension(:) :: idaen3d,idaen2d
> > 
> >   real(r_kind),allocatable,dimension(:,:) :: spc_multwgt
> >   real(r_kind),allocatable,dimension(:,:) :: spcwgt_params
> >   character(len=3) vloc_varlist(max_naensloc,max_nvars)
> >   integer(i_kind) vdl_scale(max_naensloc)
> >   logical :: global_spectral_filter_sd
> >   logical :: assign_vdl_nml
> 354c426
> <   type(gsi_bundle),save,allocatable :: en_perts(:,:)
> ---
> >   type(gsi_bundle),save,allocatable :: en_perts(:,:,:)
> 355a428
> >   real(r_single):: limqens
> 361a435
> > 
> 393a468,469
> >   l_timloc_opt=.false.
> >   l_mgbf_loc=.false.
> 404a481
> >   fv3sar_ensemble_opt=0
> 418a496
> >   beta_e0=-one
> 430d507
> <   ens_fname_tmpl = 'bkg.eta.%y4%m2%d2_%h2z.nc4' ! this should superseed var ensemble_path
> 432,438c509,512
> <   bens_recenter=.false.      ! center ensemble cov around background/guess
> <   upd_ens_spread=.false.     ! redefine ens spread (for jiter>1) by recentering ens around guess 
> <   upd_ens_localization=.false.  ! update localization when upd_ens_spread=.t.
> < 
> <   EnsSource = 'NULL'
> < 
> <   n_ens_gfs=0
> ---
> >   parallelization_over_ensmembers=.false.
> >   limqens=1.0_r_single       ! default for limiting ensemble RH (+/-)
> >   l_both_fv3sar_gfs_ens=.false.
> >   n_ens_gfs=0 
> 441a516,522
> >   r_ensloccov4tim=one
> >   r_ensloccov4var=one
> >   r_ensloccov4scl=one
> >   vdl_scale = 0
> >   vloc_varlist = 'aaa'
> >   global_spectral_filter_sd=.false.
> >   assign_vdl_nml=.false.
> 450c531
> <   allocate( s_ens_hv(grd_ens%nsig),s_ens_vv(grd_ens%nsig) )
> ---
> >   allocate( s_ens_hv(grd_ens%nsig,naensloc),s_ens_vv(grd_ens%nsig,naensloc) )
> 453a535,537
> >   allocate( alphacvarsclgrpmat(naensgrp,naensgrp) )
> >   allocate( ensgrp2aensgrp(ntotensgrp,max_nvars,ntlevs_ens) )
> >   allocate( ensloccov4tim(ntlevs_ens),ensloccov4var(ngvarloc),ensloccov4scl(nsclgrp) )
> 458a543,547
> >   alphacvarsclgrpmat=one
> >   ensgrp2aensgrp=1
> >   ensloccov4tim=one
> >   ensloccov4var=one
> >   ensloccov4scl=one
> 467a557,558
> >   deallocate(alphacvarsclgrpmat)
> >   deallocate(ensgrp2aensgrp)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: inc2guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: init_jcdfi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: insitu_info.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intall.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intaod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intcldch.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intco.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intdbz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intdw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intfed.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intgps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intgust.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: inthowv.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intjcmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intjo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intlag.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intlcbas.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intlight.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intlwcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intmitm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intmxtm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intoz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intpblh.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intpcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intpm10.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intpm2_5.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intpmsl.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intpw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intq.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intrad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intrp2a.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intrp3oz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intrp_msk.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intrw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intspd.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intsst.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intswcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: inttcamt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: inttcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: inttd2m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intuwnd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intvis.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intvwnd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: intwspd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: jcmod.f90
> diff -r ./jfunc.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/jfunc.f90
> 2,50c2,160
> < use m_kinds, only: i_kind
> < implicit none
> < public :: jfunc_init
> < 
> < public :: mockbkg
> < 
> < public :: jouter_def
> < public :: jiter
> < public :: jiterstart
> < public :: npred
> < public :: npredp
> < public :: npcptype
> < public :: nsclen
> < public :: npclen
> < public :: ntclen
> < public :: nval_lenz
> < public :: nclen
> < public :: nclenz
> < public :: jpch_rad
> < public :: ljc4tlevs
> < public :: iadate
> < public :: qoption
> < public :: cwoption
> < public :: pseudo_q2
> < public :: switch_on_derivatives
> < public :: tendsflag
> < public :: clip_supersaturation
> < 
> < integer(i_kind),dimension(5):: iadate
> < integer(i_kind) :: jiter
> < integer(i_kind) :: jiterstart
> < integer(i_kind) :: npred
> < integer(i_kind) :: npredp
> < integer(i_kind) :: npcptype
> < integer(i_kind) :: nsclen
> < integer(i_kind) :: npclen
> < integer(i_kind) :: ntclen
> < integer(i_kind) :: nval_lenz
> < integer(i_kind) :: nclen
> < integer(i_kind) :: nclenz
> < integer(i_kind) :: jpch_rad
> < integer(i_kind) :: qoption
> < integer(i_kind) :: cwoption
> < logical :: mockbkg
> < logical :: ljc4tlevs
> < logical :: pseudo_q2
> < logical :: switch_on_derivatives
> < logical :: tendsflag
> < logical :: clip_supersaturation
> ---
> > !$$$   module documentation block
> > !                .      .    .                                       .
> > ! module:    jfunc
> > !   prgmmr: treadon          org: np23                date: 2003-11-24
> > !
> > ! abstract: module containing variables used in inner loop minimzation
> > !           NOTE: it is ok for jfunc to depend on setting related to B,
> > !                 but not the other way around.
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2004-10-06  kleist, create separate control vector for u,v
> > !   2004-10-15  parrish, add outer iteration variable for nonlinear qc
> > !   2004-12-23  treadon - add logical flags first and last
> > !   2005-02-23  wu - add qoption, dqdt,dqdrh,dqdp and varq for norm RH
> > !   2005-03-28  wu - replace mlath with mlat             
> > !   2005-06-03  parrish - add logical switch_on_derivatives
> > !   2005-09-29  kleist - add pointers for time derivatives
> > !   2005-11-21  kleist - expand time deriv pointers for tracer tendencies
> > !   2005-11-29  derber - fix bug in restart
> > !   2006-02-02  treadon - remove prsi_oz (use ges_prsi array)
> > !   2006-08-30  zhang,b - add bias correction control parameter
> > !   2007-03-13  derber - remove qsinv2 and add rhgues
> > !   2007-04-13  tremolet - use control vectors
> > !   2008-05-22  guo, j - merge GMAO MERRA changes with NCEP 2008-04-22
> > !                      - defer GMAO diurnal bias correction changes.
> > !   2008-12-01  todling - bring in Tremolet's changes
> > !   2009-06-01  pondeca,sato - add tsensible initialization. used in 2dvar mode only
> > !   2010-02-20  parrish - add change to get correct nval_len when using hybrid ensemble with dual resolution.
> > !   2010-02-20  zhu     - add nrf_levb and nrf_leve
> > !   2010-03-23  derber  - remove rhgues (not used)
> > !   2010-03-25  zhu     - add pointer_state
> > !   2010-05-12  todling - use gsi_bundle for state vector; remove pointer_state
> > !   2010-05-12  todling - replace some existing subdomain pointers w/ nsubwhalo/nsubnhalo
> > !                       - declare all variables coming from use statements
> > !   2010-05-20  todling - move nrf_levb and nrf_leve to control_vector where they belong
> > !   2010-08-15  gu/todling - add pseudo-q2 options
> > !   2013-05-20  zhu     - add ntclen for aircraft temperature bias correction aircraft_t_bc=.true. 
> > !                         or aircraft_t_bc_pof=.true.
> > !   2013-10-30  jung    - added logical clip_supersaturation
> > !   2013-12-10  zhu     - add variables varcw and cwoption
> > !   2014-03-19  pondeca - add factw10m
> > !   2014-05-07  pondeca - add facthowv
> > !   2014-06-18  carley/zhu - add lcbas and tcamt
> > !   2015-07-10  pondeca - add factcldch
> > !   2018-05-19  eliu    - add control factors (factql,factqi, ....) for hydrometeors 
> > !
> > ! Subroutines Included:
> > !   sub init_jfunc           - set defaults for cost function variables
> > !   sub create_jfunc         - allocate cost function arrays 
> > !   sub destroy_jfunc        - deallocate cost function arrays
> > !   anav_info                - control variables information
> > !   sub read_guess_solution  - read guess solution
> > !   sub write_guess_solution - write guess solution
> > !   sub strip1               - strip off halo from subdomain arrays for 1 field
> > !   sub strip2               - strip off halo from subdomain arrays
> > !   sub set_pointer          - set location indices for components of vectors
> > !
> > ! remarks: variable definitions below
> > !   def first      - logical flag = .true. on first outer iteration
> > !   def last       - logical flag = .true. following last outer iteration
> > !   def switch_on_derivatives - .t. = generate horizontal derivatives
> > !   def iout_iter  - output file number for iteration information
> > !   def miter      - number of outer iterations
> > !   def qoption    - option of q analysis variable; 1:q/qsatg 2:norm RH
> > !   def iguess     - flag for guess solution
> > !   def biascor    - background error bias correction coefficient 
> > !   def bcoption   - =0:do-nothing; =1:sbc; when <0 will estimate but not correct bkg bias
> > !   def diurnalbc  - 1= diurnal bias; 0= persistent bias
> > !   def niter      - number of inner interations (for each other iter.)
> > !   def niter_no_qc- number of inner interations without nonlinear qc (for each outer iter.)
> > !   def jiter      - outer iteration counter
> > !   def jiterstart - first outloop iteration number
> > !   def jiterend   - last outloop iteration number
> > !   def iter       - do loop iteration integer
> > !   def nclen      - length of control (x,y) vectors
> > !   def diag_precon- logical, if true do  preconditioning
> > !   def step_start - initial stepsize
> > !   def nvals_levs - number of 2d (x/y) state-vector variables
> > !   def nvals_len  - number of 2d state-vector variables * subdomain size (with buffer)
> > !   def nval_levs  - number of 2d (x/y) control-vector variables
> > !   def nval_levs_ens  - number of 2d (x/y) control-vector variables including
> > !   ensembles
> > !   def nval_len   - number of 2d control-vector variables * subdomain size (with buffer)
> > !   def print_diag_pcg - option for turning on GMAO diagnostics in pcgsoi
> > !   def tsensible  - option to use sensible temperature as the control variable. applicable
> > !                    to the 2dvar mode only
> > !   def ntracer    - total number of tracer variables
> > !   def nrft       - total number of time tendencies for upper level control variables
> > !   def nrft_      - order of time tendencies for 3d control variables
> > !   def R_option   - Option to use variable correlation length for lcbas based on data
> > !                    density - follows Hayden and Purser (1995) (twodvar_regional only)
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm RS/6000 SP
> > !
> > !$$$
> >   use kinds, only: r_kind,i_kind
> >   use constants, only: zero
> >   use control_vectors, only: nc2d,nc3d,mvars
> >   use control_vectors, only: nrf,nrf_3d,nrf_var
> >   use control_vectors, only: allocate_cv,deallocate_cv
> >   use control_vectors, only: control_vector
> >   use control_vectors, only: assignment(=)
> >   use control_vectors, only: setup_control_vectors
> >   use control_vectors, only: cvars3d
> >   use state_vectors, only: setup_state_vectors
> >   use gsi_bundlemod, only: gsi_bundle
> >   use gsi_bundlemod, only: gsi_bundle
> >   use mpeu_util, only: getindex
> >   implicit none
> > 
> > ! set default to private
> >   private
> > ! set subroutines to public
> >   public :: init_jfunc
> >   public :: create_jfunc
> >   public :: destroy_jfunc
> >   public :: read_guess_solution
> >   public :: write_guess_solution
> >   public :: strip1
> >   public :: strip2
> >   public :: set_pointer
> >   public :: set_sqrt_2dsize
> > ! set passed variables to public
> >   public :: nrclen,npclen,nsclen,ntclen,qoption,nval_lenz,tendsflag,tsensible,cwoption,varcw
> >   public :: switch_on_derivatives,jiterend,jiterstart,jiter,iter,niter,miter
> >   public :: diurnalbc,bcoption,biascor,nval2d,xhatsave,first
> >   public :: factqmax,factqmin,clip_supersaturation,last,yhatsave,nvals_len,nval_levs,nval_levs_ens,iout_iter,nclen
> >   public :: factql,factqi,factqr,factqs,factqg,superfact,limitqobs
> >   public :: niter_no_qc,print_diag_pcg,penorig,gnormorig,iguess
> >   public :: factg,factv,factp,factl,R_option,factw10m,facthowv,factcldch,diag_precon,step_start
> >   public :: pseudo_q2
> >   public :: varq
> >   public :: cnvw_option
> >   public :: hofx_2m_sfcfile
> > 
> >   logical first,last,switch_on_derivatives,tendsflag,print_diag_pcg,tsensible,diag_precon
> >   logical clip_supersaturation,R_option
> >   logical pseudo_q2,limitqobs
> >   logical hofx_2m_sfcfile
> >   logical cnvw_option
> >   integer(i_kind) iout_iter,miter,iguess,nclen,qoption,cwoption
> >   integer(i_kind) jiter,jiterstart,jiterend,iter
> >   integer(i_kind) nvals_len,nvals_levs
> >   integer(i_kind) nval_len,nval_lenz,nval_levs,nval_levs_ens
> >   integer(i_kind) nclen1,nclen2,nrclen,nsclen,npclen,ntclen
> >   integer(i_kind) nval2d,nclenz
> > 
> >   integer(i_kind),dimension(0:50):: niter,niter_no_qc
> >   real(r_kind) factqmax,factqmin,gnormorig,penorig,biascor(2),diurnalbc,factg,factv,factp,factl,&
> >                factw10m,facthowv,factcldch,step_start,superfact
> >   real(r_kind) factql,factqi,factqr,factqs,factqg  
> >   integer(i_kind) bcoption
> >   real(r_kind),allocatable,dimension(:,:):: varq
> >   real(r_kind),allocatable,dimension(:,:):: varcw
> >   type(control_vector),save :: xhatsave,yhatsave
> 52d161
> < integer,save :: jouter_def=0
> 54,80d162
> < subroutine jfunc_init
> <  mockbkg=.false. ! fake background state (internally generated)
> <  jiter=1         ! used as index for output spread - wired for now
> <  jiterstart=1    ! used as index for output spread - wired for now
> <  npred=0
> <  npredp=0
> <  npcptype=0
> <  nsclen=0
> <  npclen=0
> <  ntclen=0
> <  nval_lenz=0
> <  nclen=0
> <  nclenz=0
> <  jpch_rad=0
> <  ljc4tlevs=.false.  ! used to be in jcmod
> <  iadate(1) = 1776   ! year, default: should be replaced in each pass
> <  iadate(2) = 07     ! month default: should be replaced in each pass
> <  iadate(3) = 04     ! day,  default: should be replaced in each pass
> <  iadate(4) =  0     ! hour, default: should be replaced in each pass
> <  iadate(5) =  0     ! sec,  default: should be replaced in each pass
> <  switch_on_derivatives=.false.
> <  tendsflag=.false.
> < 
> <  qoption=1
> <  cwoption=0
> <  pseudo_q2=.false.
> <  clip_supersaturation = .false.
> 82c164,846
> < end subroutine jfunc_init
> ---
> >   subroutine init_jfunc
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    init_jfunc
> > !   prgmmr: treadon          org: np23               date:  2003-11-24
> > !
> > ! abstract: initialize cost function variables to defaults
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2004-12-23  treadon - initialize first and last
> > !   2005-06-03  parrish - initialize switch_on_derivatives
> > !   2005-10-27  kleist  - initialize tendency flag
> > !   2006-08-30  zhang,b - initialize bias correction scheme
> > !   2008-05-12  safford - rm unused uses
> > !   2010-08-15  gu/todling - add pseudo-q2 options
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use constants, only: zero, one
> >     implicit none
> >     integer(i_kind) i
> > 
> >     first = .true.
> >     last  = .false.
> >     switch_on_derivatives=.false.
> >     tendsflag=.false.
> >     print_diag_pcg=.false.
> >     tsensible=.false.
> >     diag_precon=.false.
> >     step_start=1.e-4_r_kind
> >     R_option=.false.
> > 
> >     factqmin=zero
> >     factqmax=zero
> >     superfact=1.00_r_kind
> >     limitqobs=.false.
> >     factql=zero
> >     factqi=zero
> >     factqr=zero
> >     factqs=zero
> >     factqg=zero
> >     clip_supersaturation=.false.
> >     factg=zero
> >     factv=zero
> >     factp=zero
> >     factl=zero
> >     factw10m=zero
> >     facthowv=zero
> >     factcldch=zero
> >     iout_iter=220
> >     miter=1
> >     qoption=1
> >     cwoption=0
> >     pseudo_q2=.false.
> >     do i=0,50
> >        niter(i)=0
> >        niter_no_qc(i)=1000000
> >     end do
> >     jiterstart=1
> >     jiterend=1
> >     jiter=jiterstart
> >     biascor(1)=0.98_r_kind ! dump coefficient for background bias correction
> >     biascor(2)=0.1_r_kind  ! time-scale associated to background bias estimate (cov model)
> >     diurnalbc=0         ! 1= diurnal bias; 0= persistent bias
> >     bcoption=0             ! =0:do-nothing; =1:sibc; when <0 will estimate but not correct bkg bias
> >     nclen=1
> >     nclenz=1
> > 
> >     penorig=zero
> >     gnormorig=zero
> > 
> > ! iguess = -1  do not use guess file
> > ! iguess =  0  write only guess file
> > ! iguess =  1  read and write guess file
> > ! iguess =  2  read only guess file
> > 
> >     iguess=1
> > 
> > !   option for including convective clouds in the all-sky assimilation
> >     cnvw_option=.false.
> > 
> > !   option to calculate hofx for T2m and q2m by interpolating from 2m vars in sfc file
> >     hofx_2m_sfcfile=.false.
> > 
> >     return
> >   end subroutine init_jfunc
> > 
> > 
> >   subroutine create_jfunc
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    create_jfunc
> > !   prgmmr: treadon          org: np23               date:  2003-11-24
> > !
> > ! abstract: allocate memory for cost function variables
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2004-07-28  treadon - simplify subroutine argument list
> > !   2005-03-28  wu - replace mlath with mlat, modify dim of varq 
> > !   2005-06-15  treadon - remove "use guess_grids"
> > !   2008-05-12  safford - rm unused uses
> > !   2013-10-25  todling - revisit variable initialization
> > !   2013-11-12  lueken - revisit logic around cwgues
> > !   2014-02-03  todling - CV length and B-dims here (no longer in observer)
> > !
> > !   input argument list:
> > !    mlat
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use constants, only: zero
> >     use gridmod, only: nsig,regional
> >     use m_berror_stats, only: berror_get_dims
> >     use m_berror_stats_reg, only: berror_get_dims_reg
> >     implicit none
> > 
> >     integer(i_kind) j,k
> >     integer(i_kind) msig,mlat,mlon 
> > 
> > !   Set length of control vector and other control vector constants
> >     call set_pointer
> > 
> > !   Allocate arrays used in minimization
> >     if(.not.regional)then                    ! If global, use msig, mlat, and mlon
> >        call berror_get_dims(msig,mlat,mlon)
> >     else                                     ! If regional, use msig and mlat only
> >        call berror_get_dims_reg(msig,mlat)
> >     endif
> > 
> >     call allocate_cv(xhatsave)
> >     call allocate_cv(yhatsave)
> >     xhatsave=zero
> >     yhatsave=zero
> > 
> >     if (getindex(cvars3d,'q')>0) then
> >         allocate(varq(1:mlat,1:nsig))
> >         do k=1,nsig
> >           do j=1,mlat
> >              varq(j,k)=zero
> >           end do
> >        end do
> >     endif
> > 
> >     allocate(varcw(1:mlat,1:nsig))
> >     do k=1,nsig
> >        do j=1,mlat
> >           varcw(j,k)=zero
> >        end do
> >     end do
> > 
> >     return
> >   end subroutine create_jfunc
> >     
> >   subroutine destroy_jfunc
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    destroy_jfunc
> > !   prgmmr: treadon          org: np23               date:  2003-11-24
> > !
> > ! abstract: deallocate memory from cost function variables
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2013-10-25  todling, revisit deallocs
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     implicit none
> > 
> >     call deallocate_cv(xhatsave)
> >     call deallocate_cv(yhatsave)
> >     if(allocated(varq)) deallocate(varq)
> >     if(allocated(varcw)) deallocate(varcw)
> > 
> >     return
> >   end subroutine destroy_jfunc
> > 
> >   subroutine read_guess_solution(diry,mype,success)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    read_guess_solution
> > !   prgmmr: treadon          org: np23               date:  2003-11-24
> > !
> > ! abstract: read in guess solution
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2005-05-05  treadon - read guess solution from 4-byte reals
> > !   2008-05-12  safford - rm unused uses and vars
> > !   2013-10-25  todling - reposition ltosi and others to commvars
> > !   2016-05-04  todling - allow for bias component of solution to be taken in
> > !
> > !   input argument list:
> > !     mype   - mpi task id
> > !     diry - dynamic components, e.g. %values(:), must be already allocated
> > !
> > !   output argument list:
> > !     diry
> > !     success - logical flag determining if input file was successfully read
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use kinds, only: r_single
> >     use mpimod, only: ierror, mpi_comm_world,mpi_real4
> >     use gridmod, only: nlat,nlon,nsig,itotsub,&
> >          displs_s,ijn_s,latlon11,iglobal
> >     use general_commvars_mod, only: ltosi_s,ltosj_s
> >     use obsmod, only: iadate
> >     implicit none
> > 
> >     integer(i_kind)     ,intent(in   ) :: mype
> >     type(control_vector),intent(inout) :: diry
> >     logical             ,intent(inout) :: success
> > 
> >     integer(i_kind) i,k,mm1,myper,kk,i1,i2
> >     integer(i_kind) nlatg,nlong,nsigg
> >     integer(i_kind) nxval,nxrclen,nxsclen,nxpclen
> >     integer(i_kind),dimension(5):: iadateg
> >     real(r_single),dimension(max(iglobal,itotsub)):: fieldy
> >     real(r_single),dimension(nlat,nlon):: yhatsave_g
> >     real(r_single),dimension(nclen):: yhatsave_r4
> >     
> >     mm1=mype+1
> >     myper=0
> > 
> > ! Open unit to guess solution.  Read header.  If no header, file is
> > ! empty and exit routine
> >     open(12,file='gesfile_in',form='unformatted')
> >     iadateg=0
> >     nlatg=0
> >     nlong=0
> >     nsigg=0
> >     read(12,end=1234)iadateg,nlatg,nlong,nsigg,nxval,nxrclen,nxsclen,nxpclen
> >     if(iadate(1) == iadateg(1) .and. iadate(2) == iadate(2) .and. &
> >        iadate(3) == iadateg(3) .and. iadate(4) == iadateg(4) .and. &
> >        iadate(5) == iadateg(5) .and. nlat == nlatg .and. &
> >        nxval == nval_levs_ens .and. &
> >        nlon == nlong .and. nsig == nsigg) then
> >        if(mype == 0) write(6,*)'READ_GUESS_SOLUTION:  read guess solution for ',&
> >                      iadateg,nlatg,nlong,nsigg,nxval,nxrclen,nxsclen,nxpclen
> >          
> > ! Let all tasks read gesfile_in to pick up bias correction (second read)
> >        if(nxsclen+nxpclen > 0)then
> >           if ( nxsclen==nsclen  .and. nxpclen == npclen) then
> >              read(12,end=1236) (yhatsave_r4(i),i=nclen1+1,nclen-ntclen)
> >              do i=nclen+1,nclen-ntclen
> >                 diry%values(i)=real(yhatsave_r4(i),r_kind)
> >              end do
> >           else
> >              read(12)
> >              if(mype == 0) then
> >                 write(6,*) 'READ_GUESS_SOLUTION:  INCOMPATABLE RADIANCE COMPONENT in GESFILE, gesfile_in'
> >                 write(6,*) 'READ_GUESS_SOLUTION:  nrclen: input,current=',nxsclen,nsclen,nxpclen,npclen
> >                 write(6,*) 'READ_GUESS_SOLUTION:  ignoring previous radiance guess'
> >              endif
> >           endif
> >        else
> >           if(mype == 0) write(6,*) ' No bias correction in restart file '
> >        endif
> > 
> > ! Loop to read input guess fields.  After reading in each field & level,
> > ! scatter the grid to the appropriate location in the xhat and yhatsave
> > ! arrays.
> >        do k=1,nval_levs_ens
> >           if(mype == myper)then
> >              read(12,end=1236) yhatsave_g
> >              do kk=1,itotsub
> >                 i1=ltosi_s(kk); i2=ltosj_s(kk)
> >                 fieldy(kk)=yhatsave_g(i1,i2)
> >              end do
> >           end if
> >           i=(k-1)*latlon11 + 1
> >           call mpi_scatterv(fieldy,ijn_s,displs_s,mpi_real4,&
> >                    yhatsave_r4(i),ijn_s(mm1),mpi_real4,myper,mpi_comm_world,ierror)
> >        end do  !end do over val_levs_ens`
> > 
> >        do i=1,nclen1
> >           diry%values(i)=real(yhatsave_r4(i),r_kind)
> >        end do
> >        success = .true.
> > 
> >     else
> >        read(12)
> >        if(mype == 0) then
> >           write(6,*) 'READ_GUESS_SOLUTION:  INCOMPATABLE GUESS FILE, gesfile_in'
> >           write(6,*) 'READ_GUESS_SOLUTION:  iguess,iadate,iadateg=',iguess,iadate,iadateg
> >           write(6,*) 'READ_GUESS_SOLUTION:  nlat,nlatg,nlon,nlong,nsig,nsigg=',&
> >                       nlat,nlatg,nlon,nlong,nsig,nsigg,nval_levs_ens,nxval
> >        end if
> >     endif
> >     close(12)
> >     return
> > 
> > ! The guess file is empty.  Do not return an error code but print a message to
> > ! standard out.
> > 1234 continue
> >     if(mype == 0) then
> >        write(6,*) 'READ_GUESS_SOLUTION:  NO GUESS FILE, gesfile_in'
> >        write(6,*) 'READ_GUESS_SOLUTION:  iguess,iadate,iadateg=',iguess,iadate,iadateg
> >        write(6,*) 'READ_GUESS_SOLUTION:  nlat,nlatg,nlon,nlong,nsig,nsigg=',&
> >                    nlat,nlatg,nlon,nlong,nsig,nsigg
> >     end if
> >     close(12)
> >     return
> > 
> > ! Error contition reading level or bias correction data.  Set error flag and
> > ! return to the calling program.
> > 1236 continue
> >     if (mype==0) write(6,*) 'READ_GUESS_SOLUTION:  ERROR in reading guess'
> >     close(12)
> >     call stop2(76)
> > 
> >     return
> >   end subroutine read_guess_solution
> >   
> >   subroutine write_guess_solution(mype)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    write_guess_solution
> > !   prgmmr: treadon          org: np23               date:  2003-11-24
> > !
> > ! abstract: write out guess solution (not from spectral forecast)
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2005-03-10  treadon - remove iadate from calling list, access via obsmod
> > !   2005-05-05  treadon - write guess solution using 4-byte reals
> > !   2008-05-12  safford - rm unused uses
> > !   2008-12-13  todling - strip2 called w/ consistent interface
> > !   2013-10-25  todling - reposition ltosi and others to commvars
> > !
> > !   input argument list:
> > !     mype   - mpi task id
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use kinds, only: r_single
> >     use mpimod, only: ierror, mpi_comm_world, mpi_real4
> >     use gridmod, only: ijn,latlon11,displs_g,nsig,&
> >          nlat,nlon,lat1,lon1,itotsub,iglobal
> >     use general_commvars_mod, only: ltosj,ltosi 
> >     use obsmod, only: iadate
> >     use constants, only: zero
> >     implicit none
> > 
> >     integer(i_kind),intent(in   ) :: mype
> > 
> >     integer(i_kind) i,j,k,mm1,mypew,kk,i1,i2,ie,is
> >     real(r_single),dimension(lat1,lon1):: field
> >     real(r_single),dimension(max(iglobal,itotsub)):: fieldy
> >     real(r_single),dimension(nlat,nlon):: yhatsave_g
> >     real(r_single),dimension(nrclen):: yhatsave4
> >     integer :: nxr,nxs,nxp
> >     logical :: writebias
> > 
> >     mm1=mype+1
> >     mypew=0
> >     writebias=.false.
> >     if(writebias)then
> >        nxr=nrclen
> >        nxs=nsclen
> >        nxp=npclen
> >     else
> >       nxr=0
> >       nxs=0
> >       nxp=0
> >     end if
> >     
> > ! Write header record to output file
> >     if (mype==mypew) then
> >        open(51,file='gesfile_out',form='unformatted')
> >        write(51) iadate,nlat,nlon,nsig,nval_levs_ens,nxr,nxs,nxp
> >     endif
> > 
> > ! Write radiance and precipitation bias correction terms to output file
> >     if (mype==mypew .and. nsclen+npclen > 0 .and. writebias) then
> >        do i=1,nsclen+npclen
> >           yhatsave4(i)=yhatsave%values(nclen1+i)
> >        end do
> >        write(51) (yhatsave4(i),i=1,nsclen+npclen)
> >     end if
> > 
> > ! Loop over levels.  Gather guess solution and write to output
> >     do k=1,nval_levs_ens
> >        ie=(k-1)*latlon11 + 1
> >        is=ie+latlon11
> >        call strip1(yhatsave%values(ie:is),field)
> >        call mpi_gatherv(field,ijn(mm1),mpi_real4,&
> >             fieldy,ijn,displs_g,mpi_real4,mypew,&
> >             mpi_comm_world,ierror)
> > 
> >        if(mype == mypew)then
> > ! Transfer to global arrays
> >           do j=1,nlon
> >              do i=1,nlat
> >                 yhatsave_g(i,j)=zero
> >              end do
> >           end do
> >           do kk=1,iglobal
> >              i1=ltosi(kk); i2=ltosj(kk)
> >              yhatsave_g(i1,i2)=fieldy(kk)
> >           end do
> > 
> > ! Write level record
> >           write(51) yhatsave_g
> >        end if
> >     end do  !end do over nval_levs_ens
> > 
> >     if(mype==mypew)then
> >        close(51)
> >        write(6,*)'WRITE_GUESS_SOLUTION:  write guess solution for ',&
> >                   iadate,nlat,nlon,nsig,nxr,nxs,nxp
> >     endif
> > 
> >     return
> >   end subroutine write_guess_solution
> >     subroutine strip1(field_in1,field_out)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    strip1
> > !   prgmmr: treadon          org: np23                date: 2003-11-24
> > !
> > ! abstract: strip off halo from two subdomain arrays & combine into
> > !           single output array
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2008-05-12  safford - rm unused uses
> > !
> > !   input argument list:
> > !     field_in1 - subdomain field with halo
> > !
> > !   output argument list:
> > !     field_out - combined subdomain fields with halo stripped
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use kinds, only: r_single
> >     use gridmod, only: lat1,lon1,lat2,lon2
> >     implicit none
> > 
> >     real(r_single),dimension(lat1,lon1),intent(  out) :: field_out
> >     real(r_kind)  ,dimension(lat2,lon2),intent(in   ) :: field_in1
> > 
> >     integer(i_kind) i,j,jp1
> > 
> > 
> >     do j=1,lon1
> >        jp1 = j+1
> >        do i=1,lat1
> >           field_out(i,j)=field_in1(i+1,jp1)
> >        end do
> >     end do
> > 
> >     return
> >   end subroutine strip1
> > 
> >     subroutine strip2(field_in1,field_in2,field_out)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    strip2
> > !   prgmmr: treadon          org: np23                date: 2003-11-24
> > !
> > ! abstract: strip off halo from two subdomain arrays & combine into
> > !           single output array
> > !
> > ! program history log:
> > !   2003-11-24  treadon
> > !   2004-05-18  kleist, documentation
> > !   2008-05-12  safford - rm unused uses
> > !
> > !   input argument list:
> > !     field_in1 - subdomain field one with halo
> > !     field_in2 - subdomain field two with halo
> > !
> > !   output argument list:
> > !     field_out - combined subdomain fields with halo stripped
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use kinds, only: r_single
> >     use gridmod, only: lat1,lon1,lat2,lon2
> >     implicit none
> > 
> >     real(r_single),dimension(lat1,lon1,2),intent(  out) :: field_out
> >     real(r_kind)  ,dimension(lat2,lon2)  ,intent(in   ) :: field_in1,field_in2
> > 
> >     integer(i_kind) i,j,jp1
> > 
> > 
> >     do j=1,lon1
> >        jp1 = j+1
> >        do i=1,lat1
> >           field_out(i,j,1)=field_in1(i+1,jp1)
> >           field_out(i,j,2)=field_in2(i+1,jp1)
> >        end do
> >     end do
> > 
> >     return
> >   end subroutine strip2
> > 
> >   subroutine set_pointer
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    set_pointer
> > !   prgmmr: treadon          org: np23                date: 2004-07-28
> > !
> > ! abstract: Set length of control vector and other control 
> > !           vector constants
> > !
> > ! program history log:
> > !   2004-07-28  treadon
> > !   2006-04-21  kleist - include pointers for more time tendency arrays
> > !   2008-12-04  todling - increase number of 3d fields from 6 to 8 
> > !   2009-09-16  parrish - add hybrid_ensemble connection in call to setup_control_vectors
> > !   2010-03-01  zhu     - add nrf_levb and nrf_leve, generalize nval_levs
> > !                       - generalize vector starting points such as nvpsm, nst2, and others
> > !   2010-05-23  todling - remove pointers such as nvpsm, nst2, and others (intro on 10/03/01)
> > !                       - move nrf_levb and nrf_leve to anberror where they are needed
> > !   2010-05-29  todling - generalized count for number of levels in state variables
> > !   2013-10-22  todling - revisit level count in view of changes to bundle
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >     use gridmod, only: latlon11,latlon1n,nsig,lat2,lon2
> >     use gridmod, only: nnnn1o,regional,nlat,nlon
> >     use radinfo, only: npred,jpch_rad
> >     use pcpinfo, only: npredp,npcptype
> >     use aircraftinfo, only: npredt,ntail,aircraft_t_bc_pof,aircraft_t_bc
> >     use state_vectors, only: ns2d,levels
> >     use constants, only : max_varname_length
> >     use gsi_4dvar, only: nsubwin, lsqrtb
> >     use bias_predictors, only: setup_predictors
> >     use hybrid_ensemble_parameters, only: l_hyb_ens,n_ens,generate_ens,grd_ens,nval_lenz_en
> >     use hybrid_ensemble_parameters, only: naensgrp
> >     implicit none
> > 
> >     integer(i_kind) n_ensz,nval_lenz_tot,nval_lenz_enz
> > 
> >     nvals_levs=ns2d+sum(levels)
> >     nvals_len=nvals_levs*latlon11
> > 
> >     nval_levs=max(0,nc3d)*nsig+max(0,nc2d)
> >     nval_len=nval_levs*latlon11
> >     if(l_hyb_ens) then
> >        nval_len=nval_len+naensgrp*n_ens*nsig*grd_ens%latlon11
> >        nval_levs_ens=nval_levs+naensgrp*n_ens*nsig
> >     end if
> >     nsclen=npred*jpch_rad
> >     npclen=npredp*npcptype
> >     if (aircraft_t_bc_pof .or. aircraft_t_bc) then 
> >        ntclen=npredt*ntail
> >     else
> >        ntclen=0
> >     end if
> >     nclen=nsubwin*nval_len+nsclen+npclen+ntclen
> >     nrclen=nsclen+npclen+ntclen
> >     nclen1=nclen-nrclen
> >     nclen2=nclen1+nsclen
> >   
> >     n_ensz=0
> >     nval_lenz_enz=0
> >     if(lsqrtb.or.(l_hyb_ens.and.generate_ens)) then
> >        if(regional) then
> >           nval2d=nlat*nlon*3
> >        else
> >           call set_sqrt_2dsize(nval2d)
> >        end if
> >        nval_lenz=nval2d*nnnn1o
> >        nval_lenz_tot=nval_lenz
> >        if(lsqrtb.and.l_hyb_ens) then
> >           n_ensz=n_ens
> >           nval_lenz_enz=nval_lenz_en
> >           nval_lenz_tot=nval_lenz+n_ensz*nval_lenz_enz
> >        endif
> >        nclenz=nsubwin*nval_lenz_tot+nsclen+npclen+ntclen
> >     else
> >        nval2d=latlon11
> >     end if
> > 
> >     if (lsqrtb) then
> >        CALL setup_control_vectors(nsig,lat2,lon2,latlon11,latlon1n, &
> >                                   nsclen,npclen,ntclen,nclenz,nsubwin,nval_lenz,lsqrtb,n_ensz, &
> >                                   nval_lenz_enz)
> >     else
> >        CALL setup_control_vectors(nsig,lat2,lon2,latlon11,latlon1n, &
> >                                   nsclen,npclen,ntclen,nclen,nsubwin,nval_len,lsqrtb,n_ens, &
> >                                   nval_lenz_enz)
> >     endif
> >     CALL setup_predictors(nrclen,nsclen,npclen,ntclen)
> >     CALL setup_state_vectors(latlon11,latlon1n,nvals_len,lat2,lon2,nsig)
> > 
> >   end subroutine set_pointer
> > 
> >   subroutine set_sqrt_2dsize(ndim2d)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    set_sqrt_2dsize
> > !   prgmmr: todling          org: np23                date: 2011-09-05
> > !
> > ! abstract: Calculates size of 2d-component of control vector in sqrt-B
> > !           case. This being an independent call allows using ckgcov
> > !           within context of B-precond.
> > !
> > ! program history log:
> > !   2011-09-05  todling - move as independent piece out of set_pointer
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !     ndim2d - size of 2d component of control vector in sqrt-B case
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:  ibm rs/6000 sp
> > !
> > !$$$
> >   use kinds, only: i_kind
> >   use gridmod, only: nlat,nlon
> >   implicit none
> >   integer(i_kind),intent(out):: ndim2d
> >   integer(i_kind) nx,ny,mr,nr,nf
> > !           following lifted from subroutine create_berror_vars in module berror.f90
> > !            inserted because create_berror_vars called after this routine
> >      nx=nlon*3/2
> >      nx=nx/2*2
> >      ny=nlat*8/9
> >      ny=ny/2*2
> >      if(mod(nlat,2)/=0)ny=ny+1
> >      mr=0
> >      nr=nlat/4
> >      nf=nr
> >      ndim2d=(ny*nx + 2*(2*nf+1)*(2*nf+1))*3
> >   end subroutine set_sqrt_2dsize
> > 
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: jgrad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: kinds.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: lag_fields.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: lag_interp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: lagmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: lag_traj.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: lanczos.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: lightinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: logcldch_to_cldch.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: loglcbas_to_lcbas.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: logvis_to_vis.f90
> diff -r ./looplimits.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/looplimits.f90
> 28c28
> <       use m_kinds, only: i_kind
> ---
> >       use kinds, only: i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_aerolNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_aeroNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: make_depend.bash
> diff -r ./m_berror_stats.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/m_berror_stats.f90
> 14d13
> < !   2014-04-01  weir    - added some chem support
> 38c37
> <    use m_kinds,        only: i_kind,r_kind
> ---
> >    use kinds,          only : i_kind
> 41,47c40
> <    use mpeu_util,      only: getindex,check_iostat,die
> < 
> <    use m_nc_berror, only: nc_berror_dims
> <    use m_nc_berror, only: nc_berror_read
> <    use m_nc_berror, only: nc_berror_vars
> <    use m_nc_berror, only: nc_berror_vars_final
> <    use m_nc_berror, only: nc_berror_getpointer
> ---
> >    use mpeu_util,      only: getindex,check_iostat
> 53c46,49
> <    ! reconfigurable parameters, via NAMELIST/setup/
> ---
> > !   def usenewgfsberror - use modified gfs berror stats for global and regional.
> > !                        for global skips extra record
> > !                        for regional properly defines array sizes, etc.
> > !   def berror_stats  - reconfigurable filename via NAMELIST/setup/
> 62,66d57
> <    public :: berror_init     ! initialize internal variables
> <    public :: berror_final    ! finalize internal variables
> < 
> <    public :: varq
> <    public :: varcw
> 73,74d63
> <    interface berror_init;     module procedure init_;    end interface
> <    interface berror_final;    module procedure final_;   end interface
> 88d76
> < !       30Aug21 - Todling - introduce netcdf capability
> 96d83
> <    character(len=256),save :: berror_stats = "berror_stats"      ! filename
> 100,103c87
> <    logical,save :: bin_berror=.false.
> < 
> <    real(r_kind),allocatable,dimension(:,:):: varq
> <    real(r_kind),allocatable,dimension(:,:):: varcw
> ---
> >    character(len=256),save :: berror_stats = "berror_stats"      ! filename
> 107,126d90
> < subroutine init_(mlat,msig)
> <    use gridmod,  only: nsig
> <    integer,intent(in) :: mlat,msig
> <    if(.not.allocated(varq)) then
> <      if (getindex(cvars3d,'q')>0) then
> <         allocate(varq(mlat,nsig))
> <         varq=zero
> <      endif
> <    endif
> <    if(.not.allocated(varcw)) then
> <       allocate(varcw(mlat,nsig))
> <       varcw=zero
> <    endif
> < end subroutine init_
> < 
> < subroutine final_
> <   if(allocated(varq))  deallocate(varq)
> <   if(allocated(varcw)) deallocate(varcw)
> < end subroutine final_
> < 
> 137c101
> < subroutine get_dims(mype,msig,mlat,mlon,lunit)
> ---
> > subroutine get_dims(msig,mlat,mlon,lunit)
> 141d104
> <    integer(i_kind)         ,intent(   in) :: mype  ! proc identifier
> 154,178c117
> <    integer(i_kind) :: inerr,mlon_,status
> < 
> < !  Try reading as NetCDF ...
> <    if(mype==0) print*, myname_, ": Try reading berror from NetCDF file"
> <    call nc_(status)
> <    if (status==0) then
> <       if(mype==0) print*, myname_, ": Reading berror from NetCDF file"
> <       bin_berror = .false.
> <    else ! if failed, read as NetCDF
> <      call bin_(status)
> <      if (status==0) then
> <         bin_berror = .true.
> <         if(mype==0) print*, myname_, ": Read berror from Binary file"
> <      else
> <         if(mype==0) call die(myname_,'Failed reading Berror file', 99)
> <      endif
> <    endif
> <    if ( present(mlon) ) mlon = mlon_
> < 
> <    return
> < 
> <    contains
> < 
> <    subroutine bin_(ier)
> <    integer,intent(inout) :: ier
> ---
> >    integer(i_kind) :: inerr,mlon_,ier
> 187d125
> <    if (ier/=0) return
> 190a129
> >    if ( present(mlon) ) mlon = mlon_
> 193,206d131
> <    end subroutine bin_
> < 
> <    subroutine nc_(ier)
> <    integer,intent(inout) :: ier
> < 
> <    integer :: mlat_, mlev_
> < 
> <    call nc_berror_dims (berror_stats,mlat_,mlon_,mlev_,ier, mype,0)
> < 
> <    mlat = mlat_
> <    msig = mlev_
> < 
> <    return
> <    end subroutine nc_
> 211c136
> <    use m_kinds,    only: r_single
> ---
> >    use kinds,    only: r_single
> 304c229
> <    use m_kinds,    only: r_single
> ---
> >    use kinds,    only: r_single
> 332,344d256
> <    ier=0
> <    if (bin_berror) then
> <       call bin_
> <    else
> <       call nc_(mype)
> <    endif
> < 
> <    return
> < 
> <    contains
> < 
> <    subroutine bin_
> < 
> 356d267
> <    if (ier/=0) return
> 358a270,271
> > !  dummy read to skip lats,sigma
> >    if(usenewgfsberror)read(inerr)
> 388,406c301
> <    end subroutine bin_
> < 
> <    subroutine nc_(myid)
> <    integer, intent(in) :: myid
> <    type(nc_berror_vars) bvars
> <    if ( fut2ps ) then
> <       call die(myname_," fut2ps not available in this form "//trim(berror_stats), 99)
> <    endif
> <    call nc_berror_read (berror_stats,bvars,ier, myid=myid,root=0)
> <    if (nlat/=bvars%nlat .or. nsig/=bvars%nsig ) then
> <       call die(myname_," inconsistent dims in "//trim(berror_stats), 99)
> <    endif
> <    agvin = bvars%tcon
> <    bvin  = bvars%vpcon
> <    wgvin = bvars%pscon
> <    pputin=zero
> <    call nc_berror_vars_final(bvars)
> <    end subroutine nc_
> < 
> ---
> >    return
> 419,420c314
> < subroutine read_wgt(corz,corp,hwll,hwllp,vz,corsst,hsst,qoption,cwoption,mype, &
> <                     n_clouds_fwd,cloud_names_fwd,lunit)
> ---
> > subroutine read_wgt(corz,corp,hwll,hwllp,vz,corsst,hsst,varq,qoption,varcw,cwoption,mype,lunit)
> 422c316
> <    use m_kinds,only : r_single,r_kind
> ---
> >    use kinds,only : r_single,r_kind
> 424c318
> < !_RT  use radiance_mod, only: n_clouds_fwd,cloud_names_fwd
> ---
> >    use radiance_mod, only: n_clouds_fwd,cloud_names_fwd
> 437a332,334
> >    real(r_kind),  dimension(:,:)      ,intent(out  ) :: varq
> >    real(r_kind),  dimension(:,:)      ,intent(out  ) :: varcw
> > 
> 441,442d337
> < 
> < !  Optionals
> 444,445d338
> <    integer(i_kind), optional          ,intent(in   ) :: n_clouds_fwd 
> <    character(len=*),optional          ,intent(in   ) :: cloud_names_fwd(:)
> 473c366
> <    integer(i_kind) :: nsigstat,nlatstat
> ---
> >    integer(i_kind) :: nsigstat,nlatstat,mlon_
> 479a373
> > !  real(r_single),allocatable,dimension(:)  :: clat,sigma
> 485,566d378
> <    allocate(found3d(size(cvars3d)),found2d(size(cvars2d)))
> <    found3d=.false.
> <    found2d=.false.
> < 
> <    if ( bin_berror ) then
> <      call bin_()
> <    else
> <      call nc_(mype)
> <    endif
> < 
> <    ! corz, hwll & vz for undefined 3d variables
> <    do n=1,size(cvars3d)
> <       if ( .not.found3d(n) ) then
> <          if ( n>0 ) then
> <             if ( trim(cvars3d(n))=='oz' ) then
> <                call setcoroz_(corz(:,:,n),mype)
> <                call sethwlloz_(hwll(:,:,n),mype)
> <             else
> <                call setcorchem_(cvars3d(n),corz(:,:,n),ier)
> <                call sethwllchem_(hwll(:,:,n),mype)
> <                if(ier/=0) cycle ! if this happens, code will crash later
> <             endif
> <             call setvscalesoz_(vz(:,:,n))
> <          endif
> <          if ( mype==0 ) write(6,*) myname_, ': WARNING, using general Berror template for ', cvars3d(n)
> <       endif
> <    enddo
> < 
> < !  if so, overwrite cw-cov with q-cov
> <    iq=-1;icw=-1
> <    do n=1,size(cvars3d)
> <       if(trim(cvars3d(n))=='q' ) iq =n
> <       if(trim(cvars3d(n))=='cw') icw=n
> <    enddo
> <    if (cwcoveqqcov_) then
> <       if(iq>0.and.icw>0) then
> <         hwll(:,:,icw)=hwll(:,:,iq)
> <         vz  (:,:,icw)=vz  (:,:,iq)
> <       end if
> <    end if
> <    if (cwoption==1 .or. cwoption==3) then
> <       if (iq>0.and.icw>0) then
> <          do k=1,nsig
> <             do i=1,nlat
> <                corz(i,k,icw)=one
> <             end do
> <          end do
> <          hwll(:,:,icw)=0.5_r_kind*hwll(:,:,iq)
> <          vz  (:,:,icw)=0.5_r_kind*vz  (:,:,iq)
> <       end if 
> < 
> <       if (present(n_clouds_fwd) .and. present(cloud_names_fwd)) then
> <        if (n_clouds_fwd>0 .and. icw<=0) then
> <          do n=1,size(cvars3d)
> <             do ic=1,n_clouds_fwd
> <                if(trim(cvars3d(n))==trim(cloud_names_fwd(ic))) then
> <                   ivar=n
> <                   do k=1,nsig
> <                      do i=1,nlat
> <                         corz(i,k,ivar)=one
> <                      end do
> <                   end do
> <                   hwll(:,:,ivar)=0.5_r_kind*hwll(:,:,iq)
> <                   vz  (:,:,ivar)=0.5_r_kind*vz  (:,:,iq)
> <                   exit
> <                end if   
> <             end do
> <          end do
> <        end if
> <       end if
> <    endif
> < 
> <    ! need simliar general template for undefined 2d variables ...
> < 
> <    deallocate(found3d,found2d)
> < 
> <   return
> <  
> <   contains
> < 
> <   subroutine bin_
> < 
> 577c389
> <    read(inerr,iostat=ier)nsigstat,nlatstat
> ---
> >    read(inerr,iostat=ier)nsigstat,nlatstat,mlon_
> 578a391
> >    if(usenewgfsberror)read(inerr,iostat=ier)
> 596a410,412
> >    allocate(found3d(size(cvars3d)),found2d(size(cvars2d)))
> >    found3d=.false.
> >    found2d=.false.
> 687a504,519
> >    ! corz, hwll & vz for undefined 3d variables
> >    do n=1,size(cvars3d)
> >       if ( .not.found3d(n) ) then
> >          if ( n>0 ) then
> >             if ( cvars3d(n)=='oz' ) then
> >                call setcoroz_(corz(:,:,n),mype)
> >             else
> >                call setcorchem_(cvars3d(n),corz(:,:,n),ier)
> >                if ( ier/=0 ) cycle ! if this happens, code will crash later
> >             endif
> >             call sethwlloz_(hwll(:,:,n),mype)
> >             call setvscalesoz_(vz(:,:,n))
> >          endif
> >          if ( mype==0 ) write(6,*) myname_, ': WARNING, using general Berror template for ', cvars3d(n)
> >       endif
> >    enddo
> 689,691c521,542
> <   end subroutine bin_
> < 
> <   subroutine nc_(myid)
> ---
> > !  if so, overwrite cw-cov with q-cov
> >    iq=-1;icw=-1
> >    do n=1,size(cvars3d)
> >       if(trim(cvars3d(n))=='q' ) iq =n
> >       if(trim(cvars3d(n))=='cw') icw=n
> >    enddo
> >    if (cwcoveqqcov_) then
> >       if(iq>0.and.icw>0) then
> >         hwll(:,:,icw)=hwll(:,:,iq)
> >         vz  (:,:,icw)=vz  (:,:,iq)
> >       end if
> >    end if
> >    if (cwoption==1 .or. cwoption==3) then
> >       if (iq>0.and.icw>0) then
> >          do k=1,nsig
> >             do i=1,nlat
> >                corz(i,k,icw)=one
> >             end do
> >          end do
> >          hwll(:,:,icw)=0.5_r_kind*hwll(:,:,iq)
> >          vz  (:,:,icw)=0.5_r_kind*vz  (:,:,iq)
> >       end if 
> 693,700c544,560
> <    integer,intent(in) :: myid
> <    type(nc_berror_vars) bvars
> <    real(r_single), pointer :: ptr1d(:)
> <    real(r_single), pointer :: ptr2d(:,:)
> <    integer :: nv 
> <    call nc_berror_read (berror_stats,bvars,ier, myid=myid,root=0)
> <    if (nlat/=bvars%nlat .or. nlon/=bvars%nlon .or.  nsig/=bvars%nsig ) then
> <       call die(myname_," inconsistent dims in "//trim(berror_stats), 99)
> ---
> >       if (n_clouds_fwd>0 .and. icw<=0) then
> >          do n=1,size(cvars3d)
> >             do ic=1,n_clouds_fwd
> >                if(trim(cvars3d(n))==trim(cloud_names_fwd(ic))) then
> >                   ivar=n
> >                   do k=1,nsig
> >                      do i=1,nlat
> >                         corz(i,k,ivar)=one
> >                      end do
> >                   end do
> >                   hwll(:,:,ivar)=0.5_r_kind*hwll(:,:,iq)
> >                   vz  (:,:,ivar)=0.5_r_kind*vz  (:,:,iq)
> >                   exit
> >                end if   
> >             end do
> >          end do
> >       end if
> 702d561
> <    isig=bvars%nsig
> 704,784c563,565
> < !  RTodling: the following is bad since it wires all naming conventions ... to be revised
> <    do nv=1,size(cvars2d)
> <       if (trim(cvars2d(nv))=='sst') then
> <          n = getindex(cvars2d,'sst')
> <          found2d(n)=.true.
> <          call nc_berror_getpointer (cvars2d(nv),bvars,ptr2d,ier)
> <          if(ier==0) corsst=ptr2d
> <          call nc_berror_getpointer ('h'//cvars2d(nv),bvars,ptr2d,ier)
> <          if(ier==0) hsst=ptr2d
> <       endif
> <       if (trim(cvars2d(nv))=='ps') then
> <          n = getindex(cvars2d,'ps')
> <          found2d(n)=.true.
> <          call nc_berror_getpointer (cvars2d(nv),bvars,ptr1d,ier)
> <          if(ier==0) corp(:,n)=ptr1d
> <          call nc_berror_getpointer ('h'//cvars2d(nv),bvars,ptr1d,ier)
> <          if(ier==0) hwllp(:,n)=ptr1d
> <       endif
> <    enddo
> <    do nv=1,size(cvars3d)
> <       call nc_berror_getpointer (cvars3d(nv),bvars,ptr2d,ier)
> <       if (ier==0) then
> <           n = getindex(cvars3d,cvars3d(nv))
> <           found3d(n)=.true.
> <           corz(:,:,n)=ptr2d
> <           call nc_berror_getpointer ('h'//trim(cvars3d(nv)),bvars,ptr2d,ier)
> <           if(ier==0) hwll(:,:,n)=ptr2d
> <           call nc_berror_getpointer ('v'//trim(cvars3d(nv)),bvars,ptr2d,ier)
> <           if(ier==0) vz(:,:,n)=transpose(ptr2d)
> <           if (trim(cvars3d(nv))=='cw' .and. cwoption==2) then
> <              allocate(corq2(bvars%nlat,bvars%nsig))
> <              call nc_berror_getpointer ('nrh',bvars,ptr2d,ier)
> <              if (ier==0) then
> <                 corq2=ptr2d
> <                 do k=1,bvars%nsig
> <                    do i=1,bvars%nlat
> <                       corq2x=corq2(i,k)
> <                       varcw(i,k)=max(corq2x,zero)
> <                    enddo
> <                 enddo
> <              else
> <                 call die(myname_," in cw, failed to find bvar nrh ", 99)
> <              endif
> <              corz(:,:,n)=one
> <              deallocate(corq2)
> <           endif
> <           if (trim(cvars3d(nv))=='q' .and. qoption==2) then
> <              allocate(corq2(bvars%nlat,bvars%nsig))
> <              call nc_berror_getpointer ('nrh',bvars,ptr2d,ier)
> <              if (ier==0) then
> <                 corq2=ptr2d
> < !               corq2=max(0.0_r_kind,corq2) ! hack 1
> < !               corq2=min(1.0_r_kind,2*corq2) ! hack 2
> < !               print *, 'DEBUG (berr): ', minval(corq2),maxval(corq2)
> <                 do k=1,bvars%nsig
> <                    do i=1,bvars%nlat
> <                       corq2x=corq2(i,k)
> <                       varq(i,k)=min(max(corq2x,0.00015_r_kind),one)
> <                    enddo
> <                 enddo
> <              else
> <                 call die(myname_," in q, failed to find bvar nrh ", 99)
> <              endif
> <              corz(:,:,n)=one
> <              deallocate(corq2)
> <           endif
> <           cycle
> <       endif
> <       if (trim(cvars3d(nv))=='q') then
> <           n = getindex(cvars3d,'q')
> <           found3d(n)=.true.
> <           corz(:,:,n)=bvars%qvar
> <           if (qoption == 2) then
> <           endif
> <           hwll(:,:,n)=bvars%qhln
> <           vz(:,:,n)=transpose(bvars%qvln)
> <           cycle
> <       endif
> <    enddo
> <    call nc_berror_vars_final(bvars)
> <   end subroutine nc_
> ---
> >    ! need simliar general template for undefined 2d variables ...
> > 
> >    deallocate(found3d,found2d)
> 785a567
> >   return
> 800c582
> <    use m_kinds,    only: r_single,r_kind
> ---
> >    use kinds,    only: r_single,r_kind
> 802c584
> <    use m_mpimod,   only: npe,mpi_rtype,mpi_sum,gsi_mpi_comm_world
> ---
> >    use mpimod,   only: npe,mpi_rtype,mpi_sum,mpi_comm_world
> 867c649
> <    work_oz(nsig+1,mm1)=float(lon1*lat1)
> ---
> >    work_oz(nsig+1,mm1)=real(lon1*lat1,r_kind)
> 870c652
> <       gsi_mpi_comm_world,ierror)
> ---
> >       mpi_comm_world,ierror)
> 915,916c697,698
> <    use m_kinds,    only: r_single,r_kind
> <    use m_mpimod,   only: levs_id
> ---
> >    use kinds,    only: r_single,r_kind
> >    use mpimod,   only: levs_id
> 946c728
> <       if(mype==0) write(6,*) myname_,'(PREWGT): mype = ',mype, k1
> ---
> >       write(6,*) myname_,'(PREWGT): mype = ',mype, k1
> 975c757
> <    use m_kinds,  only: r_single,r_kind
> ---
> >    use kinds,  only: r_single,r_kind
> 1009,1010c791,792
> <    use m_kinds,    only: r_single,r_kind
> <    use m_mpimod,   only: mype
> ---
> >    use kinds,    only: r_single,r_kind
> >    use mpimod,   only: mype
> 1012c794
> <    use m_mpimod,   only: npe,mpi_rtype,mpi_sum,gsi_mpi_comm_world
> ---
> >    use mpimod,   only: npe,mpi_rtype,mpi_sum,mpi_comm_world
> 1030,1032c812
> < !    15Jul2010 - Todling - created from Guo's OZ routine
> < !    20Apr2015 - Weir    - relaced chemz with a constant, old approach
> < !                          wasn't appropriate for CO
> ---
> > !    15Jul20010 - Todling - created from Guo's OZ routine
> 1092c872
> <    work_chem(nsig+1,mm1)=float(lon1*lat1)
> ---
> >    work_chem(nsig+1,mm1)=real(lon1*lat1,r_kind)
> 1095c875
> <         gsi_mpi_comm_world,ierror)
> ---
> >         mpi_comm_world,ierror)
> 1115,1118c895
> < !      Not appropriate for co, just replacing with a constant, will revisit
> < !      later (bweir)
> < !      if (bsum>zero) chemz(k)=asum/bsum
> <       chemz(k) = 1._r_kind
> ---
> >       if ( bsum>zero ) chemz(k)=asum/bsum
> 1133,1190d909
> < !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> < ! NASA/GSFC, Global Modeling and Assimilation Office, 900.3, GEOS/DAS  !
> < !BOP -------------------------------------------------------------------
> < !
> < ! !IROUTINE: sethwllchem_ - a modeled hwll of chem
> < !
> < ! !DESCRIPTION:
> < !
> < ! !INTERFACE:
> < 
> <    subroutine sethwllchem_(hwll, mype)
> < 
> <       use m_kinds,     only: r_single, r_kind
> <       use m_mpimod,    only: levs_id
> <       use gridmod,   only: nnnn1o, nsig, nlon, nlat
> <       use constants, only: two, three, pi, rearth_equator
> < 
> <       implicit none
> < 
> <       real(r_single),  intent(  out) :: hwll(nlat,nsig)
> <       integer(i_kind), intent(in   ) :: mype
> < 
> < ! !REVISION HISTORY:
> < !       20May14 - Weir    - Initial code, based on sethwlloz_
> < !EOP ___________________________________________________________________
> < 
> <       character(len=*), parameter :: myname_ = myname//'::sethwllchem_'
> < 
> <       real(r_kind),     parameter :: r400    =   400._r_kind
> <       real(r_kind),     parameter :: r800    =   800._r_kind
> <       real(r_kind),     parameter :: r40000  = 40000._r_kind
> < 
> <       integer(i_kind) :: k, k1
> <       real(r_kind)    :: fact
> <       real(r_kind)    :: s2u
> <     
> <       if (mype == 0) then
> <          write(6,*) myname_, '(PREWGT): mype = ', mype
> <       end if
> < 
> <       s2u = (two*pi*rearth_equator)/nlon
> <       do k = 1,nnnn1o
> <          k1 = levs_id(k)
> <          if (k1 > 0) then
> <             if (mype == 0) write(6,*) myname_, '(PREWGT): mype = ', mype, k1
> < !           make everything constant
> < !           fact = real(k1,r_kind)**2._r_kind
> <             fact = 1._r_kind
> <             fact = r40000/(r400*nlon*fact)
> <             hwll(:,k1) = s2u/fact
> <          end if
> <       end do
> < 
> <       if (mype == 0) then
> <          write(6,*) myname_, '(PREWGT): mype = ', mype, 'finish sethwllchem_'
> <       end if
> < 
> <    end subroutine sethwllchem_
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_berror_stats_reg.f90
> Only in ./: m_berror_stats_reg.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_cldchNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_colvkNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_cvgridLookup.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_dbzNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_dgeevx.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_distance.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_dtime.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_dwNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_extOzone.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_fedNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_find.f90
> Only in ./: m_fitcons.f90
> Only in ./: m_gbc4saber.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_gpsNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_gpsrhs.F90
> Only in ./: m_grid2sub1var.f90
> Only in ./: m_gsibec.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_gsiBiases.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_gustNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_howvNode.F90
> Only in ./: m_kinds.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_lagNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_latlonRange.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_lcbasNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_lightNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_lwcpNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_mitmNode.F90
> Only in ./: m_mpimod.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_mxtmNode.F90
> Only in ./: m_nc_berror.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_o3lNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_obsdiagNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_obsdiags.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_obsLList.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_obsNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_obsNodeTypeManager.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: model_ad.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: model_tl.F90
> diff -r ./mod_fv3_lola.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/mod_fv3_lola.f90
> 66c66
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 70c70
> <   public :: generate_anl_grid,m_generate_anl_grid,fv3_h_to_ll,fv3_ll_to_h,fv3uv2earth,earthuv2fv3
> ---
> >   public :: generate_anl_grid,fv3_h_to_ll,fv3_ll_to_h,fv3uv2earth,earthuv2fv3
> 126c126
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 131c131
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 212,215c212,213
> <   !nlat=nya
> <   !nlon=nxa
> <   nlat=ny
> <   nlon=nx
> ---
> >   nlat=nya
> >   nlon=nxa
> 596,832d593
> < subroutine m_generate_anl_grid(nx,ny,grid_lon,grid_lont,grid_lat,grid_latt,gsi_lats,gsi_lons)
> < !$$$  subprogram documentation block
> < !                .      .    .                                       .
> < ! subprogram:    generate_anl_grid
> < !   prgmmr: parrish
> < !
> < ! abstract:  define rotated lat-lon analysis grid which is centered on fv3 tile 
> < !             and oriented to completely cover the tile.
> < !
> < ! program history log:
> < !   2017-05-02  parrish
> < !   2017-10-10  wu   - 1. setup analysis A-grid, 
> < !                      2. compute/setup FV3 to A grid interpolation parameters
> < !                      3. compute/setup A to FV3 grid interpolation parameters         
> < !                      4. setup weightings for wind conversion from FV3 to earth
> < !   2019-11-01  wu   - add checks to present the mean longitude correctly to fix
> < !                       problem near lon=0
> < !
> < !   2021-08-11   lei - a fix for an upper bound of the dimnsion of  a3jyp 
> < !   input argument list:
> < !    nx, ny               - number of cells = nx*ny 
> < !    grid_lon ,grid_lat   - longitudes and latitudes of fv3 grid cell corners
> < !    grid_lont,grid_latt  - longitudes and latitudes of fv3 grid cell centers
> < !
> < !   output argument list:
> < !
> < ! attributes:
> < !   language: f90
> < !   machine:
> < !
> < !$$$ end documentation block
> < 
> <   use m_kinds, only: r_kind,i_kind
> <   use constants, only: quarter,one,two,half,zero,deg2rad,rearth,rad2deg,pi
> <   use gridmod,  only:grid_ratio_fv3_regional, region_lat,region_lon,nlat,nlon
> <   use gridmod,  only: region_dy,region_dx,region_dyi,region_dxi,coeffy,coeffx
> <   use gridmod,  only:init_general_transform,region_dy,region_dx 
> <   use m_mpimod, only: mype
> <   use egrid2agrid_mod, only: egrid2agrid_parm
> <   implicit none
> < 
> <   real(r_kind),allocatable,dimension(:)::xbh_a,xa_a,xa_b
> <   real(r_kind),allocatable,dimension(:)::ybh_a,ya_a,ya_b,yy
> <   real(r_kind),allocatable,dimension(:,:)::xbh_b,ybh_b
> <   real(r_kind) dlat,dlon,dyy,dxx,dyyi,dxxi
> <   real(r_kind) dyyh,dxxh
> < 
> < 
> <   integer(i_kind), intent(in   ) :: nx,ny                 ! fv3 tile x- and y-dimensions
> <   real(r_kind)   , intent(inout) :: grid_lon(nx+1,ny+1)   ! fv3 cell corner longitudes
> <   real(r_kind)   , intent(inout) :: grid_lont(nx,ny)      ! fv3 cell center longitudes
> <   real(r_kind)   , intent(inout) :: grid_lat(nx+1,ny+1)   ! fv3 cell corner latitudes
> <   real(r_kind)   , intent(inout) :: grid_latt(nx,ny)      ! fv3 cell center latitudes
> <   real(r_kind),intent(inout) :: gsi_lats(:,:),gsi_lons(:,:)
> < 
> <   integer(i_kind) i,j,ir,jr,n
> <   real(r_kind),allocatable,dimension(:,:) :: xc,yc,zc,gclat,gclon,gcrlat,gcrlon,rlon_in,rlat_in
> <   real(r_kind),allocatable,dimension(:,:) :: glon_an,glat_an
> <   real(r_kind) xcent,ycent,zcent,rnorm,centlat,centlon
> <   real(r_kind) adlon,adlat,alon,clat,clon
> <   integer(i_kind) nlonh,nlath,nxh,nyh
> <   integer(i_kind) ib1,ib2,jb1,jb2,jj
> < 
> <   integer(i_kind) nord_e2a
> <   real(r_kind)gxa,gya
> < 
> <   real(r_kind) x(nx+1,ny+1),y(nx+1,ny+1),z(nx+1,ny+1), xr,yr,zr,xu,yu,zu,rlat,rlon
> <   real(r_kind) xv,yv,zv,vval
> <   real(r_kind) cx,cy
> <   real(r_kind) uval,ewval,nsval
> <   real(r_kind) diff,sq180
> <   real(r_kind) d(4),ds
> <   integer(i_kind) kk,k
> < 
> < 
> <   nord_e2a=4
> <   bilinear=.false.
> < 
> < 
> < !   create xc,yc,zc for the cell centers.
> <   allocate(xc(nx,ny))
> <   allocate(yc(nx,ny))
> <   allocate(zc(nx,ny))
> <   allocate(gclat(nx,ny))
> <   allocate(gclon(nx,ny))
> <   allocate(gcrlat(nx,ny))
> <   allocate(gcrlon(nx,ny))
> <   do j=1,ny
> <      do i=1,nx
> <         xc(i,j)=cos(grid_latt(i,j)*deg2rad)*cos(grid_lont(i,j)*deg2rad)
> <         yc(i,j)=cos(grid_latt(i,j)*deg2rad)*sin(grid_lont(i,j)*deg2rad)
> <         zc(i,j)=sin(grid_latt(i,j)*deg2rad)
> <      enddo
> <   enddo
> < 
> < !  compute center as average x,y,z coordinates of corners of domain --
> < 
> <   xcent=quarter*(xc(1,1)+xc(1,ny)+xc(nx,1)+xc(nx,ny))
> <   ycent=quarter*(yc(1,1)+yc(1,ny)+yc(nx,1)+yc(nx,ny))
> <   zcent=quarter*(zc(1,1)+zc(1,ny)+zc(nx,1)+zc(nx,ny))
> < 
> <   rnorm=one/sqrt(xcent**2+ycent**2+zcent**2)
> <   xcent=rnorm*xcent
> <   ycent=rnorm*ycent
> <   zcent=rnorm*zcent
> <   centlat=asin(zcent)*rad2deg
> <   centlon=atan2(ycent,xcent)*rad2deg
> < 
> < !!  compute new lats, lons
> <   call rotate2deg(grid_lont,grid_latt,gcrlon,gcrlat, &
> <                   centlon,centlat,nx,ny)
> < 
> < !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
> < !!  compute analysis A-grid  lats, lons
> < !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
> < 
> < !--------------------------obtain analysis grid dimensions nxa,nya
> <   nxa=1+nint((nx-one)/grid_ratio_fv3_regional)
> <   nya=1+nint((ny-one)/grid_ratio_fv3_regional)
> <   !nlat=nya
> <   !nlon=nxa
> <   nlat=ny
> <   nlon=nx
> <   if(mype==0) print *,'nlat,nlon=nya,nxa= ',nlat,nlon
> < 
> < !--------------------------obtain analysis grid spacing
> <   dlat=(maxval(gcrlat)-minval(gcrlat))/(ny-1)
> <   dlon=(maxval(gcrlon)-minval(gcrlon))/(nx-1)
> <   adlat=dlat*grid_ratio_fv3_regional
> <   adlon=dlon*grid_ratio_fv3_regional
> < 
> < !-------setup analysis A-grid; find center of the domain
> <   nlonh=nlon/2
> <   nlath=nlat/2
> < 
> <   if(nlonh*2==nlon)then
> <      clon=adlon/two
> <      cx=half
> <   else
> <      clon=adlon
> <      cx=one
> <   endif
> < 
> <   if(nlath*2==nlat)then
> <      clat=adlat/two
> <      cy=half
> <   else
> <      clat=adlat
> <      cy=one
> <   endif
> < 
> < !
> < !-----setup analysis A-grid from center of the domain
> < !
> <   if (allocated(rlat_in)) deallocate(rlat_in)
> <   if (allocated(rlon_in)) deallocate(rlon_in)
> <   allocate(rlat_in(nlat,nlon))
> <   allocate(rlon_in(nlat,nlon))
> <   do j=1,nlon
> <      alon=(j-nlonh)*adlon-clon
> <      do i=1,nlat
> <         rlon_in(i,j)=alon
> <      enddo
> <   enddo
> < 
> < 
> <   do j=1,nlon
> <      do i=1,nlat
> <         rlat_in(i,j)=(i-nlath)*adlat-clat
> <      enddo
> <   enddo
> < 
> <   if (allocated(region_dx )) deallocate(region_dx )
> <   if (allocated(region_dy )) deallocate(region_dy )
> <   if (allocated(region_dxi )) deallocate(region_dxi )
> <   if (allocated(region_dyi )) deallocate(region_dyi )
> <   if (allocated(coeffx )) deallocate(coeffx )
> <   if (allocated(coeffy )) deallocate(coeffy )
> <   allocate(region_dx(nlat,nlon),region_dy(nlat,nlon))
> <   allocate(region_dxi(nlat,nlon),region_dyi(nlat,nlon))
> <   allocate(coeffx(nlat,nlon),coeffy(nlat,nlon))
> <   dyy=rearth*adlat*deg2rad
> <   dyyi=one/dyy
> <   dyyh=half/dyy
> <   do j=1,nlon
> <      do i=1,nlat
> <         region_dy(i,j)=dyy
> <         region_dyi(i,j)=dyyi
> <         coeffy(i,j)=dyyh
> <      enddo
> <   enddo
> < 
> <   do i=1,nlat
> <      dxx=rearth*cos(rlat_in(i,1)*deg2rad)*adlon*deg2rad
> <      dxxi=one/dxx
> <      dxxh=half/dxx
> <      do j=1,nlon
> <         region_dx(i,j)=dxx
> <         region_dxi(i,j)=dxxi
> <         coeffx(i,j)=dxxh
> <      enddo
> <   enddo
> < 
> < !
> < !----------  setup  region_lat,region_lon in earth coord
> < !
> <   if (allocated(region_lat)) deallocate(region_lat)
> <   if (allocated(region_lon)) deallocate(region_lon)
> <   allocate(region_lat(nlat,nlon),region_lon(nlat,nlon))
> <   !allocate(glat_an(nlon,nlat),glon_an(nlon,nlat))
> < 
> <   call unrotate2deg(region_lon,region_lat,rlon_in,rlat_in, &
> <                     centlon,centlat,nlat,nlon)
> < 
> <   region_lat=region_lat*deg2rad
> <   region_lon=region_lon*deg2rad
> < 
> <   do j=1,nlat
> <      do i=1,nlon
> <         gsi_lats(i,j)=region_lat(j,i)
> <         gsi_lons(i,j)=region_lon(j,i)
> <         if(gsi_lons(i,j)<0.) gsi_lons(i,j)= gsi_lons(i,j) + 2.*pi
> <      enddo
> <   enddo
> <   
> <   !call init_general_transform(glat_an,glon_an)
> <  
> <   !deallocate(glat_an,glon_an)
> < 
> <   deallocate( xc,yc,zc,gclat,gclon,gcrlat,gcrlon)
> <   deallocate(rlat_in,rlon_in)
> < 
> <   deallocate(region_dxi,region_dyi)
13a13577,22846
> < 
> < end subroutine m_generate_anl_grid
> < 
> 864c625
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 867c628
> <   use m_mpimod, only: mype
> ---
> >   use mpimod, only: mype
> 1267c1028
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1326c1087
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1371c1132
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1572c1333
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1650c1411
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 1707c1468
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mod_nmmb_to_a.f90
> diff -r ./mod_strong.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/mod_strong.f90
> 69c69
> < use m_kinds,only: r_kind,i_kind
> ---
> > use kinds,only: r_kind,i_kind
> 136c136
> <     reg_tlnmc_type=0
> ---
> >     reg_tlnmc_type=1
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mod_vtrans.f90
> Only in ./: mod_vtrans.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mod_wrfmass_to_a.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_ozNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_pblhNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mp_compact_diffs_mod1.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mp_compact_diffs_support.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_pcpNode.F90
> diff -r ./mpeu_mpif.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/mpeu_mpif.F90
> 109,110d108
> <    public :: GSI_MPI_COMM_WORLD
> < 
> 164d161
> <     integer :: GSI_MPI_COMM_WORLD
> diff -r ./mpeu_util.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/mpeu_util.F90
> 126,128c126,128
> <       use m_kinds, only: IK => i_kind     ! default INTEGER kind
> <       use m_kinds, only: SP => r_single   ! default REAL kind
> <       use m_kinds, only: DP => r_double   ! DOUBLE PRECISION kind
> ---
> >       use kinds, only: IK => i_kind     ! default INTEGER kind
> >       use kinds, only: SP => r_single   ! default REAL kind
> >       use kinds, only: DP => r_double   ! DOUBLE PRECISION kind
> 157d156
> <     public :: StrUpCase
> 263,266d261
> <   ! List of character for case conversion
> <   CHARACTER(*), PARAMETER :: LOWER_CASE = 'abcdefghijklmnopqrstuvwxyz'
> <   CHARACTER(*), PARAMETER :: UPPER_CASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
> < 
> 382d376
> < #ifdef INCLUDE_MPOUT
> 420d413
> < #endif /* INCLUDE_MPOUT */
> 563,578d555
> < #ifdef _NEW_CODE_
> < !! need to send outputs to variables.
> < !! need to set return code (stat=).
> < subroutine ls_(files)       ! show information? or just inquire(exists(file))
> <   call system("ls "//files)
> < end subroutine ls_
> < subroutine rm_(files)     ! delete, open();close(status='delete')
> <   call system("rm "//files)
> < end subroutine rm_
> < subroutine mkdir_(dir,mode,parents)
> <   call system("mkdir "//files)
> < end subroutine mkdir_
> < subroutine size_(file)    ! faster access?
> <   call system("wc -c "//files)
> < end subroutine size_
> < #endif
> 987c964
> <   use mpeu_mpif, only: gsi_mpi_comm_world
> ---
> >   use mpeu_mpif, only: mpi_comm_world
> 1002c979
> <   call mpi_abort(gsi_mpi_comm_world,myer,ier)
> ---
> >   call mpi_abort(mpi_comm_world,myer,ier)
> 1121d1097
> < !       "%eX"   where X in range(1,4) for ensemble numbering
> 1126c1102
> <     subroutine strTemplate(str,tmpl,nymd,nhms,dims,xid,ens,stat)
> ---
> >     subroutine strTemplate(str,tmpl,nymd,nhms,dims,xid,stat)
> 1150,1153d1125
> <       integer,intent(in ),optional :: ens
> <                         ! substituting "%e1", "%e2", "%e3",
> <                         ! and "%e4"
> < 
> 1188d1159
> <   integer :: ie1,ie2,ie3,ie4
> 1198,1214d1168
> < ! Determine %e
> <   ie1=-1;ie2=-1;ie3=-1;ie4=-1
> <   if(present(ens)) then
> <     if(ens <= 0) then
> <         call perr(myname_,'ens <= 0',ens)
> <         if(.not.present(stat)) call die(myname_)
> <         stat=1
> <         return
> <     endif
> <   endif
> < 
> <   ie4=ens
> <   ie3=mod(ie4,1000)
> <   ie2=mod(ie3,100)
> <   ie1=mod(ie2,10)
> < 
> < !________________________________________
> 1376,1385d1329
> <       case("e1","e2","e3","e4")
> <         if(.not.present(ens)) then
> <            write(stderr,'(2a)') myname_,          &
> <               ': optional argument expected, "ens="'
> <            if(.not.present(stat)) call die(myname_)
> <            stat=1
> <            return
> <         endif
> <         istp=3
> < 
> 1400,1421d1343
> <     case("e")
> <       select case(c2)
> <       case("1")
> <         write(sbuf,'(i1)') ie1
> <         kstp=1
> <       case("2")
> <         write(sbuf,'(i2.2)') ie2
> <         kstp=2
> <       case("3")
> <         write(sbuf,'(i3.3)') ie3
> <         kstp=3
> <       case("4")
> <         write(sbuf,'(i4.4)') ie4
> <         kstp=4
> <       case default
> <         write(stderr,'(4a)') myname_,                  &
> <              ': invalid template entry, "',trim(tmpl(i:)),'"'
> <         if(.not.present(stat)) call die(myname_)
> <         stat=2
> <         return
> <       end select
> < 
> 2257c2179
> < !  use m_mpimod, only: mype
> ---
> >    use mpimod, only: mype
> 2263c2185
> < !     if ( mype == 0 ) &
> ---
> >       if ( mype == 0 ) &
> 2269,2328d2190
> < 
> < !------------------------------------------------------------------------------
> < !:sdoc+:
> < !
> < ! NAME:
> < !       StrUpCase
> < !
> < ! PURPOSE:
> < !       Function to convert an input string to upper case.
> < !
> < ! CALLING SEQUENCE:
> < !       Result = StrUpCase( String )
> < !
> < ! INPUT ARGUMENTS:
> < !       String:  Character string to be converted to upper case.
> < !                UNITS:      N/A
> < !                TYPE:       CHARACTER(*)
> < !                DIMENSION:  Scalar
> < !                ATTRIBUTES: INTENT(IN)
> < !
> < ! FUNCTION RESULT:
> < !       Result:  The input character string converted to upper case.
> < !                UNITS:      N/A
> < !                TYPE:       CHARACTER(LEN(String))
> < !                DIMENSION:  Scalar
> < !
> < ! EXAMPLE:
> < !       string = 'this is a string'
> < !       WRITE( *, '( a )' ) StrUpCase( string )
> < !   THIS IS A STRING
> < !
> < ! PROCEDURE:
> < !       Figure 3.5B, pg 80, "Upgrading to Fortran 90", by Cooper Redwine,
> < !       1995 Springer-Verlag, New York.
> < !
> < ! CREATION HISTORY:
> < !       Written by:     Paul van Delst, CIMSS/SSEC 18-Oct-1999
> < !                       paul.vandelst@ssec.wisc.edu
> < !       Stolen from CRTM: R. Todling
> < !
> < !:sdoc-:
> < !------------------------------------------------------------------------------
> < 
> <   FUNCTION StrUpCase( Input_String ) RESULT( Output_String )
> <     ! Arguments
> <     CHARACTER(*), INTENT(IN)     :: Input_String
> <     ! Function result
> <     CHARACTER(LEN(Input_String)) :: Output_String
> <     ! Local variables
> <     INTEGER :: i, n
> < 
> <     ! Copy input string
> <     Output_String = Input_String
> < 
> <     ! Convert case character by character
> <     DO i = 1, LEN(Output_String)
> <       n = INDEX(LOWER_CASE, Output_String(i:i))
> <       IF ( n /= 0 ) Output_String(i:i) = UPPER_CASE(n:n)
> <     END DO
> <   END FUNCTION StrUpCase
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mpimod.F90
> diff -r ./mpl_allreduce.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/mpl_allreduce.F90
> 70,71c70,71
> <   use m_kinds, only: r_kind,i_kind
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe
> ---
> >   use kinds, only: r_kind,i_kind
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe
> 88c88
> <                         zwork,klen,mpi_rtype, gsi_mpi_comm_world,ierror)
> ---
> >                         zwork,klen,mpi_rtype, mpi_comm_world,ierror)
> 129,130c129,130
> <   use m_kinds, only: r_kind,i_kind,r_quad,r_double
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16
> ---
> >   use kinds, only: r_kind,i_kind,r_quad,r_double
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16
> 154c154
> <                         qpval2r,klen,mpi_rtype, gsi_mpi_comm_world,ierror)
> ---
> >                         qpval2r,klen,mpi_rtype, mpi_comm_world,ierror)
> 159c159
> <                            qpval2,klen,mpi_real8 , gsi_mpi_comm_world,ierror)
> ---
> >                            qpval2,klen,mpi_real8 , mpi_comm_world,ierror)
> 162c162
> <                            qpval2,klen,mpi_real16, gsi_mpi_comm_world,ierror)
> ---
> >                            qpval2,klen,mpi_real16, mpi_comm_world,ierror)
> 207,208c207,208
> <   use m_kinds, only: r_kind,i_kind,r_quad,r_double
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16
> ---
> >   use kinds, only: r_kind,i_kind,r_quad,r_double
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16
> 230c230
> <                      pval2r,ilen*klen,mpi_rtype, gsi_mpi_comm_world,ierror)
> ---
> >                      pval2r,ilen*klen,mpi_rtype, mpi_comm_world,ierror)
> 235c235
> <                         pval2,ilen*klen,mpi_real8 , gsi_mpi_comm_world,ierror)
> ---
> >                         pval2,ilen*klen,mpi_real8 , mpi_comm_world,ierror)
> 238c238
> <                         pval2,ilen*klen,mpi_real16, gsi_mpi_comm_world,ierror)
> ---
> >                         pval2,ilen*klen,mpi_real16, mpi_comm_world,ierror)
> 303,304c303,304
> <   use m_kinds, only: i_kind,r_kind,r_quad,r_double
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16
> ---
> >   use kinds, only: i_kind,r_kind,r_quad,r_double
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16
> 323c323
> <                      zallr,idim,mpi_rtype, gsi_mpi_comm_world,ierror)
> ---
> >                      zallr,idim,mpi_rtype, mpi_comm_world,ierror)
> 328c328
> <                         zall,idim,mpi_real8 , gsi_mpi_comm_world,ierror)
> ---
> >                         zall,idim,mpi_real8 , mpi_comm_world,ierror)
> 331c331
> <                         zall,idim,mpi_real16, gsi_mpi_comm_world,ierror)
> ---
> >                         zall,idim,mpi_real16, mpi_comm_world,ierror)
> 363,364c363,364
> <   use m_kinds, only: r_kind,i_kind
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe,mype
> ---
> >   use kinds, only: r_kind,i_kind
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe,mype
> 381c381
> <                         zwork,klen,mpi_rtype, iroot,gsi_mpi_comm_world,ierror)
> ---
> >                         zwork,klen,mpi_rtype, iroot,mpi_comm_world,ierror)
> 427,428c427,428
> <   use m_kinds, only: r_kind,i_kind,r_quad,r_double
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16,mype
> ---
> >   use kinds, only: r_kind,i_kind,r_quad,r_double
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe,mpi_real8,mpi_real16,mype
> 452c452
> <                         qpval2r,klen,mpi_rtype,iroot, gsi_mpi_comm_world,ierror)
> ---
> >                         qpval2r,klen,mpi_rtype,iroot, mpi_comm_world,ierror)
> 457c457
> <                            qpval2,klen,mpi_real8 , iroot, gsi_mpi_comm_world,ierror)
> ---
> >                            qpval2,klen,mpi_real8 , iroot, mpi_comm_world,ierror)
> 460c460
> <                            qpval2,klen,mpi_real16, iroot, gsi_mpi_comm_world,ierror)
> ---
> >                            qpval2,klen,mpi_real16, iroot, mpi_comm_world,ierror)
> 510,511c510,511
> <   use m_kinds, only: r_kind,i_kind,r_quad,r_double
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,mype,npe,mpi_real8,mpi_real16
> ---
> >   use kinds, only: r_kind,i_kind,r_quad,r_double
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,mype,npe,mpi_real8,mpi_real16
> 533c533
> <                      pval2r,ilen*klen,mpi_rtype, iroot,gsi_mpi_comm_world,ierror)
> ---
> >                      pval2r,ilen*klen,mpi_rtype, iroot,mpi_comm_world,ierror)
> 538c538
> <                         pval2,ilen*klen,mpi_real8 ,iroot, gsi_mpi_comm_world,ierror)
> ---
> >                         pval2,ilen*klen,mpi_real8 ,iroot, mpi_comm_world,ierror)
> 541c541
> <                         pval2,ilen*klen,mpi_real16, iroot,gsi_mpi_comm_world,ierror)
> ---
> >                         pval2,ilen*klen,mpi_real16, iroot,mpi_comm_world,ierror)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mpl_bcast.f90
> Only in ./: m_plib8mat1.f90
> Only in ./: m_plib8mat2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_pm10Node.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_pm2_5Node.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_pmslNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_psNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_pwNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_qNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_radNode.F90
> diff -r ./m_rerank.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/m_rerank.f90
> 2c2
> < ! From Jing Guo - use m_kinds for GSI consitency (Todling)
> ---
> > ! From Jing Guo - use kinds for GSI consitency (Todling)
> 5c5,6
> <   use m_kinds, only : r_double,r_single,i_kind
> ---
> >   use kinds, only : r_double,r_single,i_kind
> >   use iso_c_binding
> 34,44c35
> <     interface
> <        function rerank_hack_2in1r4_(ln,i2) result(i1)
> <        use m_kinds, only: r_single,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: ln
> <        real(r_single),dimension(:,:),target,intent(in):: i2
> <        real(r_single),pointer,dimension(:):: i1
> <        end function rerank_hack_2in1r4_
> <     end interface
> < 
> <     i1 => rerank_hack_2in1r4_(size(i2),i2)
> ---
> >     call c_f_pointer(c_loc(i2), i1, [size(i2)])
> 52,62c43
> <     interface
> <        function rerank_hack_2in1r8_(ln,i2) result(i1)
> <        use m_kinds, only: r_double,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: ln
> <        real(r_double),dimension(:,:),target,intent(in):: i2
> <        real(r_double),pointer,dimension(:):: i1
> <        end function rerank_hack_2in1r8_
> <     end interface
> < 
> <     i1 => rerank_hack_2in1r8_(size(i2),i2)
> ---
> >     call c_f_pointer(c_loc(i2), i1, [size(i2)])
> 70,80c51
> <     interface
> <        function rerank_hack_2in1r4_(ln,i3) result(i1)
> <        use m_kinds, only: r_single,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: ln
> <        real(r_single),dimension(:,:,:),target,intent(in):: i3
> <        real(r_single),pointer,dimension(:):: i1
> <        end function rerank_hack_2in1r4_
> <     end interface
> < 
> <     i1 => rerank_hack_2in1r4_(size(i3),i3)
> ---
> >     call c_f_pointer(c_loc(i3), i1, [size(i3)])
> 88,98c59
> <     interface
> <        function rerank_hack_2in1r8_(ln,i3) result(i1)
> <        use m_kinds, only: r_double,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: ln
> <        real(r_double),dimension(:,:,:),target,intent(in):: i3
> <        real(r_double),pointer,dimension(:):: i1
> <        end function rerank_hack_2in1r8_
> <     end interface
> < 
> <     i1 => rerank_hack_2in1r8_(size(i3),i3)
> ---
> >     call c_f_pointer(c_loc(i3), i1, [size(i3)])
> 106,116c67
> <     interface
> <        function rerank_hack_2in1r4_(ln,i4) result(i1)
> <        use m_kinds, only: r_single,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: ln
> <        real(r_single),dimension(:,:,:,:),target,intent(in):: i4
> <        real(r_single),pointer,dimension(:):: i1
> <        end function rerank_hack_2in1r4_
> <     end interface
> < 
> <     i1 => rerank_hack_2in1r4_(size(i4),i4)
> ---
> >     call c_f_pointer(c_loc(i4), i1, [size(i4)])
> 124,134c75
> <     interface
> <        function rerank_hack_2in1r8_(ln,i4) result(i1)
> <        use m_kinds, only: r_double,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: ln
> <        real(r_double),dimension(:,:,:,:),target,intent(in):: i4
> <        real(r_double),pointer,dimension(:):: i1
> <        end function rerank_hack_2in1r8_
> <     end interface
> < 
> <     i1 => rerank_hack_2in1r8_(size(i4),i4)
> ---
> >     call c_f_pointer(c_loc(i4), i1, [size(i4)])
> 144,153d84
> <     interface
> <        function rerank_hack_1in2r4_(l1,l2,i1) result(i2)
> <        use m_kinds, only: r_single,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: l1,l2
> <        real(r_single),dimension(l1,l2),target,intent(in):: i1
> <        real(r_single),pointer,dimension(:,:):: i2
> <        end function rerank_hack_1in2r4_
> <     end interface
> < 
> 156c87
> <     i2 => rerank_hack_1in2r4_(shape(1),shape(2),i1)
> ---
> >     call c_f_pointer(c_loc(i1), i2, [shape(1), shape(2)])
> 166,175d96
> <     interface
> <        function rerank_hack_1in2r8_(l1,l2,i1) result(i2)
> <        use m_kinds, only: r_double,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: l1,l2
> <        real(r_double),dimension(l1,l2),target,intent(in):: i1
> <        real(r_double),pointer,dimension(:,:):: i2
> <        end function rerank_hack_1in2r8_
> <     end interface
> < 
> 178c99
> <     i2 => rerank_hack_1in2r8_(shape(1),shape(2),i1)
> ---
> >     call c_f_pointer(c_loc(i1), i2, [shape(1), shape(2)])
> 188,197d108
> <     interface
> <        function rerank_hack_1in3r4_(l1,l2,l3,i1) result(i3)
> <        use m_kinds, only: r_single,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: l1,l2,l3
> <        real(r_single),dimension(l1,l2,l3),target,intent(in):: i1
> <        real(r_single),pointer,dimension(:,:,:):: i3
> <        end function rerank_hack_1in3r4_
> <     end interface
> < 
> 200c111
> <     i3 => rerank_hack_1in3r4_(shape(1),shape(2),shape(3),i1)
> ---
> >     call c_f_pointer(c_loc(i1), i3, [shape(1), shape(2), shape(3)])
> 210,219d120
> <     interface
> <        function rerank_hack_1in3r8_(l1,l2,l3,i1) result(i3)
> <        use m_kinds, only: r_double,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: l1,l2,l3
> <        real(r_double),dimension(l1,l2,l3),target,intent(in):: i1
> <        real(r_double),pointer,dimension(:,:,:):: i3
> <        end function rerank_hack_1in3r8_
> <     end interface
> < 
> 222c123
> <     i3 => rerank_hack_1in3r8_(shape(1),shape(2),shape(3),i1)
> ---
> >     call c_f_pointer(c_loc(i1), i3, [shape(1), shape(2), shape(3)])
> 232,241d132
> <     interface
> <        function rerank_hack_1in4r4_(l1,l2,l3,l4,i1) result(i4)
> <        use m_kinds, only: r_single,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: l1,l2,l3,l4
> <        real(r_single),dimension(l1,l2,l3,l4),target,intent(in):: i1
> <        real(r_single),pointer,dimension(:,:,:,:):: i4
> <        end function rerank_hack_1in4r4_
> <     end interface
> < 
> 244c135
> <     i4 => rerank_hack_1in4r4_(shape(1),shape(2),shape(3),shape(4),i1)
> ---
> >     call c_f_pointer(c_loc(i1), i4, [shape(1), shape(2), shape(3), shape(4)])
> 254,263d144
> <     interface
> <        function rerank_hack_1in4r8_(l1,l2,l3,l4,i1) result(i4)
> <        use m_kinds, only: r_double,i_kind
> <        implicit none
> <        integer(i_kind),intent(in) :: l1,l2,l3,l4
> <        real(r_double),dimension(l1,l2,l3,l4),target,intent(in):: i1
> <        real(r_double),pointer,dimension(:,:,:,:):: i4
> <        end function rerank_hack_1in4r8_
> <     end interface
> < 
> 266c147
> <     i4 => rerank_hack_1in4r8_(shape(1),shape(2),shape(3),shape(4),i1)
> ---
> >     call c_f_pointer(c_loc(i1), i4, [shape(1), shape(2), shape(3), shape(4)])
> 282,354d162
> < 
> < ! These must live outside module to trick compiler
> < function rerank_hack_2in1r8_(ln,i2) result(i1)
> <   use m_kinds, only: r_double,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: ln
> <   real(r_double),dimension(ln),target,intent(in):: i2
> <   real(r_double),pointer,dimension(:):: i1
> <   i1 => i2
> < end function rerank_hack_2in1r8_
> < 
> < function rerank_hack_2in1r4_(ln,i2) result(i1)
> <   use m_kinds, only: r_single,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: ln
> <   real(r_single),dimension(ln),target,intent(in):: i2
> <   real(r_single),pointer,dimension(:):: i1
> <   i1 => i2
> < end function rerank_hack_2in1r4_
> < 
> < function rerank_hack_1in2r8_(l1,l2,i1) result(i2)
> <   use m_kinds, only: r_double,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: l1,l2
> <   real(r_double),dimension(l1,l2),target,intent(in):: i1
> <   real(r_double),pointer,dimension(:,:):: i2
> <   i2 => i1
> < end function rerank_hack_1in2r8_
> < 
> < function rerank_hack_1in2r4_(l1,l2,i1) result(i2)
> <   use m_kinds, only: r_single,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: l1,l2
> <   real(r_single),dimension(l1,l2),target,intent(in):: i1
> <   real(r_single),pointer,dimension(:,:):: i2
> <   i2 => i1
> < end function rerank_hack_1in2r4_
> < 
> < function rerank_hack_1in3r8_(l1,l2,l3,i1) result(i3)
> <   use m_kinds, only: r_double,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: l1,l2,l3
> <   real(r_double),dimension(l1,l2,l3),target,intent(in):: i1
> <   real(r_double),pointer,dimension(:,:,:):: i3
> <   i3 => i1
> < end function rerank_hack_1in3r8_
> < 
> < function rerank_hack_1in3r4_(l1,l2,l3,i1) result(i3)
> <   use m_kinds, only: r_single,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: l1,l2,l3
> <   real(r_single),dimension(l1,l2,l3),target,intent(in):: i1
> <   real(r_single),pointer,dimension(:,:,:):: i3
> <   i3 => i1
> < end function rerank_hack_1in3r4_
> < 
> < function rerank_hack_1in4r8_(l1,l2,l3,l4,i1) result(i4)
> <   use m_kinds, only: r_double,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: l1,l2,l3,l4
> <   real(r_double),dimension(l1,l2,l3,l4),target,intent(in):: i1
> <   real(r_double),pointer,dimension(:,:,:,:):: i4
> <   i4 => i1
> < end function rerank_hack_1in4r8_
> < 
> < function rerank_hack_1in4r4_(l1,l2,l3,l4,i1) result(i4)
> <   use m_kinds, only: r_single,i_kind
> <   implicit none
> <   integer(i_kind),intent(in) :: l1,l2,l3,l4
> <   real(r_single),dimension(l1,l2,l3,l4),target,intent(in):: i1
> <   real(r_single),pointer,dimension(:,:,:,:):: i4
> <   i4 => i1
> < end function rerank_hack_1in4r4_
> Only in ./: m_rf.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_rhs.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mrmsmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_rwNode.F90
> Only in ./: m_set_eta.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_sortind.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_spdNode.F90
> Only in ./: m_spline.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_sstNode.F90
> diff -r ./m_stats.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/m_stats.f90
> 31,32c31,32
> < use m_kinds,only : r_kind
> < use m_kinds,only : i_kind
> ---
> > use kinds,only : r_kind
> > use kinds,only : i_kind
> 34c34
> < use m_mpimod, only: ierror,mpi_rtype,mpi_sum,mpi_max,mpi_itype
> ---
> > use mpimod, only: ierror,mpi_rtype,mpi_sum,mpi_max
> 187c187
> < ! call mpi_allreduce(vdim_local,vdim,1,mpi_itype,mpi_sum,comm,ierror)
> ---
> >   call mpi_allreduce(vdim_local,vdim,1,mpi_rtype,mpi_sum,comm,ierror)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_stubTimer.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_swcpNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_tcamtNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_tcpNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_td2mNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_tick.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_tNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_uniq.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_uwnd10mNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_visNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_vwnd10mNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_wNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: m_wspd10mNode.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: myassert.H
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: mytrace.H
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: native_endianness.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: nc_diag_read_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: nc_diag_write_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ncepgfs_ghg.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ncepgfs_io.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ncepnems_io.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: netcdfgfs_io.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: netcdf_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: nlmsas_ad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: nltransf.f90
> diff -r ./normal_rh_to_q.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/normal_rh_to_q.f90
> 32c32
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 50,51c50
> <             !q(i,j,k) = dqdrh(i,j,k)*rhnorm(i,j,k)
> <             q(i,j,k) = rhnorm(i,j,k)
> ---
> >             q(i,j,k) = dqdrh(i,j,k)*rhnorm(i,j,k)
> 99c98
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: nstio_module.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: Nst_Var_ESMFMod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: obserr_allsky_mw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: observer.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: obs_ferrscale.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: obsmod.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: obs_para.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: obs_sensitivity.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: omegas_ad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: oneobmod.F90
> Only in ./: outgrads1.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ozinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: patch2grid_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pcgsoi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pcgsqrt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pcpinfo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pcp_k.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: penal.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: phil0.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: phil1.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: phil2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: phil.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pietc.f90
> diff -r ./plib8.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/plib8.f90
> 0a1,6617
> > MODULE MODULE_pmat1
> > !$$$ module documentation block
> > !              .      .    .                                       .
> > ! module:  module_pmat1
> > !
> > ! abstract:  Routines for basic algebraic operations on general matrices 
> > !             and vectors
> > !
> > ! additional notes:
> > !  These routines, perform basic algebraic operations on real vectors and
> > !  matrices. The task performed by each routine is, as far as possible,
> > !  encoded in each routine's name; three letters describe the
> > !  operation, the remainder defining the type of operand and, if needed to
> > !  resolve an ambiguity, the type of result.
> > !
> > ! program history log:
> > !   2011-07-04 todling - set to double precision to allow running GSI in
> > !                        in either single or double precision
> > !
> > ! remarks:
> > !   1. routines here must work under REAL*8 (double precision)
> > !
> > !  OPERATIONS:
> > !   DET     evaluate log-determinant
> > !   DIF     differentiate
> > !   INT     integrate
> > !   INV     invert the matrix, or linear system involving the matrix operand
> > !   L1L     Cholesky LU decomposition, where U is just L-transpose
> > !   L1U     L-U decomposition of first arg, with 1's along diagonal of L and U
> > !   LDL     Cholesky LDU decomposition, where U is just L-transpose and D diag.
> > !   LDU     LDU decomposition
> > !   NOR     evaluate norm of operand
> > !   POL     polynomial (first argument) of second argument
> > !   POW     raise operand to some integer power
> > !   SWP     swap first two operands
> > !   TRC     evaluate trace of operand
> > !   U1L     back substitution with matrix decomposed into LU form, 1's on diag.
> > !   UDL     back substitution with matrix decomposed into LDU form
> > !   WRT     write out
> > !   ZER     set operand to zero
> > !
> > !  OPERAND TYPES:
> > !   B	    banded matrix
> > !   C	    circulant matrix
> > !   D	    diagonal matrix
> > !   H	    symmetric or hermitian matrix
> > !   L	    lower triangular matrix
> > !   M	    matrix (rectangular, in general)
> > !   P	    polynomial or power-series coefficient vector
> > !   Q	    sQuare matrix with Fortran dimension same as logical dimension
> > !   R	    row of a matrix
> > !   S	    scalar
> > !   T	    transpose of the matrix
> > !   U	    upper triangular matrix
> > !   V	    vector, or column of a matrix
> > !   X	    field of parallel X-vectors (aligned like "columns" of a matrix)
> > !   Y	    field of parallel Y-vectors (aligned like "rows" of a matrix)
> > !
> > ! program history:
> > !   1994-  -    R.J.Purser - initial coding
> > !   2008-04-25  safford    - add standard documentation blocks
> > !
> > ! subroutines included:
> > !   pro333
> > !   dpro333
> > !   cro33
> > !   dcro33
> > !   norv
> > !   dnorv
> > !   norq
> > !   dnorq
> > !   swpvv
> > !   dswpvv
> > !   mulmd
> > !   dmulmd
> > !   multd
> > !   dmultd
> > !   muldm
> > !   dmuldm
> > !   muldt
> > !   dmuldt
> > !   mulpp
> > !   dmulpp
> > !   madpp
> > !   dmadpp
> > !   msbpp
> > !   dmsbpp
> > !   difp
> > !   ddifp
> > !   intp
> > !   dintp
> > !   invp
> > !   dinvp
> > !   prgv
> > !   dprgv
> > !   mulcc
> > !   dmulcc
> > !   madcc
> > !   dmadcc
> > !   msbcc
> > !   dmsbcc
> > !   zerl
> > !   dzerl
> > !   zeru
> > !   dzeru
> > !   ldum
> > !   dldum
> > !   udlmm, udlmv
> > !   dudlmm,dudlmv
> > !   linvan
> > !   dlinvan
> > !   copdm
> > !   dcopdm
> > !   condm
> > !   dcondm
> > !   copsm
> > !   dcopsm
> > !   consm
> > !   dconsm
> > !   addmd
> > !   daddmd
> > !   submd
> > !   dsubmd
> > !   addms
> > !   daddms
> > !   subms
> > !   dsubms
> > !   l1lm
> > !   dl1lm
> > !   ldlm
> > !   dldlm
> > !   invh
> > !   dinvh
> > !   invl
> > !   dinvl
> > !   linlv
> > !   dlinlv
> > !   linuv
> > !   dlinuv
> > !   powp
> > !   dpowp
> > !   polps
> > !   dpolps
> > !   polpp
> > !   dpolpp
> > !   trcm
> > !   dtrcm
> > !   invmt, linmmt, linmvt
> > !   dinvmt,dlinmmt,dlinmvt
> > !
> > ! variable definitions:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> > use constants,only: zero,one
> > IMPLICIT NONE
> > 
> > ! set default to private
> >   private
> > ! set subroutines/interfaces to public
> >   public :: pro333
> >   public :: pro333_d
> >   public :: cro33
> >   public :: cro33_d
> >   public :: norv
> >   public :: norv_d
> >   public :: norq
> >   public :: norq_d
> >   public :: swpvv
> >   public :: swpvv_d
> >   public :: mulmd
> >   public :: mulmd_d
> >   public :: multd
> >   public :: multd_d
> >   public :: muldm
> >   public :: muldm_d
> >   public :: muldt
> >   public :: muldt_d
> >   public :: mulpp
> >   public :: mulpp_d
> >   public :: madpp
> >   public :: madpp_d
> >   public :: msbpp
> >   public :: msbpp_d
> >   public :: difp
> >   public :: difp_d
> >   public :: intp
> >   public :: intp_d
> >   public :: invp
> >   public :: invp_d
> >   public :: prgv
> >   public :: prgv_d
> >   public :: mulcc
> >   public :: mulcc_d
> >   public :: madcc
> >   public :: madcc_d
> >   public :: msbcc
> >   public :: msbcc_d
> >   public :: zerl
> >   public :: zerl_d
> >   public :: zeru
> >   public :: zeru_d
> >   public :: ldum
> >   public :: ldum_d
> >   public :: udlmm
> >   public :: udlmm_d
> >   public :: linvan
> >   public :: linvan_d
> >   public :: copdm
> >   public :: copdm_d
> >   public :: condm
> >   public :: condm_d
> >   public :: copsm
> >   public :: copsm_d
> >   public :: consm
> >   public :: consm_d
> >   public :: addmd
> >   public :: addmd_d
> >   public :: submd
> >   public :: submd_d
> >   public :: addms
> >   public :: addms_d
> >   public :: subms
> >   public :: subms_d
> >   public :: l1lm
> >   public :: l1lm_d
> >   public :: ldlm
> >   public :: ldlm_d
> >   public :: invh
> >   public :: invh_d
> >   public :: invl
> >   public :: invl_d
> >   public :: linlv
> >   public :: linlv_d
> >   public :: linuv
> >   public :: linuv_d
> >   public :: powp
> >   public :: powp_d
> >   public :: polps
> >   public :: polps_d
> >   public :: polpp
> >   public :: polpp_d
> >   public :: trcm
> >   public :: trcm_d
> >   public :: inv
> >   public :: inv_d
> > 
> > INTERFACE pro333  ; MODULE PROCEDURE pro333;                 END INTERFACE
> > INTERFACE pro333_d; MODULE PROCEDURE dpro333;                END INTERFACE
> > INTERFACE cro33   ; MODULE PROCEDURE cro33;                  END INTERFACE
> > INTERFACE cro33_d;  MODULE PROCEDURE dcro33;                 END INTERFACE
> > INTERFACE norv;     MODULE PROCEDURE norv;                   END INTERFACE
> > INTERFACE norv_d;   MODULE PROCEDURE dnorv;                  END INTERFACE
> > INTERFACE norq;     MODULE PROCEDURE norq;                   END INTERFACE
> > INTERFACE norq_d;   MODULE PROCEDURE dnorq;                  END INTERFACE
> > INTERFACE swpvv;    MODULE PROCEDURE swpvv;                  END INTERFACE
> > INTERFACE swpvv_d;  MODULE PROCEDURE dswpvv;                 END INTERFACE
> > INTERFACE mulmd;    MODULE PROCEDURE mulmd;                  END INTERFACE
> > INTERFACE mulmd_d;  MODULE PROCEDURE dmulmd;                 END INTERFACE
> > INTERFACE multd;    MODULE PROCEDURE multd;                  END INTERFACE
> > INTERFACE multd_d;  MODULE PROCEDURE dmultd;                 END INTERFACE
> > INTERFACE muldm;    MODULE PROCEDURE muldm;                  END INTERFACE
> > INTERFACE muldm_d;  MODULE PROCEDURE dmuldm;                 END INTERFACE
> > INTERFACE muldt;    MODULE PROCEDURE muldt;                  END INTERFACE
> > INTERFACE muldt_d;  MODULE PROCEDURE dmuldt;                 END INTERFACE
> > INTERFACE mulpp;    MODULE PROCEDURE mulpp;                  END INTERFACE
> > INTERFACE mulpp_d;  MODULE PROCEDURE dmulpp;                 END INTERFACE
> > INTERFACE madpp;    MODULE PROCEDURE madpp;                  END INTERFACE
> > INTERFACE madpp_d;  MODULE PROCEDURE dmadpp;                 END INTERFACE
> > INTERFACE msbpp;    MODULE PROCEDURE msbpp;                  END INTERFACE
> > INTERFACE msbpp_d;  MODULE PROCEDURE dmsbpp;                 END INTERFACE
> > INTERFACE difp;     MODULE PROCEDURE difp;                   END INTERFACE
> > INTERFACE difp_d;   MODULE PROCEDURE ddifp;                  END INTERFACE
> > INTERFACE intp;     MODULE PROCEDURE intp;                   END INTERFACE
> > INTERFACE intp_d;   MODULE PROCEDURE dintp;                  END INTERFACE
> > INTERFACE invp;     MODULE PROCEDURE invp;                   END INTERFACE
> > INTERFACE invp_d;   MODULE PROCEDURE dinvp;                  END INTERFACE
> > INTERFACE prgv;     MODULE PROCEDURE prgv;                   END INTERFACE
> > INTERFACE prgv_d;   MODULE PROCEDURE dprgv;                  END INTERFACE
> > INTERFACE mulcc;    MODULE PROCEDURE mulcc;                  END INTERFACE
> > INTERFACE mulcc_d;  MODULE PROCEDURE dmulcc;                 END INTERFACE
> > INTERFACE madcc;    MODULE PROCEDURE madcc;                  END INTERFACE
> > INTERFACE madcc_d;  MODULE PROCEDURE dmadcc;                 END INTERFACE
> > INTERFACE msbcc;    MODULE PROCEDURE msbcc;                  END INTERFACE
> > INTERFACE msbcc_d;  MODULE PROCEDURE dmsbcc;                 END INTERFACE
> > INTERFACE zerl;     MODULE PROCEDURE zerl;                   END INTERFACE
> > INTERFACE zerl_d;   MODULE PROCEDURE dzerl;                  END INTERFACE
> > INTERFACE zeru;     MODULE PROCEDURE zeru;                   END INTERFACE
> > INTERFACE zeru_d;   MODULE PROCEDURE dzeru;                  END INTERFACE
> > INTERFACE ldum;     MODULE PROCEDURE ldum;                   END INTERFACE
> > INTERFACE ldum_d;   MODULE PROCEDURE dldum;                  END INTERFACE
> > INTERFACE udlmm;    MODULE PROCEDURE udlmm, udlmv;           END INTERFACE
> > INTERFACE udlmm_d;  MODULE PROCEDURE dudlmm,dudlmv;          END INTERFACE
> > INTERFACE linvan;   MODULE PROCEDURE linvan;                 END INTERFACE
> > INTERFACE linvan_d; MODULE PROCEDURE dlinvan;                END INTERFACE
> > INTERFACE copdm;    MODULE PROCEDURE copdm;                  END INTERFACE
> > INTERFACE copdm_d;  MODULE PROCEDURE dcopdm;                 END INTERFACE
> > INTERFACE condm;    MODULE PROCEDURE condm;                  END INTERFACE
> > INTERFACE condm_d;  MODULE PROCEDURE dcondm;                 END INTERFACE
> > INTERFACE copsm;    MODULE PROCEDURE copsm;                  END INTERFACE
> > INTERFACE copsm_d;  MODULE PROCEDURE dcopsm;                 END INTERFACE
> > INTERFACE consm;    MODULE PROCEDURE consm;                  END INTERFACE
> > INTERFACE consm_d;  MODULE PROCEDURE dconsm;                 END INTERFACE
> > INTERFACE addmd;    MODULE PROCEDURE addmd;                  END INTERFACE
> > INTERFACE addmd_d;  MODULE PROCEDURE daddmd;                 END INTERFACE
> > INTERFACE submd;    MODULE PROCEDURE submd;                  END INTERFACE
> > INTERFACE submd_d;  MODULE PROCEDURE dsubmd;                 END INTERFACE
> > INTERFACE addms;    MODULE PROCEDURE addms;                  END INTERFACE
> > INTERFACE addms_d;  MODULE PROCEDURE daddms;                 END INTERFACE
> > INTERFACE subms;    MODULE PROCEDURE subms;                  END INTERFACE
> > INTERFACE subms_d;  MODULE PROCEDURE dsubms;                 END INTERFACE
> > INTERFACE l1lm;     MODULE PROCEDURE l1lm;                   END INTERFACE
> > INTERFACE l1lm_d;   MODULE PROCEDURE dl1lm;                  END INTERFACE
> > INTERFACE ldlm;     MODULE PROCEDURE ldlm;                   END INTERFACE
> > INTERFACE ldlm_d;   MODULE PROCEDURE dldlm;                  END INTERFACE
> > INTERFACE invh;     MODULE PROCEDURE invh;                   END INTERFACE
> > INTERFACE invh_d;   MODULE PROCEDURE dinvh;                  END INTERFACE
> > INTERFACE invl;     MODULE PROCEDURE invl;                   END INTERFACE
> > INTERFACE invl_d;   MODULE PROCEDURE dinvl;                  END INTERFACE
> > INTERFACE linlv;    MODULE PROCEDURE linlv;                  END INTERFACE
> > INTERFACE linlv_d;  MODULE PROCEDURE dlinlv;                 END INTERFACE
> > INTERFACE linuv;    MODULE PROCEDURE linuv;                  END INTERFACE
> > INTERFACE linuv_d;  MODULE PROCEDURE dlinuv;                 END INTERFACE
> > INTERFACE powp;     MODULE PROCEDURE powp;                   END INTERFACE
> > INTERFACE powp_d;   MODULE PROCEDURE dpowp;                  END INTERFACE
> > INTERFACE polps;    MODULE PROCEDURE polps;                  END INTERFACE
> > INTERFACE polps_d;  MODULE PROCEDURE dpolps;                 END INTERFACE
> > INTERFACE polpp;    MODULE PROCEDURE polpp;                  END INTERFACE
> > INTERFACE polpp_d;  MODULE PROCEDURE dpolpp;                 END INTERFACE
> > INTERFACE trcm;     MODULE PROCEDURE trcm;                   END INTERFACE
> > INTERFACE trcm_d;   MODULE PROCEDURE dtrcm;                  END INTERFACE
> > INTERFACE inv;      MODULE PROCEDURE invmt, linmmt, linmvt;  END INTERFACE
> > INTERFACE inv_d;    MODULE PROCEDURE dinvmt,dlinmmt,dlinmvt; END INTERFACE
> > 
> > CONTAINS
> > 
> > 
> > FUNCTION pro333(d,e,f) RESULT(pro_res)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    pro333
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  triple product of 3 3-vectors
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d(3), e(3), f(3) - input vectors
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),    INTENT(IN   ) :: d(3), e(3), f(3)
> > 
> > REAL(r_kind)                :: pro_res
> > REAL(r_kind)                :: g(3)
> > 
> > CALL CRO33(E,F,G)
> > pro_res=DOT_PRODUCT(d,g)
> > END FUNCTION pro333
> > 
> > 
> > FUNCTION dpro333(d,e,f) RESULT(pro_res)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dpro333
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  triple product of 3 3-vectors
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d(3), e(3), f(3) - input vectors
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: d(3), e(3), f(3)
> > 
> > REAL(r_kind)             :: pro_res
> > REAL(r_kind)             :: g(3)
> > CALL CRO33_d(E,F,G)
> > pro_res=DOT_PRODUCT(d,g)
> > END FUNCTION dpro333
> > 
> > 
> > SUBROUTINE cro33(a,b,c) 
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    cro33
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  special case of 3-dimensions:  cross-product
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a(3), b(3)       - input vectors
> > !
> > !   output argument list:
> > !     c(3)             - resulting cross-product
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block$
> > implicit none
> > 
> > REAL(r_kind),    INTENT(IN   ) :: a(3), b(3)
> > REAL(r_kind),    INTENT(  OUT) :: c(3)
> > 
> > c(1)=a(2)*b(3)-a(3)*b(2)
> > c(2)=a(3)*b(1)-a(1)*b(3)
> > c(3)=a(1)*b(2)-a(2)*b(1)
> > END SUBROUTINE cro33
> > 
> > 
> > SUBROUTINE dcro33(a,b,c)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dcro33
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  special case of 3-dimensions:  cross-product
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a(3), b(3)       - input vectors
> > !
> > !   output argument list:
> > !     c(3)             - resulting cross-product
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(3), b(3)
> > REAL(r_kind), INTENT(  OUT) :: c(3)
> > 
> > c(1)=a(2)*b(3)-a(3)*b(2)
> > c(2)=a(3)*b(1)-a(1)*b(3)
> > c(3)=a(1)*b(2)-a(2)*b(1)
> > END SUBROUTINE dcro33
> > 
> > 
> > FUNCTION norv(d) RESULT(norv_res)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    norv
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  norm of vector
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d                - input vector
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),    INTENT(IN   ) :: d(:)
> > 
> > REAL(r_kind)                :: norv_res
> > 
> > norv_res=SQRT(DOT_PRODUCT(D,D))
> > END FUNCTION norv
> > 
> > 
> > FUNCTION dnorv(d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dnorv
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  norm of vector
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d                - input vector
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),    INTENT(IN   ) :: d(:)
> > 
> > REAL(r_kind):: dnorv
> > 
> > dnorv=SQRT(DOT_PRODUCT(d,d))
> > END FUNCTION dnorv
> > 
> > 
> > FUNCTION norq(d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    norq
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  norm of a matrix
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d                - input matrix
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(IN   ) :: d(:,:)
> > 
> > REAL(r_kind):: norq
> > INTEGER(i_kind) m2,i2
> > 
> > m2=SIZE(d,2)
> > norq=zero; DO i2=1,m2; norq=norq+dot_PRODUCT(d(:,i2),d(:,i2)); ENDDO
> > norq=SQRT(norq)
> > END FUNCTION norq
> > 
> > 
> > FUNCTION dnorq(d) ! norm of a matrix
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dnorq
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  norm of a matrix
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d                - input matrix
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(IN   ) :: d(:,:)
> > 
> > REAL(r_kind):: dnorq
> > INTEGER(i_kind) m2,i2
> > 
> > m2=SIZE(d,2)
> > dnorq=zero; DO i2=1,m2; dnorq=dnorq+dot_PRODUCT(d(:,i2),d(:,i2)); ENDDO
> > dnorq=SQRT(dnorq)
> > END FUNCTION dnorq
> > 
> > 
> > SUBROUTINE swpvv(d,e)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    swpvv 
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  swap first two operands of input vectors
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d, e       - 
> > !
> > !   output argument list:
> > !     d, e       - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: d(:), e(:)
> > 
> > REAL(r_kind) :: t(SIZE(d))
> > 
> > t = d; d = e; e = t
> > END SUBROUTINE swpvv
> > 
> > 
> > SUBROUTINE dswpvv(d,e)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dswpvv
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  swap first two operads of input vectors
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d, e       - 
> > !
> > !   output argument list:
> > !     d, e       - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: d(:), e(:)
> > 
> > REAL(r_kind) :: t(SIZE(d))
> > 
> > t = d; d = e; e = t
> > END SUBROUTINE dswpvv
> > 
> > 
> > SUBROUTINE mulmd(a,d,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulmd
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       - 
> > !     d          -
> > !   output argument list:
> > !     a, b       - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind):: m2,j
> > 
> > m2=SIZE(a,2)
> > DO j=1,m2; b(:,j)=a(:,j)*d(j); ENDDO
> > END SUBROUTINE mulmd
> > 
> > 
> > SUBROUTINE dmulmd(a,d,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmulmd
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  special case of 3-dimensions:  cross-product
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       - 
> > !     d          - 
> > !
> > !   output argument list:
> > !     a, b       - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:)
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind):: m2,j
> > 
> > m2=SIZE(a,2)
> > DO j=1,m2; b(:,j)=a(:,j)*d(j); ENDDO
> > END SUBROUTINE dmulmd
> > 
> > 
> > SUBROUTINE multd(a,d,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    multd
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       - 
> > !     d          - 
> > !
> > !   output argument list:
> > !     a, b       - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind):: m2,j
> > 
> > m2=SIZE(a,1)
> > DO j=1,m2; b(:,j) = a(j,:) * d(j); ENDDO
> > END SUBROUTINE multd
> > 
> > 
> > SUBROUTINE dmultd(a,d,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmultd
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       -
> > !     d          -
> > !
> > !   output argument list:
> > !     a, b       -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind):: m2,j
> > 
> > m2=SIZE(a,1)
> > DO j=1,m2; b(:,j) = a(j,:) * d(j); ENDDO
> > END SUBROUTINE dmultd
> > 
> > 
> > SUBROUTINE muldm(d,a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    muldm
> > !
> > !   prgrmmr:
> > !
> > ! abstract: 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       -
> > !     d          -
> > !
> > !   output argument list:
> > !     a, b       -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind)                :: m1,i
> > 
> > m1=SIZE(a,1)
> > DO i=1,m1; b(i,:) = d(i)*a(i,:); ENDDO
> > END SUBROUTINE muldm
> > 
> > 
> > SUBROUTINE dmuldm(d,a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmuldm
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       -
> > !     d          -
> > !
> > !   output argument list:
> > !     a, b       -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind)             :: m1,i
> > 
> > m1=SIZE(a,1)
> > DO i=1,m1; b(i,:) = d(i)*a(i,:); ENDDO
> > END SUBROUTINE dmuldm
> > 
> > 
> > SUBROUTINE muldt(d,a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    muldt
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       -
> > !     d          -
> > !
> > !   output argument list:
> > !     a, b       -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind)                :: m1,i
> > 
> > m1=SIZE(a,2)
> > DO i=1,m1; b(i,:) = d(i)*a(:,i); ENDDO
> > END SUBROUTINE muldt
> > 
> > 
> > SUBROUTINE dmuldt(d,a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmuldt
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       -
> > !     d          -
> > !
> > !   output argument list:
> > !     a, b       -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:),b(:,:) 
> > REAL(r_kind), INTENT(IN   ) :: d(*)
> > 
> > INTEGER(i_kind):: m1,i
> > 
> > m1=SIZE(a,2)
> > DO i=1,m1; b(i,:) = d(i)*a(:,i); ENDDO
> > END SUBROUTINE dmuldt
> > 
> > 
> > SUBROUTINE mulpp(a,b,c)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulpp
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  multiply polynomials, possibly in place
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     a, b       -
> > !     c          -
> > !
> > !   output argument list:
> > !     c          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),    INTENT(IN   ) :: a(0:), b(0:)
> > REAL(r_kind),    INTENT(INOUT) :: c(0:)
> > 
> > INTEGER(i_kind)                :: m,mcp, j
> > REAL(r_kind)                   :: s
> > 
> > m=SIZE(a)-1
> > mcp=mcmax(a,b,m)
> > c(mcp:m) = zero
> > DO j=mcp,1,-1
> >    s = SUM(a(j-1:0:-1)*b(0:j-1))
> >    c(j-1)=s
> > ENDDO
> > RETURN
> > ENTRY madpp(a,b,c)
> > m=SIZE(a)-1
> > mcp=mcmax(a,b,m)
> > DO j=mcp,1,-1
> >    s = SUM(a(j-1:0:-1)*b(0:j-1))
> >    c(j-1)=c(j-1)+s
> > ENDDO
> > RETURN
> > ENTRY msbpp(a,b,c)
> > m=SIZE(a)-1
> > mcp=mcmax(a,b,m)
> > DO j=mcp,1,-1
> >    s = SUM(a(j-1:0:-1)*b(0:j-1))
> >    c(j-1)=c(j-1)-s
> > ENDDO
> > RETURN
> > CONTAINS
> > FUNCTION mcmax(a,b,m) RESULT(mmx_res) ! This fn can be contained in mulpp().
> > !$$$  subprogram documentation block
> > !                .      .    .                                        .
> > ! subprogram:    mcmax
> > !   prgmmr:
> > !
> > ! abstract:
> > !
> > ! program history log:
> > !   2009-08-26  lueken - added subprogram doc block
> > !
> > !   input argument list:
> > !    m
> > !    a,b
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m
> > REAL(r_kind),    INTENT(IN   ) :: a(0:m), b(0:m)
> > 
> > INTEGER(i_kind)             :: mmx_res
> > INTEGER(i_kind)             :: ma, mb
> > 
> > mmx_res=0                     ! default for when ALL elements of c are zero
> > DO ma=m,0,-1                      ! seek last nonzero coefficient of polynomial a
> >    IF(a(ma) /= zero)THEN
> >       DO mb=m,0,-1                  ! seek last nonzero coefficient of polynomial b
> >          IF(b(mb) /= zero)THEN
> >             mmx_res=MIN(m,ma+mb)+1 ! hence, 1+last non-0 element of their product
> >             RETURN
> >          ENDIF
> >       ENDDO
> >       RETURN
> >    ENDIF
> > ENDDO
> > END FUNCTION mcmax
> > END SUBROUTINE mulpp
> > 
> > 
> > SUBROUTINE difp(a,b) ! Symbolically differentiate polynomial
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    difp
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Symbolically differentiate polynomial
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     a          -
> > !
> > !   output argument list:
> > !     b          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(0:)
> > REAL(r_kind), INTENT(  OUT) :: b(0:)
> > 
> > INTEGER(i_kind)           :: m, i
> > REAL(r_kind)              :: s, b0
> > 
> > m=SIZE(a)-1
> > DO i=1,m        ! possibly with coincident storage for a and b
> >    b(i-1)=i*a(i)
> > ENDDO
> > b(m)=zero
> > RETURN
> > ENTRY intp(a,b) ! Symbolically integrate polynomial
> > m=SIZE(a)-1
> > DO i=m,1,-1     ! possibly with coincident storage for a and b
> >    b(i)=a(i-1)/i
> > ENDDO
> > b(0)=zero
> > RETURN
> > ENTRY invp(a,b) ! Invert polynomial or power-series
> > m=SIZE(a)-1
> > b0=one/a(0)     ! storage of a and b must not be the same
> > b(0)=b0
> > DO i=1,m
> >    s = SUM(b(i-1:0:-1)*a(1:i))
> >    b(i)=-b0*s
> > ENDDO
> > END SUBROUTINE difp
> > 
> > 
> > SUBROUTINE dmulpp(a,b,c) !  multiply polynomials, possibly in place
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmulpp
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  multiply polynomials, possibly in place
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     a, b       -
> > !     c          -
> > !
> > !   output argument list:
> > !     c          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(0:), b(0:)
> > REAL(r_kind), INTENT(INOUT) :: c(0:)
> > 
> > INTEGER(i_kind)            :: m,mcp, j
> > REAL(r_kind)               :: s
> > 
> > m=SIZE(a)-1
> > mcp=mcmax(a,b,m)
> > c(mcp:m) = zero
> > DO j=mcp,1,-1
> >    s = SUM(a(j-1:0:-1)*b(0:j-1))
> >    c(j-1)=s
> > ENDDO
> > RETURN
> > ENTRY dmadpp(a,b,c)
> > m=SIZE(a)-1
> > mcp=mcmax(a,b,m)
> > DO j=mcp,1,-1
> >    s = SUM(a(j-1:0:-1)*b(0:j-1))
> >    c(j-1)=c(j-1)+s
> > ENDDO
> > RETURN
> > ENTRY dmsbpp(a,b,c)
> > m=SIZE(a)-1
> > mcp=mcmax(a,b,m)
> > DO j=mcp,1,-1
> >    s = SUM(a(j-1:0:-1)*b(0:j-1))
> >    c(j-1)=c(j-1)-s
> > ENDDO
> > RETURN
> > CONTAINS
> > 
> > FUNCTION mcmax(a,b,m) RESULT(mmx_res)
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    mcmax
> > !   prgmmr:
> > !
> > ! abstract:
> > !
> > ! program history log:
> > !   2009-08-26  lueken - added subprogram doc block
> > !
> > !   input argument list:
> > !    m
> > !    a,b
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m
> > REAL(r_kind)   ,  INTENT(IN   ) :: a(0:m), b(0:m)
> > 
> > INTEGER(i_kind)              :: mmx_res
> > INTEGER(i_kind)              :: ma, mb
> > 
> > mmx_res=0                     ! default for when all elements of c are zero
> > DO ma=m,0,-1                      ! seek last nonzero coefficient of polynomial a
> >    IF(a(ma) /= zero)THEN
> >       DO mb=m,0,-1                  ! seek last nonzero coefficient of polynomial b
> >          IF(b(mb) /= zero)THEN
> >             mmx_res=MIN(m,ma+mb)+1 ! hence, 1+last non-0 element of their product
> >             RETURN
> >          ENDIF
> >       ENDDO
> >       RETURN
> >    ENDIF
> > ENDDO
> > RETURN
> > END FUNCTION mcmax
> > 
> > END SUBROUTINE dmulpp
> > 
> > 
> > SUBROUTINE ddifp(a,b) ! Symbolically differentiate polynomial
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ddifp
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Symbolically differentiate polynomial
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     a          -
> > !     b          -
> > !
> > !   output argument list:
> > !     b          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(0:)
> > REAL(r_kind), INTENT(INOUT) :: b(0:)
> > 
> > INTEGER(i_kind)            :: m, i
> > REAL(r_kind)               :: s, b0
> > 
> > m=SIZE(a)-1
> > DO i=1,m         ! possibly with coincident storage for a and b
> >    b(i-1)=i*a(i)
> > ENDDO
> > b(m)=zero
> > RETURN
> > ENTRY dintp(a,b) ! Symbolically integrate polynomial
> > m=SIZE(a)-1
> > DO i=m,1,-1      ! possibly with coincident storage for a and b
> >    b(i)=a(i-1)/i
> > ENDDO
> > b(0)=zero
> > RETURN
> > ENTRY dinvp(a,b) ! Invert polynomial or power-series
> > m=SIZE(a)-1
> > b0=one/a(0)      ! storage of a and b must not be the same
> > b(0)=b0
> > DO i=1,m
> >    s = SUM(b(i-1:0:-1)*a(1:i))
> >    b(i)=-b0*s
> > ENDDO
> > END SUBROUTINE ddifp
> > 
> > 
> > SUBROUTINE prgv(d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    prgv
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d          -
> > !
> > !   output argument list:
> > !     d          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: d(:)
> > 
> > REAL(r_kind), PARAMETER        :: crit=1.E-30_r_kind
> > INTEGER(i_kind)                :: i,m
> > 
> > m=SIZE(d)
> > DO i=1,m; IF(ABS(d(i)) <= crit)d(i)=zero; ENDDO
> > END SUBROUTINE prgv
> > 
> > 
> > SUBROUTINE dprgv(d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dprgv
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d          -
> > !
> > !   output argument list:
> > !     d          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: d(:)
> > 
> > REAL(r_kind), PARAMETER     :: crit=1.E-30_r_kind
> > INTEGER(i_kind)             :: i,m
> > 
> > m=SIZE(d)
> > DO i=1,m; IF(ABS(d(i)) <= crit)d(i)=zero; ENDDO
> > END SUBROUTINE dprgv
> > 
> > 
> > SUBROUTINE mulcc(a,b,c,m)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulcc
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Multiply circulant matrices of period M
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b, c    -
> > !     m          -
> > !
> > !   output argument list:
> > !     a, b, c    -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m
> > REAL(r_kind)   , INTENT(INOUT) :: a(0:m-1), b(0:m-1), c(0:m-1)
> > 
> > INTEGER(i_kind)                :: mm, j
> > 
> > c(0:m-1) = zero
> > ENTRY madcc(a,b,c,m)
> > mm=m-1
> > DO j=0,mm
> >    c(j:m-1) = c(j:m-1) + a(0:m-j-1)*b(j)
> >    c(0:j-1) = c(0:j-1) + a(m-j:m-1)*b(j)
> > ENDDO
> > RETURN
> > ENTRY msbcc(a,b,c,m)
> > mm=m-1
> > DO j=0,mm
> >    c(j:m-1) = c(j:m-1) - a(0:m-j-1)*b(j)
> >    c(0:j-1) = c(0:j-1) - a(m-j:m-1)*b(j)
> > ENDDO
> > END SUBROUTINE mulcc
> > 
> > 
> > SUBROUTINE dmulcc(a,b,c,m)  ! Multiply circulant matrices of period M
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmulcc
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Multiply circulant matrices of period M
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b, c    -
> > !     m          -
> > !
> > !   output argument list:
> > !     a, b, c    -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m
> > REAL(r_kind)   , INTENT(INOUT) :: a(0:m-1), b(0:m-1), c(0:m-1)
> > 
> > INTEGER(i_kind)                :: mm, j
> > 
> > c(0:m-1) = zero
> > ENTRY dmadcc(a,b,c,m)
> > mm=m-1
> > DO j=0,mm
> >    c(j:m-1) = c(j:m-1) + a(0:m-j-1)*b(j)
> >    c(0:j-1) = c(0:j-1) + a(m-j:m-1)*b(j)
> > ENDDO
> > RETURN
> > ENTRY dmsbcc(a,b,c,m)
> > mm=m-1
> > DO j=0,mm
> >    c(j:m-1) = c(j:m-1) - a(0:m-j-1)*b(j)
> >    c(0:j-1) = c(0:j-1) - a(m-j:m-1)*b(j)
> > ENDDO
> > END SUBROUTINE dmulcc
> > 
> > 
> > SUBROUTINE zerl(a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    zerl
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Zero out the strictly lower triangle of elements
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -
> > !
> > !   output argument list:
> > !     a          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(INOUT) :: a(:,:)
> > 
> > INTEGER(i_kind)           :: m,j
> > 
> > m=SIZE(a,1); DO j=1,m; a(j+1:m,j) = zero; ENDDO; RETURN
> > 
> > ENTRY zeru(a)       ! Zero out the strictly upper triangle of elements
> > m=SIZE(a,1); DO j=1,m; a(1:j-1,j) = zero; ENDDO
> > END SUBROUTINE zerl
> > 
> > 
> > SUBROUTINE dzerl(a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dmuldm
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Zero out the strictly lower triangle of elements
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -
> > !
> > !   output argument list:
> > !     a          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(INOUT) :: a(:,:)
> > 
> > INTEGER(i_kind)           :: m,j
> > 
> > m=SIZE(a,1); DO j=1,m; a(j+1:m,j) = zero; ENDDO; RETURN
> > 
> > ENTRY dzeru(a)      ! Zero out the strictly upper triangle of elements
> > m=SIZE(a,1); DO j=1,m; a(1:j-1,j) = zero; ENDDO
> > END SUBROUTINE dzerl
> > 
> > 
> > SUBROUTINE ldum(a,ipiv,d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ldum
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.	1996
> > !
> > ! abstract:  perform l-d-u decomposition of square matrix a in place with
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - square matrix to be factorized
> > !
> > !   output argument list:
> > !     a          - square matrix to be factorized
> > !     ipiv       - ipiv array encoding the pivoting sequence
> > !     d          - indicator for possible sign change of determinant
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),    INTENT(INOUT) :: a(:,:) 
> > REAL(r_kind),    INTENT(OUT  ) :: d
> > INTEGER(i_kind), INTENT(OUT  ) :: ipiv(:)
> > 
> > INTEGER(i_kind)                :: m,i, j, jp, ibig, jm
> > REAL(r_kind)                   :: s(SIZE(a,1)),  aam, aa, abig,  ajj, ajji, aij
> > 
> > m=SIZE(a,1)
> > DO i=1,m
> >    aam=zero
> >    DO j=1,m
> >       aa=ABS(a(i,j))
> >       IF(aa > aam)aam=aa
> >    ENDDO
> >    IF(aam == zero)THEN
> >       PRINT '(" row ",i3," of matrix in ldum vanishes")',i
> >       STOP
> >    ENDIF
> >    s(i)=one/aam
> > ENDDO
> > d=one
> > ipiv(m)=m
> > DO j=1,m-1
> >    jp=j+1
> >    abig=s(j)*ABS(a(j,j))
> >    ibig=j
> >    DO i=jp,m
> >       aa=s(i)*ABS(a(i,j))
> >       IF(aa > abig)THEN
> >          ibig=i
> >          abig=aa
> >       ENDIF
> >    ENDDO
> > !  swap rows, recording changed sign of determinant
> >    ipiv(j)=ibig
> >    IF(ibig /= j)THEN
> >       d=-d
> >       CALL swpvv(a(j,:),a(ibig,:))
> >       s(ibig)=s(j)
> >    ENDIF
> >    ajj=a(j,j)
> >    IF(ajj == zero)THEN
> >       jm=j-1
> >       PRINT '(" failure in ldum:"/" matrix singular, rank=",i3)',jm
> >       STOP
> >    ENDIF
> >    ajji=one/ajj
> >    DO i=jp,m
> >       aij=ajji*a(i,j)
> >       a(i,j)=aij
> >       a(i,jp:m) = a(i,jp:m) - aij*a(j,jp:m)
> >    ENDDO
> > ENDDO
> > END SUBROUTINE ldum
> > 
> > 
> > SUBROUTINE DLDUM(A,IPIV,D)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dldum
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1996
> > !
> > ! abstract:  perform l-d-u decomposition of square matrix a in place with
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - square matrix to be factorized
> > !
> > !   output argument list:
> > !     a          - square matrix to be factorized
> > !     ipiv       - ipiv array encoding the pivoting sequence
> > !     d          - indicator for possible sign change of determinant
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind)   , INTENT(INOUT) :: a(:,:) 
> > REAL(r_kind)   , INTENT(  OUT) :: d
> > INTEGER(i_kind), INTENT(  OUT) :: ipiv(:)
> > 
> > INTEGER(i_kind)                :: m,i, j, jp, ibig, jm
> > REAL(r_kind)                   :: s(SIZE(a,1)),  aam, aa, abig,  ajj, ajji, aij
> > 
> > m=SIZE(a,1)
> > DO i=1,m
> >    aam=zero
> >    DO j=1,m
> >       aa=ABS(a(i,j))
> >       IF(aa > aam)aam=aa
> >    ENDDO
> >    IF(aam == zero)THEN
> >       PRINT '(" row ",i3," of matrix in dldum vanishes")',i
> >       STOP
> >    ENDIF
> >    s(i)=one/aam
> > ENDDO
> > d=one
> > ipiv(m)=m
> > DO j=1,m-1
> >    jp=j+1
> >    abig=s(j)*ABS(a(j,j))
> >    ibig=j
> >    DO i=jp,m
> >       aa=s(i)*ABS(a(i,j))
> >       IF(aa > abig)THEN
> >          ibig=i
> >          abig=aa
> >       ENDIF
> >    ENDDO
> > !  swap rows, recording changed sign of determinant
> >    ipiv(j)=ibig
> >    IF(ibig /= j)THEN
> >       d=-d
> >       CALL swpvv_d(a(j,:),a(ibig,:))
> >       s(ibig)=s(j)
> >    ENDIF
> >    ajj=a(j,j)
> >    IF(ajj == zero)THEN
> >       jm=j-1
> >       PRINT '(" Failure in dldum:"/" matrix singular, rank=",i3)',jm
> >       STOP
> >    ENDIF
> >    ajji=one/ajj
> >    DO i=jp,m
> >       aij=ajji*a(i,j)
> >       a(i,j)=aij
> >       a(i,jp:m) = a(i,jp:m) - aij*a(j,jp:m)
> >    ENDDO
> > ENDDO
> > END SUBROUTINE dldum
> > 
> > 
> > SUBROUTINE udlmm(a,b,ipiv)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlmm
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1993
> > !
> > ! abstract:  use l-u factors in A to back-substitute for mm rhs in B, 
> > !            using ipiv to define the pivoting permutation used in the l-u 
> > !            decomposition.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - L-D-U factorization of linear system matrux
> > !     b          - right-hand-sides on entry, corresponding matrix of solution
> > !	           vectors on return
> > !     ipiv       - ipiv array encoding the pivoting sequence
> > !
> > !   output argument list:
> > !     b          - right-hand-sides on entry, corresponding matrix of solution
> > !	           vectors on return
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: ipiv(:) 
> > REAL(r_kind),    INTENT(IN   ) :: a(:,:) 
> > REAL(r_kind),    INTENT(INOUT) :: b(:,:) 
> > 
> > INTEGER(i_kind)                :: m,mm,i, k, l
> > REAL(r_kind)                   :: s,aiii
> > 
> > m=SIZE(a,1); mm=SIZE(b,2)
> > DO k=1,mm !loop over columns of b
> >    DO i=1,m
> >       l=ipiv(i)
> >       s=b(l,k)
> >       b(l,k)=b(i,k)
> >       s = s - SUM(b(1:i-1,k)*a(i,1:i-1))
> >       b(i,k)=s
> >    ENDDO
> >    b(m,k)=b(m,k)/a(m,m)
> >    DO i=m-1,1,-1
> >       aiii=one/a(i,i)
> >       b(i,k) = b(i,k) - SUM(b(i+1:m,k)*a(i,i+1:m))
> >       b(i,k)=b(i,k)*aiii
> >    ENDDO
> > ENDDO
> > END SUBROUTINE udlmm
> > 
> > 
> > SUBROUTINE dudlmm(a,b,ipiv)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dudlmm
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1993
> > !
> > ! abstract:  use l-u factors in A to back-substitute for mm rhs in B,
> > !            using ipiv to define the pivoting permutation used in the l-u
> > !            decomposition.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - L-D-U factorization of linear system matrux
> > !     b          - right-hand-sides on entry, corresponding matrix of solution
> > !                  vectors on return
> > !     ipiv       - ipiv array encoding the pivoting sequence
> > !
> > !   output argument list:
> > !     b          - right-hand-sides on entry, corresponding matrix of solution
> > !                  vectors on return
> > !     
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: ipiv(:) 
> > REAL(r_kind)   , INTENT(IN   ) :: a(:,:) 
> > REAL(r_kind)   , INTENT(INOUT) :: b(:,:) 
> > 
> > INTEGER(i_kind)                :: m,mm,i, k, l
> > REAL(r_kind)                   :: s,aiii
> > 
> > m=SIZE(a,1); mm=SIZE(b,2)
> > DO k=1,mm !loop over columns of b
> >    DO i=1,m
> >       l=ipiv(i)
> >       s=b(l,k)
> >       b(l,k)=b(i,k)
> >       s = s - SUM(b(1:i-1,k)*a(i,1:i-1))
> >       b(i,k)=s
> >    ENDDO
> >    b(m,k)=b(m,k)/a(m,m)
> >    DO i=m-1,1,-1
> >       aiii=one/a(i,i)
> >       b(i,k) = b(i,k) - SUM(b(i+1:m,k)*a(i,i+1:m))
> >       b(i,k)=b(i,k)*aiii
> >    ENDDO
> > ENDDO
> > END SUBROUTINE dudlmm
> > 
> > 
> > SUBROUTINE udlmv(a,b,ipiv)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlmv
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1993
> > !
> > ! abstract:  use l-u factors in A to back-substitute for mm rhs in B, using 
> > !            ipiv to define the pivoting permutation used in the l-u 
> > !            decomposition.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - L-D-U factorization of linear system matrux
> > !     b          - right-hand-side on entry, corresponding vector solution
> > !                  on return
> > !     ipiv       - ipiv array encoding the pivoting sequence
> > !
> > !   output argument list:
> > !     b          - right-hand-side on entry, corresponding vector solution
> > !                  on return
> > !     
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: ipiv(:) 
> > REAL(r_kind),    INTENT(IN   ) :: a(:,:) 
> > REAL(r_kind),    INTENT(INOUT) :: b(:) 
> > 
> > INTEGER(i_kind)                :: m,i, l
> > REAL(r_kind)                   :: s,aiii
> > 
> > m=SIZE(a,1)
> > DO i=1,m
> >    l=ipiv(i)
> >    s=b(l)
> >    b(l)=b(i)
> >    s = s - SUM(b(1:i-1)*a(i,1:i-1))
> >    b(i)=s
> > ENDDO
> > b(m)=b(m)/a(m,m)
> > DO i=m-1,1,-1
> >    aiii=one/a(i,i)
> >    b(i) = b(i) - SUM(b(i+1:m)*a(i,i+1:m))
> >    b(i)=b(i)*aiii
> > ENDDO
> > END SUBROUTINE udlmv
> > 
> > 
> > SUBROUTINE dudlmv(a,b,ipiv)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dudlmv
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1993
> > !
> > ! abstract:  use l-u factors in A to back-substitute for mm rhs in B, using
> > !            ipiv to define the pivoting permutation used in the l-u
> > !            decomposition.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - L-D-U factorization of linear system matrux
> > !     b          - right-hand-side on entry, corresponding vector solution
> > !                  on return
> > !     ipiv       - ipiv array encoding the pivoting sequence
> > !
> > !   output argument list:
> > !     b          - right-hand-side on entry, corresponding vector solution
> > !                  on return
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: ipiv(:) 
> > REAL(r_kind)   ,  INTENT(IN   ) :: a(:,:) 
> > REAL(r_kind)   ,  INTENT(INOUT) :: b(:) 
> > 
> > INTEGER(i_kind)                 :: m,i, l
> > REAL(r_kind)                    :: s,aiii
> > 
> > m=SIZE(a,1)
> > DO i=1,m
> >    l=ipiv(i)
> >    s=b(l)
> >    b(l)=b(i)
> >    s = s - SUM(b(1:i-1)*a(i,1:i-1))
> >    b(i)=s
> > ENDDO
> > b(m)=b(m)/a(m,m)
> > DO i=m-1,1,-1
> >    aiii=one/a(i,i)
> >    b(i) = b(i) - SUM(b(i+1:m)*a(i,i+1:m))
> >    b(i)=b(i)*aiii
> > ENDDO
> > END SUBROUTINE dudlmv
> > 
> > 
> > SUBROUTINE linvan(w,ab)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    linvan
> > !
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1993
> > !
> > ! abstract:  
> > !   Take square matrix W and seek row and column scalings to produce non-
> > !   vanishing elements of rescaled W having magnitudes as close to unity
> > !   as possible. The approach is make the geometric mean of the nonvanishing
> > !   elements of each row and of each column +1 or -1. Having rescaled the
> > !   matrix and the r.h.s. vector AB, compute the product P of row-vector
> > !   norms, then compute the determinant D and solve the linear system.
> > !   Rescale the solution vector (now AB) and put the conditioning indicator
> > !   formed by the ratio D/P into the first element of W.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     W       - Generalized Vandermonde matrix in, conditioning indicator out.
> > !     AB      - R.h.s. vector in, solution vector of numerical coefficients out.
> > !
> > !   output argument list:
> > !     W       - Generalized Vandermonde matrix in, conditioning indicator out.
> > !     AB      - R.h.s. vector in, solution vector of numerical coefficients out.
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: w(:,:), ab(:)
> > 
> > INTEGER(i_kind), PARAMETER  :: nit=20
> > REAL(r_kind)                :: d1(SIZE(w,1)), d2(SIZE(w,1)), &
> >                                w2(SIZE(w,1),SIZE(w,1)),v(SIZE(w,1))
> > INTEGER(i_kind)             :: i, j, it, jt, ipiv(SIZE(w,1)), nc
> > REAL(r_kind)                :: p, e, dw, c, d, d2j
> > REAL(r_kind),ALLOCATABLE    :: wv(:,:) ! work variable for ab(nc) and v(nn)
> > 
> > nc = SIZE(w,DIM=1)
> > ALLOCATE(wv(nc,1))
> > 
> > w2=w                ! Preserve original W and AB for use
> > v = ab(1:nc)        ! in later "clean-up" operation.
> > 
> > d1 = one            ! Row scaling factors set to default
> > d2 = one            ! Column scaling factors set to default
> > 
> > C=1.E-16_r_kind	    ! Set initial criterion for "negligible" elements of W
> > 
> > ! In first attempt to estimate row and column scalings, use logarithms
> > ! to avoid the risk of under- or over-flows of the line products of W:
> > DO i=1,nc
> >    p=zero
> >    e=zero
> >    DO j=1,nc
> >       dw=ABS(w(i,j))
> >       IF(dw > c)THEN
> >          e=e+one
> >          p=p+LOG(dw)
> >       ENDIF
> >    ENDDO
> >    IF(E == zero)STOP 'W effectively singular in LINVAN'
> >    d1(i)=EXP(-p/e)
> > ENDDO
> > CALL muldm(d1,w2,w)
> > 
> > DO j=1,nc
> >    p=zero
> >    e=zero
> >    DO i=1,nc
> >       dw=ABS(w(i,j))
> >       IF(dw > c)THEN
> >          e=e+one
> >          p=p+LOG(dw)
> >       ENDIF
> >    ENDDO
> >    IF(E == zero)STOP 'W effectively singular in LINVAN'
> >    d2(j)=EXP(-p/e)
> > ENDDO
> > CALL mulmd(w,d2,w)
> > 
> > c=1.e-8_r_kind  ! reset the criterion for "negligible" elements
> > 
> > ! revert to iterations of the more efficient method without logarithms:
> > DO jt=1,2
> >    DO it=1,nit    !	perform nit relaxation iterations
> >       DO i=1,nc    !	do rows:
> >          p=one
> >          e=zero
> >          DO j=1,nc
> >             dw=ABS(w(i,j))
> >             IF(dw > c)THEN
> >                e=e+one
> >                p=p*dw
> >             ENDIF
> >          ENDDO
> >          p=one/(p**(one/e))
> >          w(i,:) = w(i,:) * p            ! rescale this row of w..
> >          d1(i)=d1(i)*p     ! ..and update d1 consistently
> >       ENDDO
> >       DO j=1,nc    !	do columns:
> >          p=one
> >          e=zero
> >          d2j=d2(j)
> >          DO i=1,nc
> >             dw=ABS(w(i,j))
> >             IF(dw > c)THEN
> >                e=e+one
> >                p=p*dw
> >             ENDIF
> >          ENDDO
> >          p=one/(p**(one/e))
> >          w(:,j) = w(:,j) * p        ! rescale this column of w..
> >          d2(j)=d2(j)*p       ! ..and update d2 consistently
> >       ENDDO
> >    ENDDO
> >    c=1.e-3_r_kind    ! final setting for criterion for "negligible" elements
> > ENDDO
> > ab(1:nc) = d1(1:nc) * ab(1:nc) ! rescale r.h.s vector by d1
> > p=one     ! p becomes product of row-lengths:
> > DO i=1,nc
> >    p=p*SQRT(dot_PRODUCT(w(i,:),w(i,:)))
> > ENDDO
> > CALL ldum(w,ipiv,d)
> > DO i=1,nc
> >    d=d*w(i,i)      ! d becomes the determinant of w
> > ENDDO
> > wv(:,1) = ab ! convert shape of array
> > CALL udlmm(w,wv(:,1:1),ipiv)
> > ab = d2 * wv(:,1) ! rescale solution vector by d2
> > !     ab(1:nc) = d2(1:nc) * ab(1:nc) ! rescale solution vector by d2
> > !  note: it is very likely that round-off errors have accumulated during
> > !  the iterative rescaling of w. we invoke original matrix elements w2 and
> > !  substitute the tentative solution vector into the original (unscaled)
> > !  equation in order to estimate the residual components of roundoff error.
> > 
> > !  begin "clean-up" process. substitute solution vector in original
> > !  equation and leave the residual difference in v
> > v=v-MATMUL(w2,ab)
> > v = d1 * v    ! rescale the residual vector by d1
> > wv(:,1) = v ! convert shape of array
> > CALL udlmm(w,wv(:,1:1),ipiv) ! solve linear system with this rhs.
> > ab=ab+wv(:,1)*d2 ! add residual solution vector, 
> >                                       ! scaled, to ab
> > 
> > DEALLOCATE(wv)
> > w(1,1)=d/p  ! this ratio is an indicator of the overall conditioning
> >             ! when d/p is very small, treat the results with suspicion!
> > 
> > END SUBROUTINE linvan
> > 
> > 
> > SUBROUTINE dlinvan(w,ab)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dlinvan
> > !                .      .    .
> > !   prgrmmr:     R.J.Purser, NCEP, Washington D.C.      1996
> > !
> > ! abstract: 
> > !   Take square matrix W and seek row and column scalings to produce non-
> > !   vanishing elements of rescaled W having magnitudes as close to unity
> > !   as possible. The approach is make the geometric mean of the nonvanishing
> > !   elements of each row and of each column +1 or -1. Having rescaled the
> > !   matrix and the r.h.s. vector AB, compute the product P of row-vector
> > !   norms, then compute the determinant D and solve the linear system.
> > !   Rescale the solution vector (now AB) and put the conditioning indicator
> > !   formed by the ratio D/P into the first element of W.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     W   -  Generalized Vandermonde matrix in, conditioning indicator out.
> > !     AB  -  R.h.s. vector in, solution vector of numerical coefficients out.
> > !
> > !   output argument list:
> > !     W   -  Generalized Vandermonde matrix in, conditioning indicator out.
> > !     AB  -  R.h.s. vector in, solution vector of numerical coefficients out.
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: w(:,:), ab(:)
> > 
> > INTEGER(i_kind), PARAMETER     :: nit=20
> > REAL(r_kind)                   :: d1(SIZE(w,1)), d2(SIZE(w,1)), &
> >                                   w2(SIZE(w,1),SIZE(w,1)),v(SIZE(w,1))
> > INTEGER(i_kind)                :: i, j, it, jt, ipiv(SIZE(w,1)), nc
> > REAL(r_kind)                   :: p, e, dw, c, d, d2j
> > REAL(r_kind),ALLOCATABLE       :: wv(:,:) ! work variable for ab(nc) and v(nn)
> > 
> > nc = SIZE(w,DIM=1)
> > ALLOCATE(wv(nc,1))
> > 
> > w2=w                ! Preserve original W and AB for use
> > v = ab(1:nc)        ! in later "clean-up" operation.
> > 
> > d1 = one            ! Row scaling factors set to default
> > d2 = one            ! Column scaling factors set to default
> > 
> > C=1.E-16_r_kind     ! Set initial criterion for "negligible" elements of W
> > 
> > ! In first attempt to estimate row and column scalings, use logarithms
> > ! to avoid the risk of under- or over-flows of the line products of W:
> > DO i=1,nc
> >    p=zero
> >    e=zero
> >    DO j=1,nc
> >       dw=ABS(w(i,j))
> >       IF(dw > c)THEN
> >          e=e+one
> >          p=p+LOG(dw)
> >       ENDIF
> >    ENDDO
> >    IF(e == zero)STOP 'w effectively singular in linvan'
> >    d1(i)=EXP(-p/e)
> > ENDDO
> > CALL muldm_d(d1,w2,w)
> > 
> > DO j=1,nc
> >    p=zero
> >    e=zero
> >    DO i=1,nc
> >       dw=ABS(w(i,j))
> >       IF(dw > c)THEN
> >          e=e+one
> >          p=p+LOG(dw)
> >       ENDIF
> >    ENDDO
> >    IF(e == zero)STOP 'w effectively singular in linvan'
> >    d2(j)=EXP(-p/e)
> > ENDDO
> > CALL mulmd_d(w,d2,w)
> >  
> > c=1.e-8_r_kind  ! reset the criterion for "negligible" elements
> > 
> > ! revert to iterations of the more efficient method without logarithms:
> > DO jt=1,2
> >    DO it=1,nit    !	perform nit relaxation iterations
> >       DO i=1,nc    !	do rows:
> >          p=one
> >          e=zero
> >          DO j=1,nc
> >             dw=ABS(w(i,j))
> >             IF(dw > c)THEN
> >                e=e+one
> >                p=p*dw
> >             ENDIF
> >          ENDDO
> >          p=one/(p**(one/e))
> >          w(i,:) = w(i,:) * p            ! rescale this row of w..
> >          d1(i)=d1(i)*p     ! ..and update d1 consistently
> >      ENDDO
> >     DO j=1,nc    ! do columns:
> >       p=one
> >       e=zero
> >       d2j=d2(j)
> >       DO i=1,nc
> >         dw=ABS(w(i,j))
> >         IF(dw > c)THEN
> >           e=e+one
> >           p=p*dw
> >         ENDIF
> >       ENDDO
> >       p=one/(p**(one/e))
> >       w(:,j) = w(:,j) * p        ! rescale this column of w..
> >       d2(j)=d2(j)*p       ! ..and update d2 consistently
> >     ENDDO
> >   ENDDO
> >   c=1.e-3_r_kind    ! final setting for criterion for "negligible" elements
> > ENDDO
> > ab(1:nc) = d1(1:nc) * ab(1:nc) ! rescale r.h.s vector by d1
> > p=one     ! p becomes product of row-lengths:
> > DO i=1,nc
> >    p=p*SQRT(dot_PRODUCT(w(i,:),w(i,:)))
> > ENDDO
> > CALL ldum_d(w,ipiv,d)
> > DO i=1,nc
> >   d=d*w(i,i)      ! d becomes the determinant of w
> > ENDDO
> > wv(:,1) = ab ! convert shape of array
> > CALL udlmm_d(w,wv(:,1:1),ipiv)
> > ab = d2 * wv(:,1) ! rescale solution vector by d2
> > !     ab(1:nc) = d2(1:nc) * ab(1:nc) ! Rescale solution vector by D2
> > !  Note: it is very likely that round-off errors have accumulated during
> > !  the iterative rescaling of W. We invoke original matrix elements W2 and
> > !  substitute the tentative solution vector into the original (unscaled)
> > !  equation in order to estimate the residual components of roundoff error.
> > 
> > !  Begin "clean-up" process. Substitute solution vector in original
> > !  equation and leave the residual difference in V
> > v=v-MATMUL(w2,ab)
> > v = d1 * v    ! Rescale the residual vector by D1
> > wv(:,1) = v ! Convert shape of array
> > CALL UDLMM_d(w,wv(:,1:1),ipiv) ! Solve linear system with THIS rhs.
> > ab=ab+wv(:,1)*d2 ! Add residual solution vector, 
> >                                       ! scaled, to AB
> > 
> > DEALLOCATE(wv)
> > w(1,1)=d/p  ! this ratio is an indicator of the overall conditioning
> >             ! When D/P is very small, treat the results with suspicion!
> > 
> > END SUBROUTINE dlinvan
> > 
> > 
> > SUBROUTINE copdm(d,a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    copdm
> > !
> > !   prgrmmr:     
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d          - 
> > !
> > !   output argument list:
> > !     a          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:),INTENT(IN)::d; REAL(r_kind),DIMENSION(:,:),INTENT(OUT)::a; INTEGER(i_kind) i
> >                   a=zero; DO i=1,SIZE(a,1); a(i,i)= d(i); ENDDO; RETURN
> > ENTRY condm(d,a); a=zero; DO i=1,SIZE(a,1); a(i,i)=-d(i); ENDDO
> > END SUBROUTINE copdm
> > 
> > 
> > SUBROUTINE dcopdm(d,a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dcopdm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d          - 
> > !
> > !   output argument list:
> > !     a          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:),INTENT(IN)::d; REAL(r_kind),DIMENSION(:,:),INTENT(OUT)::a
> > INTEGER(i_kind) i
> >                    a=zero; DO i=1,SIZE(a,1); a(i,i)= d(i); ENDDO; RETURN
> > ENTRY dcondm(d,a); a=zero; DO i=1,SIZE(a,1); a(i,i)=-d(i); ENDDO
> > END SUBROUTINE dcopdm
> > 
> > 
> > SUBROUTINE copsm(s,a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    copsm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract: 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     s          -
> > !
> > !   output argument list:
> > !     a          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(IN) :: s; REAL(r_kind),DIMENSION(:,:),INTENT(OUT):: a; INTEGER(i_kind) i
> >                   a=zero; DO i=1,SIZE(a,1); a(i,i)= s; ENDDO; RETURN
> > ENTRY consm(s,a); a=zero; DO i=1,SIZE(a,1); a(i,i)=-s; ENDDO
> > END SUBROUTINE copsm
> > 
> > 
> > SUBROUTINE dcopsm(s,a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dcopsm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     s          - 
> > !
> > !   output argument list:
> > !     a          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(IN) :: s; REAL(r_kind),DIMENSION(:,:),INTENT(OUT):: a; INTEGER(i_kind) i
> >                    a=zero; DO i=1,SIZE(a,1); a(i,i)= s; ENDDO; RETURN
> > ENTRY dconsm(s,a); a=zero; DO i=1,SIZE(a,1); a(i,i)=-s; ENDDO
> > END SUBROUTINE dcopsm
> > 
> > 
> > SUBROUTINE addmd(a,b,d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    addmd
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       -
> > !     d          - 
> > !
> > !   output argument list:
> > !     a, b       -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT):: a,b; REAL(r_kind),DIMENSION(:),INTENT(IN):: d
> > REAL(r_kind) s;  INTEGER(i_kind) i
> >                    b=a; DO i=1,SIZE(a,1); b(i,i)=b(i,i)+d(i); ENDDO; RETURN
> > ENTRY submd(a,b,d);b=a; DO i=1,SIZE(a,1); b(i,i)=b(i,i)-d(i); ENDDO; RETURN
> > ENTRY addms(a,b,s);b=a; DO I=1,SIZE(a,1); b(i,i)=b(i,i)+s;    ENDDO; RETURN
> > ENTRY SUBMS(A,B,S);b=a; DO I=1,SIZE(a,1); B(I,I)=B(I,I)-S;    ENDDO;
> > END SUBROUTINE addmd
> > 
> > 
> > SUBROUTINE daddmd(a,b,d)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    daddmd
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a, b       - 
> > !     d          -
> > !
> > !   output argument list:
> > !     a, b       - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT)::A,B;REAL(r_kind),DIMENSION(:),INTENT(IN)::D
> > REAL(r_kind) s; INTEGER(i_kind) i
> >                      b=a; DO i=1,SIZE(a,1); b(i,i)=b(i,i)+d(i); ENDDO; RETURN
> > ENTRY DSUBMD(A,B,D); b=a; DO i=1,SIZE(a,1); b(i,i)=b(i,i)-d(i); ENDDO; RETURN
> > ENTRY DADDMS(A,B,S); b=a; DO i=1,SIZE(a,1); b(i,i)=b(i,i)+s;    ENDDO; RETURN
> > ENTRY DSUBMS(A,B,S); b=a; DO i=1,SIZE(a,1); b(i,i)=b(i,i)-s;    ENDDO;
> > END SUBROUTINE daddmd
> > 
> > 
> > SUBROUTINE l1lm(a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    l1lm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Cholesky, M -> L*U, U(i,j)=L(j,i)
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - 
> > !     b          - 
> > !
> > !   output argument list:
> > !     b          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:)
> > REAL(r_kind), INTENT(INOUT) :: b(:,:)
> > INTEGER(i_kind)             :: m,j, jm, jp, i
> > REAL(r_kind)                :: s, bjji
> > m=SIZE(a,1)
> > DO j=1,m
> >   jm=j-1
> >   jp=j+1
> >   s = a(j,j) - SUM(b(j,1:jm)*b(j,1:jm))
> >   IF(S <= zero)THEN
> >     PRINT '(" L1LM detects non-positivity at diagonal index",i2)',J
> >     STOP
> >   ENDIF
> >   b(j,j)=SQRT(s)
> >   bjji=one/b(j,j)
> >   DO i=jp,m
> >     s = a(i,j) - SUM(b(i,1:jm)*b(j,1:jm))
> >     b(i,j)=s*bjji
> >   ENDDO
> >   b(1:jm,j) = zero
> > ENDDO
> > END SUBROUTINE l1lm
> > 
> > 
> > SUBROUTINE DL1LM(A,B)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dl1lm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Cholesky, M -> L*U, U(i,j)=L(j,i)
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > ! 
> > !   input argument list:
> > !     a          -
> > !     b          -
> > !
> > !   output argument list:
> > !     b          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:) 
> > REAL(r_kind), INTENT(INOUT) :: b(:,:) 
> > 
> > INTEGER(i_kind) :: m,j, jm, jp, i
> > REAL(r_kind) :: s, bjji
> > 
> > m=SIZE(a,1)
> > DO j=1,m
> >    jm=j-1
> >    jp=j+1
> >    s = a(j,j) - SUM(b(j,1:jm)*b(j,1:jm))
> >    IF(s <= zero)THEN
> >       PRINT '(" L1LM detects non-positivity at diagonal index",i2)',J
> >       STOP
> >    ENDIF
> >    b(j,j)=SQRT(s)
> >    bjji=one/b(j,j)
> >    DO i=jp,m
> >       s = a(i,j) - SUM(b(i,1:jm)*b(j,1:jm))
> >       b(i,j)=s*bjji
> >    ENDDO
> >    b(1:jm,j) = zero
> > ENDDO
> > RETURN
> > END SUBROUTINE dl1lm
> > 
> > SUBROUTINE ldlm(a,b,d) ! Modified Cholesky decompose Q --> L*D*U, U(i,j)=L(j,i)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ldlm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Modified Cholesky decompose Q --> L*D*U, U(i,j)=L(j,i)
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > ! 
> > !   input argument list:
> > !     a          -
> > !     b          -
> > !
> > !   output argument list:
> > !     b          -
> > !     d          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:)
> > REAL(r_kind), INTENT(INOUT) :: b(:,:)
> > REAL(r_kind), INTENT(  OUT) :: d(:)
> > 
> > INTEGER(i_kind) :: m,j, jm, jp, i
> > REAL(r_kind) :: bjji
> > 
> > m=SIZE(a,1)
> > DO j=1,m
> >    jm=j-1
> >    jp=j+1
> >    d(j)=a(j,j) - SUM(b(1:jm,j)*b(j,1:jm))
> >   
> >    b(j,j) = one
> >    IF(d(j) == zero)THEN
> >       PRINT '(" LDLM detects singularity at diagonal index",i2)',J
> >       STOP
> >    ENDIF
> >    bjji=one/d(j)
> >    DO i=jp,m
> >       b(j,i)= a(i,j) - dot_PRODUCT(b(1:jm,j),b(i,1:jm))
> >       b(i,j)=b(j,i)*bjji
> >    ENDDO
> > ENDDO
> > CALL zeru(b)
> > RETURN
> > END SUBROUTINE ldlm
> > 
> > 
> > SUBROUTINE dldlm(a,b,d) ! Modified Cholesky  Q --> L*D*U, U(i,j)=L(j,i)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dldlm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Modified Cholesky  Q --> L*D*U, U(i,j)=L(j,i)
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > ! 
> > !   input argument list:
> > !     a          -
> > !     b          -
> > !
> > !   output argument list:
> > !     b          -
> > !     d          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:)
> > REAL(r_kind), INTENT(INOUT) :: b(:,:)
> > REAL(r_kind), INTENT(  OUT) :: d(:)
> > 
> > INTEGER(i_kind)             :: m,j, jm, jp, i
> > REAL(r_kind)                :: bjji
> > 
> > m=SIZE(a,1)
> > DO j=1,m; jm=j-1; jp=j+1
> >    d(j)=a(j,j) - SUM(b(1:jm,j)*b(j,1:jm))
> >    b(j,j) = one
> >    IF(d(j) == zero)THEN
> >       PRINT '(" DLDLM detects singularity at diagonal index",i2)',J
> >       STOP
> >    ENDIF
> >    bjji=one/d(j)
> >    DO i=jp,m
> >       b(j,i)= a(i,j) - dot_PRODUCT(b(1:jm,j),b(i,1:jm))
> >       b(i,j)=b(j,i)*bjji
> >    ENDDO
> > ENDDO
> > CALL zeru_d(b)
> > RETURN
> > END SUBROUTINE dldlm
> > 
> > 
> > SUBROUTINE invh(a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    invh
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1993
> > !
> > ! abstract:   Inver,t in place, a symmetric matrix
> > !
> > ! limitation:  This routine incorporates no pivoting - it is intended for matrices
> > !              that are already diagonally dominant
> > !  
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > ! 
> > !   input argument list:
> > !     A          - symmetric square matrix, output as inverse of input
> > !
> > !   output argument list:
> > !     A          - symmetric square matrix, output as inverse of input
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:) 
> > 
> > INTEGER(i_kind)                  :: m,k, kp, i, ip, j
> > REAL(r_kind),DIMENSION(SIZE(a,1)):: d
> > 
> > m=SIZE(a,1)
> > !  PERFORM L.D.U DECOMPOSITION OF THE SYMMETRIC MATRIX:
> > CALL ldlm(a,a,d)
> > 
> > !  INVERT (IN PLACE) THE LOWER TRIANGULAR PART OF A, (ASSUMING UNIT
> > !  DIAGONAL ELEMENTS), AND INVERT THE DIAGONAL PART OF A (ASSUMING
> > !  ZERO OFF-DIAGONAL ELEMENTS). PUT TRANSPOSE OF LOWER, TIMES DIAGONAL,
> > !  INTO UPPER PART OF A.
> > DO k=1,m; kp=k+1
> >    a(k,k)=one/d(k)
> >    DO i=kp,m
> >       a(i,k) = a(i,k) + SUM(a(kp:i-1,k)*a(i,kp:i-1)) ! really??
> >       a(i,k) =-a(i,k)
> >    ENDDO
> > ENDDO
> > 
> > !  MULTIPLY: THE TRANSPOSE OF THE LOWER PART OF A (ASSUMING UNIT DIAGS),
> > !  TIMES THE DIAGONAL PART (ASSUMING ZERO OFF-DIAGS), TIMES THE LOWER
> > !  PART. THIS PRODUCT IS THE SYMMETRIC INVERSE OF THE ORIGINAL B.
> > DO i=2,m
> >    a(1:i-1,i) = a(i,1:i-1) * a(i,i) ! Really?
> > ENDDO
> > DO i=1,m
> >    ip=i+1
> >    DO j=1,i-1
> >       a(j,i) = a(j,i) + SUM(a(ip:ip+m-i-1,i)*a(j,ip:ip+m-i-1))
> >       a(i,j) = a(j,i)
> >    ENDDO
> >    a(i,i) = a(i,i) + SUM(a(ip:ip+m-i-1,i)*a(i,ip:ip+m-i-1))
> > ENDDO
> > END SUBROUTINE invh
> > 
> > 
> > SUBROUTINE dinvh(a)
> > !$$$  subprogram documentation block
> > !                .      .    .    
> > ! subprogram:    dinvh 
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1993 
> > !
> > ! abstract:   Inver,t in place, a symmetric matrix
> > !
> > ! limitation:  This routine incorporates no pivoting - it is intended for matrices
> > !              that are already diagonally dominant
> > !  
> > ! program history log: 
> > !   2008-04-25  safford -- add subprogram doc block
> > ! 
> > !   input argument list:
> > !     A          - symmetric square matrix, output as inverse of input
> > !
> > !   output argument list:
> > !     A          - symmetric square matrix, output as inverse of input
> > !
> > ! attributes:
> > !   language:  f90  
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:) 
> > 
> > INTEGER(i_kind)                  :: m,k, kp, i, ip, j
> > REAL(r_kind),DIMENSION(SIZE(a,1)):: d
> > 
> > m=SIZE(a,1)
> > !  PERFORM L.D.U DECOMPOSITION OF THE SYMMETRIC MATRIX:
> > CALL ldlm_d(a,a,d)
> > 
> > !  INVERT (IN PLACE) THE LOWER TRIANGULAR PART OF A, (ASSUMING UNIT
> > !  DIAGONAL ELEMENTS), AND INVERT THE DIAGONAL PART OF A (ASSUMING
> > !  ZERO OFF-DIAGONAL ELEMENTS). PUT TRANSPOSE OF LOWER, TIMES DIAGONAL,
> > !  INTO UPPER PART OF A.
> > DO k=1,m
> >    kp=k+1
> >    a(k,k)=one/d(k)
> >    DO i=kp,m
> >       a(i,k) = a(i,k) + SUM(a(kp:i-1,k)*a(i,kp:i-1)) ! really??
> >       a(i,k) =-a(i,k)
> >    ENDDO
> > ENDDO
> > 
> > !  MULTIPLY: THE TRANSPOSE OF THE LOWER PART OF A (ASSUMING UNIT DIAGS),
> > !  TIMES THE DIAGONAL PART (ASSUMING ZERO OFF-DIAGS), TIMES THE LOWER
> > !  PART. THIS PRODUCT IS THE SYMMETRIC INVERSE OF THE ORIGINAL B.
> > DO i=2,m
> >    a(1:i-1,i) = a(i,1:i-1) * a(i,i) ! really?
> > ENDDO
> > DO i=1,m
> >    ip=i+1
> >    DO j=1,i-1
> >       a(j,i) = a(j,i) + SUM(a(ip:ip+m-i-1,i)*a(j,ip:ip+m-i-1))
> >       a(i,j) = a(j,i)
> >    ENDDO
> >    a(i,i) = a(i,i) + SUM(a(ip:ip+m-i-1,i)*a(i,ip:ip+m-i-1))
> > ENDDO
> > END SUBROUTINE dinvh
> > 
> > 
> > SUBROUTINE invl(a)
> > !$$$  subprogram documentation block
> > !                .      .    .    
> > ! subprogram:    invl 
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1994
> > !
> > ! abstract:   Invert lower triangular matrix in place if A are same
> > !
> > ! program history log: 
> > !   2008-04-25  safford -- add subprogram doc block
> > ! 
> > !   input argument list:
> > !     a          - 
> > !
> > !   output argument list:
> > !     a          - 
> > !
> > ! attributes:
> > !   language:  f90  
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:) 
> > 
> > INTEGER(i_kind)             :: m,j, i
> > REAL(r_kind)                :: s
> > 
> > m=SIZE(a,1)
> > DO j=m,1,-1
> >    a(1:j-1,j) = zero
> >    a(j,j)=one/a(j,j)
> >    DO i=j+1,m
> >       s = SUM(a(j:i-1,j)*a(i,j:i-1))
> >       a(i,j)=-a(i,i)*s
> >    ENDDO
> > ENDDO
> > END SUBROUTINE invl
> > 
> > 
> > SUBROUTINE dinvl(a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dinvl
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1994
> > !
> > ! abstract:   Invert lower triangular matrix in place if A are same
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - 
> > !
> > !   output argument list:
> > !     a          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(INOUT) :: a(:,:) 
> > INTEGER(i_kind)             :: m,j, i
> > REAL(r_kind)                :: s
> > m=SIZE(a,1)
> > DO j=m,1,-1
> >    a(1:j-1,j) = zero
> >    a(j,j)=one/a(j,j)
> >    DO i=j+1,m
> >       s = SUM(a(j:i-1,j)*a(i,j:i-1))
> >       a(i,j)=-a(i,i)*s
> >    ENDDO
> > ENDDO
> > END SUBROUTINE dinvl
> > 
> > 
> > SUBROUTINE linlv(a,u)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    linvlv
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1994
> > !
> > ! abstract:   Solve linear system involving lower triangular (LINLV) or upper
> > !             triangular (LINUV) matrix. u is input as right-hand-side, output
> > !             as the solution vector.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - 
> > !     u          - 
> > !
> > !   output argument list:
> > !     u          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ):: a(:,:)
> > REAL(r_kind), INTENT(INOUT):: u(:)
> > 
> > INTEGER(i_kind)            :: m,i, j, jp
> > 
> > DO i=1,SIZE(a,1);    u(i)=(u(i) - SUM(u(1:i-1)*a(i,1:i-1)))/a(i,i); ENDDO
> > RETURN
> > ENTRY linuv(a,u); m=SIZE(a,1)
> > DO j=m,1,-1; jp=j+1; u(j)=(u(j) - SUM(a(jp:m,j)*u(jp:m)))  /a(j,j); ENDDO
> > END SUBROUTINE linlv
> > 
> > 
> > SUBROUTINE dlinlv(a,u)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dlinvlv
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1994
> > !
> > ! abstract:   Invert lower triangular matrix in place if A are same
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          - 
> > !     u          - 
> > !
> > !   output argument list:
> > !     u          - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:)
> > REAL(r_kind), INTENT(INOUT) :: u(:)
> > 
> > INTEGER(i_kind) :: m,i, j, jp
> > 
> > DO i=1,SIZE(a,1); u(i)= (u(i) - SUM(u(1:i-1)*a(i,1:i-1)))/a(i,i); ENDDO
> > RETURN
> > ENTRY dlinuv(a,u); m=SIZE(a,1)
> > DO j=m,1,-1; jp=j+1; u(j) = (u(j) - SUM(a(jp:m,j)*u(jp:m)))/a(j,j); ENDDO
> > END SUBROUTINE dlinlv
> > 
> > 
> > SUBROUTINE powp(a,b,n) 
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    powp
> > !
> > !   prgrmmr: 
> > !
> > ! abstract:  Raise power series A to the power 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -  power series
> > !     n          -  power to raise to
> > !
> > !   output argument list:
> > !     b          -  output power series
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: n       ! of N and output as B
> > REAL(r_kind),    INTENT(IN   ) :: a(0:)
> > REAL(r_kind),    INTENT(  OUT) :: b(0:)
> > 
> > REAL(r_kind),DIMENSION(0:SIZE(a)-1):: t; INTEGER(i_kind) :: k
> > 
> > b(0)=one; b(1:) = zero; DO k=1,n; CALL mulpp(a,b,t); b=t; ENDDO
> > END SUBROUTINE powp
> > 
> > 
> > SUBROUTINE DPOWP(A,B,N)        ! Raise power series A to the power
> > !$$$  subprogram documentation block
> > !                .      .    . 
> > ! subprogram:    dpowp
> > !
> > !   prgrmmr:  
> > !
> > ! abstract:  Raise power series A to the power
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -  power series
> > !     n          -  power to raise to
> > !
> > !   output argument list:
> > !     b          -  output power series
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: n      ! of N and output as B
> > REAL(r_kind)   , INTENT(IN   ) :: a(0:)
> > REAL(r_kind)   , INTENT(  OUT) :: b(0:)
> > 
> > REAL(r_kind),DIMENSION(0:SIZE(a)-1):: t; INTEGER(i_kind) :: k
> > 
> > B(0)=one; b(1:) = zero; DO k=1,n; CALL mulpp_d(a,b,t); b=t; ENDDO
> > END SUBROUTINE dpowp
> > 
> > 
> > SUBROUTINE polps(a,s1,s2) ! Apply series A to scalar S1 to obtain S2
> > !$$$  subprogram documentation block
> > !                .      .    . 
> > ! subprogram:    polps
> > !
> > !   prgrmmr:  
> > !
> > ! abstract:  Apply series A to scalar S1 to obtain S2
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -  
> > !     s1         - 
> > !
> > !   output argument list:
> > !     s2         -  
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(IN   ) :: a(0:)
> > REAL(r_kind),INTENT(IN   ) :: s1
> > REAL(r_kind),INTENT(  OUT) :: s2
> > 
> > INTEGER(i_kind) m,k
> > 
> > m=SIZE(a)-1; s2=a(m); DO k=m-1,0,-1; s2=s2*s1+a(k); ENDDO
> > END SUBROUTINE polps
> > 
> > 
> > SUBROUTINE dpolps(a,s1,s2) ! Apply series A to scalar S1 to obtain S2
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dpolps
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Apply series A to scalar S1 to obtain S2
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -  
> > !     s1         -  
> > !
> > !   output argument list:
> > !     s2         -  
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(IN   ) :: a(0:)
> > REAL(r_kind),INTENT(IN   ) :: s1
> > REAL(r_kind),INTENT(  OUT) :: s2
> > 
> > INTEGER(i_kind) m,k
> > 
> > m=SIZE(a)-1; s2=a(m); DO k=m-1,0,-1; s2=s2*s1+a(k); ENDDO
> > END SUBROUTINE dpolps
> > 
> > 
> > SUBROUTINE polpp(a,b,c)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    polpp
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Apply power series A to power series B and put
> > !            the result out as power-series C.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a,b,c      -  
> > !
> > !   output argument list:
> > !     a,b,c      -  
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(INOUT) :: a(0:),b(0:),c(0:)
> > 
> > REAL(r_kind),DIMENSION(0:SIZE(a)-1):: t
> > INTEGER(i_kind) m,k
> > 
> > m=SIZE(a)-1; c(0)=a(m); c(1:m) = zero
> > DO k=m-1,0,-1; CALL mulpp(b,c,t); c=t; c(0)=c(0)+a(k); ENDDO
> > END SUBROUTINE polpp
> > 
> > 
> > SUBROUTINE dpolpp(a,b,c)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dpolpp
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Apply power series A to power series B and put
> > !            the result out as power-series C.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a,b,c      -
> > !
> > !   output argument list:
> > !     a,b,c      -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),INTENT(INOUT) :: a(0:),b(0:),c(0:)
> > 
> > REAL(r_kind),DIMENSION(0:SIZE(a)-1):: t
> > INTEGER(i_kind) m,k
> > 
> > m=SIZE(a)-1
> > c(0)=a(m); c(1:m) = zero
> > DO k=m-1,0,-1; CALL mulpp_d(b,c,t); c=t; c(0)=c(0)+a(k); ENDDO
> > END SUBROUTINE dpolpp
> > 
> > 
> > FUNCTION trcm(a) RESULT(trc_res)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    trcm
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  Trace of square matrix A
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !     a          -
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:)
> > 
> > REAL(r_kind)             :: trc_res
> > INTEGER(i_kind)          :: i
> > 
> > trc_res=zero; DO i=1,SIZE(a,1); trc_res=trc_res+a(i,i); ENDDO
> > END FUNCTION trcm
> > 
> > FUNCTION dtrcm(a) RESULT(trc_res)	    ! Trace of square matrix A
> > !$$$  subprogram documentation block
> > !                .      .    .                                       .
> > ! subprogram:    dtrcm
> > !   prgmmr:
> > !
> > ! abstract:
> > !
> > ! program history log:
> > !   2009-08-26  lueken - added subprogram doc block
> > !
> > !   input argument list:
> > !    a
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language: f90
> > !   machine:
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind), INTENT(IN   ) :: a(:,:)
> > 
> > REAL(r_kind)             :: trc_res
> > INTEGER(i_kind)          :: i
> > 
> > trc_res=zero; DO i=1,SIZE(a,1); trc_res=trc_res+a(i,i); ENDDO
> > END FUNCTION dtrcm
> > 
> > 
> > SUBROUTINE invmt(a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    invmt
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -
> > !
> > !   output argument list:
> > !     a          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT) :: a
> > 
> > INTEGER(i_kind) m,i,j,jp,l
> > REAL(r_kind) d
> > INTEGER(i_kind),DIMENSION(SIZE(a,1)):: ipiv
> > 
> > m=SIZE(a,1)
> > IF(m /= SIZE(a,2))STOP 'matrix passed to invmt is not square'
> > ! Perform a pivoted L-D-U decomposition on matrix a:
> > CALL ldum(a,ipiv,d)
> > 
> > ! Invert upper triangular portion U in place:
> > DO i=1,m; a(i,i)=one/a(i,i); ENDDO
> > DO i=1,m-1
> >    DO j=i+1,m; a(i,j)=-a(j,j)*DOT_PRODUCT(a(i:j-1,j),a(i,i:j-1)); ENDDO
> > ENDDO
> > 
> > ! Invert lower triangular portion L in place:
> > DO j=1,m-1; jp=j+1
> >    DO i=jp,m; a(i,j)=-a(i,j)-DOT_PRODUCT(a(jp:i-1,j),a(i,jp:i-1)); ENDDO
> > ENDDO
> > 
> > !  Form the product of U**-1 and L**-1 in place
> > DO j=1,m-1; jp=j+1
> >    DO i=1,j; a(i,j)=a(i,j)+DOT_PRODUCT(a(jp:m,j),a(i,jp:m)); ENDDO
> >    DO i=jp,m; a(i,j)=DOT_PRODUCT(a(i:m,j),a(i,i:m));         ENDDO
> > ENDDO
> > 
> > !  Permute columns according to ipiv
> > DO j=m-1,1,-1; l=ipiv(j); CALL swpvv(a(:,j),a(:,l)); ENDDO
> > END SUBROUTINE invmt
> > 
> > 
> > SUBROUTINE dinvmt(a)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dinvmt
> > !
> > !   prgrmmr:
> > !
> > ! abstract: 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a          -
> > !
> > !   output argument list:
> > !     a          -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT) :: a
> > 
> > INTEGER(i_kind)                          :: m,i,j,jp,l
> > REAL(r_kind)                             :: d
> > INTEGER(i_kind),DIMENSION(SIZE(a,1))     :: ipiv
> > 
> > m=SIZE(a,1)
> > IF(m /= SIZE(a,2))STOP 'matrix passed to dinvmt is not square'
> > ! Perform a pivoted L-D-U decomposition on matrix a:
> > CALL ldum_d(a,ipiv,d)
> > 
> > ! Invert upper triangular portion U in place:
> > DO i=1,m; a(i,i)=one/a(i,i); ENDDO
> > DO i=1,m-1
> >    DO j=i+1,m; a(i,j)=-a(j,j)*DOT_PRODUCT(a(i:j-1,j),a(i,i:j-1)); ENDDO
> > ENDDO
> > 
> > ! Invert lower triangular portion L in place:
> > DO j=1,m-1; jp=j+1
> >    DO i=jp,m; a(i,j)=-a(i,j)-DOT_PRODUCT(a(jp:i-1,j),a(i,jp:i-1)); ENDDO
> > ENDDO
> > 
> > !  Form the product of U**-1 and L**-1 in place
> > DO j=1,m-1; jp=j+1
> >    DO i=1,j; a(i,j)=a(i,j)+DOT_PRODUCT(a(jp:m,j),a(i,jp:m)); ENDDO
> >    DO i=jp,m; a(i,j)=DOT_PRODUCT(a(i:m,j),a(i,i:m));         ENDDO
> > ENDDO
> > 
> > !  Permute columns according to ipiv
> > DO j=m-1,1,-1; l=ipiv(j); CALL swpvv_d(a(:,j),a(:,l)); ENDDO
> > END SUBROUTINE dinvmt
> > 
> > 
> > SUBROUTINE linmmt(a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    linmmt
> > !
> > !   prgrmmr:
> > !
> > ! abstract: 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a,b        -
> > !
> > !   output argument list:
> > !     a,b        -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT) :: a,b
> > 
> > INTEGER(i_kind),DIMENSION(SIZE(a,1))     :: ipiv
> > INTEGER(i_kind)                          :: m
> > REAL(r_kind)                             :: d
> > 
> > m=SIZE(a,1)
> > IF(m /= SIZE(a,2))STOP 'matrix passed to linmmt is not square'
> > IF(m /= SIZE(b,1))STOP 'matrix and vectors in linmmt have unmatched sizes'
> > CALL ldum(a,ipiv,d); CALL udlmm(a,b,ipiv)
> > END SUBROUTINE linmmt
> > 
> > 
> > SUBROUTINE dlinmmt(a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dlinmmt
> > !
> > !   prgrmmr:
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a,b        -
> > !
> > !   output argument list:
> > !     a,b        -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT) :: a,b
> > 
> > INTEGER(i_kind),DIMENSION(SIZE(a,1))     :: ipiv
> > INTEGER(i_kind)                          :: m 
> > REAL(r_kind)                             :: d
> > 
> > m=SIZE(a,1)
> > IF(m /= SIZE(a,2))STOP 'matrix passed to linmmt_d is not square'
> > IF(m /= SIZE(b,1))STOP 'matrix and vectors in linmmt_d have unmatched sizes'
> > CALL ldum_d(a,ipiv,d); CALL udlmm_d(a,b,ipiv)
> > END SUBROUTINE dlinmmt
> > 
> > 
> > SUBROUTINE linmvt(a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    linmvt
> > !
> > !   prgrmmr:
> > !
> > ! abstract: 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a,b        -
> > !
> > !   output argument list:
> > !     a,b        -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT) :: a
> > REAL(r_kind),DIMENSION(:),  INTENT(INOUT) :: b
> > 
> > INTEGER(i_kind),DIMENSION(SIZE(a,1))     :: ipiv
> > INTEGER(i_kind)                          :: m
> > REAL(r_kind)                             :: d
> > 
> > m=SIZE(a,1)
> > IF(m /= SIZE(a,2))STOP 'matrix passed to linmvt is not square'
> > IF(m /= SIZE(b))STOP 'matrix and vectors in linmvt have unmatched sizes'
> > CALL ldum(a,ipiv,d); CALL udlmm(a,b,ipiv)
> > END SUBROUTINE linmvt
> > 
> > 
> > SUBROUTINE dlinmvt(a,b)
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dlinmvt
> > !
> > !   prgrmmr:
> > !
> > ! abstract: 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a,b        -
> > !
> > !   output argument list:
> > !     a,b        -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > REAL(r_kind),DIMENSION(:,:),INTENT(INOUT) :: a
> > REAL(r_kind),DIMENSION(:),  INTENT(INOUT) :: b
> > 
> > INTEGER(i_kind),DIMENSION(SIZE(a,1))     :: ipiv
> > INTEGER(i_kind) m; REAL(r_kind) d
> > 
> > m=SIZE(a,1)
> > IF(m /= SIZE(a,2))STOP 'matrix passed to linmvt_d is not square'
> > IF(m /= SIZE(b))STOP 'matrix and vectors in linmvt_d have unmatched sizes'
> > CALL ldum_d(a,ipiv,d); CALL udlmm_d(a,b,ipiv)
> > END SUBROUTINE dlinmvt
> > 
> > end module module_pmat1
> > 
> > 
> > 
> > MODULE MODULE_pmat2
> > !$$$   module documentation block
> > !                .      .    .                                     .
> > ! module:  module_pmat2
> > !  prgmmr: purser
> > !
> > ! abstract:
> > !
> > ! program history log:
> > !   1994-  -    purser
> > !   2008-04-25  safford - add documentation block
> > !
> > ! subroutines included:
> > !   avco
> > !   davco
> > !   dfco
> > !   ddfco
> > !   dfco2
> > !   ddfco2
> > !   clib
> > !   dclib
> > !   cad1b
> > !   csb1b
> > !   cad2b
> > !   csb2b
> > !   copbt
> > !   conbt
> > !   copmb
> > !   conmb
> > !   copbm
> > !   conbm
> > !   mulbb
> > !   madbb
> > !   msbbb
> > !   ldub
> > !   dldub
> > !   l1ubb
> > !   dl1ubb
> > !   l1ueb
> > !   dl1ueb
> > !   l1lb
> > !   ldlb
> > !   dldlb
> > !   udub
> > !   dudub
> > !   mulbv
> > !   madbv
> > !   msbbv
> > !   mulbx
> > !   madbx
> > !   msbbx
> > !   mulby
> > !   madby
> > !   msbby
> > !   mulvb
> > !   madvb
> > !   msbvb
> > !   mulxb
> > !   madxb
> > !   msbxb
> > !   mulyb
> > !   madyb
> > !   msbyb
> > !   mulbd
> > !   madbd
> > !   msbbd
> > !   muldb
> > !   maddb
> > !   msbdb
> > !   udlbv
> > !   udlbx
> > !   udlby
> > !   udlvb
> > !   udlxb
> > !   udlyb
> > !   u1lbv
> > !   u1lbx
> > !   u1lby
> > !   u1lvb
> > !   u1lxb
> > !   u1lyb
> > !   linbv
> > !   wrtb
> > !
> > ! variable definitions:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > USE MODULE_pmat1
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> > use constants, only: zero,one,two
> > IMPLICIT NONE
> > 
> > ! set default to private
> >   private
> > ! set subroutines/interfaces to public
> >   public :: avco
> >   public :: avco_d
> >   public :: dfco
> >   public :: dfco_d
> >   public :: dfco2
> >   public :: dfco2_d
> >   public :: clib
> >   public :: clib_d
> >   public :: cad1b
> >   public :: csb1b
> >   public :: cad2b
> >   public :: csb2b
> >   public :: copbt
> >   public :: conbt
> >   public :: copmb
> >   public :: conmb
> >   public :: mulbb
> >   public :: madbb
> >   public :: msbbb
> >   public :: ldub
> >   public :: ldub_d
> >   public :: l1ubb
> >   public :: l1ubb_d
> >   public :: l1ueb
> >   public :: l1ueb_d
> >   public :: l1lb
> >   public :: ldlb
> >   public :: ldlb_d
> >   public :: udub
> >   public :: udub_d
> >   public :: mulbv
> >   public :: madbv
> >   public :: msbbv
> >   public :: mulbx
> >   public :: madbx
> >   public :: msbbx
> >   public :: mulby
> >   public :: madby
> >   public :: msbby
> >   public :: mulvb
> >   public :: madvb
> >   public :: msbvb
> >   public :: mulxb
> >   public :: madxb
> >   public :: msbxb
> >   public :: mulyb
> >   public :: madyb
> >   public :: msbyb
> >   public :: mulbd
> >   public :: madbd
> >   public :: msbbd
> >   public :: muldb
> >   public :: maddb
> >   public :: msbdb
> >   public :: udlbv
> >   public :: udlbx
> >   public :: udlby
> >   public :: udlvb
> >   public :: udlxb
> >   public :: udlyb
> >   public :: u1lbv
> >   public :: u1lbx
> >   public :: u1lby
> >   public :: u1lvb
> >   public :: u1lxb
> >   public :: u1lyb
> >   public :: linbv
> >   public :: wrtb
> > 
> > INTERFACE avco;   MODULE PROCEDURE avco;           END INTERFACE
> > INTERFACE avco_d; MODULE PROCEDURE davco;          END INTERFACE
> > INTERFACE dfco;   MODULE PROCEDURE dfco;           END INTERFACE
> > INTERFACE dfco_d; MODULE PROCEDURE ddfco;          END INTERFACE
> > INTERFACE dfco2;  MODULE PROCEDURE dfco2;          END INTERFACE
> > INTERFACE dfco2_d;MODULE PROCEDURE ddfco2;         END INTERFACE
> > INTERFACE clib;   MODULE PROCEDURE clib;           END INTERFACE
> > INTERFACE clib_d; MODULE PROCEDURE dclib;          END INTERFACE
> > INTERFACE cad1b;  MODULE PROCEDURE cad1b;          END INTERFACE
> > INTERFACE csb1b;  MODULE PROCEDURE csb1b;          END INTERFACE
> > INTERFACE cad2b;  MODULE PROCEDURE cad2b;          END INTERFACE
> > INTERFACE csb2b;  MODULE PROCEDURE csb2b;          END INTERFACE
> > INTERFACE copbt;  MODULE PROCEDURE copbt;          END INTERFACE
> > INTERFACE conbt;  MODULE PROCEDURE conbt;          END INTERFACE
> > INTERFACE copmb;  MODULE PROCEDURE copmb;          END INTERFACE
> > INTERFACE conmb;  MODULE PROCEDURE conmb;          END INTERFACE
> > INTERFACE copbm;  MODULE PROCEDURE copbm;          END INTERFACE
> > INTERFACE conbm;  MODULE PROCEDURE conbm;          END INTERFACE
> > INTERFACE mulbb;  MODULE PROCEDURE mulbb;          END INTERFACE
> > INTERFACE madbb;  MODULE PROCEDURE madbb;          END INTERFACE
> > INTERFACE msbbb;  MODULE PROCEDURE msbbb;          END INTERFACE
> > INTERFACE ldub;   MODULE PROCEDURE ldub;           END INTERFACE
> > INTERFACE ldub_d; MODULE PROCEDURE dldub;          END INTERFACE
> > INTERFACE l1ubb;  MODULE PROCEDURE l1ubb;          END INTERFACE
> > INTERFACE l1ubb_d;MODULE PROCEDURE dl1ubb;         END INTERFACE
> > INTERFACE l1ueb;  MODULE PROCEDURE l1ueb;          END INTERFACE
> > INTERFACE l1ueb_d;MODULE PROCEDURE dl1ueb;         END INTERFACE
> > INTERFACE l1lb;   MODULE PROCEDURE l1lb;           END INTERFACE
> > INTERFACE ldlb;   MODULE PROCEDURE ldlb;           END INTERFACE
> > INTERFACE ldlb_d; MODULE PROCEDURE dldlb;          END INTERFACE
> > INTERFACE udub;   MODULE PROCEDURE udub;           END INTERFACE
> > INTERFACE udub_d; MODULE PROCEDURE dudub;          END INTERFACE
> > INTERFACE mulbv;  MODULE PROCEDURE mulbv;          END INTERFACE
> > INTERFACE madbv;  MODULE PROCEDURE madbv;          END INTERFACE
> > INTERFACE msbbv;  MODULE PROCEDURE msbbv;          END INTERFACE
> > INTERFACE mulbx;  MODULE PROCEDURE mulbx;          END INTERFACE
> > INTERFACE madbx;  MODULE PROCEDURE madbx;          END INTERFACE
> > INTERFACE msbbx;  MODULE PROCEDURE msbbx;          END INTERFACE
> > INTERFACE mulby;  MODULE PROCEDURE mulby;          END INTERFACE
> > INTERFACE madby;  MODULE PROCEDURE madby;          END INTERFACE
> > INTERFACE msbby;  MODULE PROCEDURE msbby;          END INTERFACE
> > INTERFACE mulvb;  MODULE PROCEDURE mulvb;          END INTERFACE
> > INTERFACE madvb;  MODULE PROCEDURE madvb;          END INTERFACE
> > INTERFACE msbvb;  MODULE PROCEDURE msbvb;          END INTERFACE
> > INTERFACE mulxb;  MODULE PROCEDURE mulxb;          END INTERFACE
> > INTERFACE madxb;  MODULE PROCEDURE madxb;          END INTERFACE
> > INTERFACE msbxb;  MODULE PROCEDURE msbxb;          END INTERFACE
> > INTERFACE mulyb;  MODULE PROCEDURE mulyb;          END INTERFACE
> > INTERFACE madyb;  MODULE PROCEDURE madyb;          END INTERFACE
> > INTERFACE msbyb;  MODULE PROCEDURE msbyb;          END INTERFACE
> > INTERFACE mulbd;  MODULE PROCEDURE mulbd;          END INTERFACE
> > INTERFACE madbd;  MODULE PROCEDURE madbd;          END INTERFACE
> > INTERFACE msbbd;  MODULE PROCEDURE msbbd;          END INTERFACE
> > INTERFACE muldb;  MODULE PROCEDURE muldb;          END INTERFACE
> > INTERFACE maddb;  MODULE PROCEDURE maddb;          END INTERFACE
> > INTERFACE msbdb;  MODULE PROCEDURE msbdb;          END INTERFACE
> > INTERFACE udlbv;  MODULE PROCEDURE udlbv;          END INTERFACE
> > INTERFACE udlbx;  MODULE PROCEDURE udlbx;          END INTERFACE
> > INTERFACE udlby;  MODULE PROCEDURE udlby;          END INTERFACE
> > INTERFACE udlvb;  MODULE PROCEDURE udlvb;          END INTERFACE
> > INTERFACE udlxb;  MODULE PROCEDURE udlxb;          END INTERFACE
> > INTERFACE udlyb;  MODULE PROCEDURE udlyb;          END INTERFACE
> > INTERFACE u1lbv;  MODULE PROCEDURE u1lbv;          END INTERFACE
> > INTERFACE u1lbx;  MODULE PROCEDURE u1lbx;          END INTERFACE
> > INTERFACE u1lby;  MODULE PROCEDURE u1lby;          END INTERFACE
> > INTERFACE u1lvb;  MODULE PROCEDURE u1lvb;          END INTERFACE
> > INTERFACE u1lxb;  MODULE PROCEDURE u1lxb;          END INTERFACE
> > INTERFACE u1lyb;  MODULE PROCEDURE u1lyb;          END INTERFACE
> > INTERFACE linbv;  MODULE PROCEDURE linbv;          END INTERFACE
> > INTERFACE wrtb;   MODULE PROCEDURE wrtb;           END INTERFACE
> > 
> > 
> > CONTAINS
> > 
> > 
> > !=============================================================================
> > SUBROUTINE davco(na,nb,za,zb,z0,a,b) 
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    davco
> > !
> > !   prgrmmr:    purser					      1999
> > !
> > ! abstract:  Compute one row of the coefficients for the compact mid-interval
> > !            interpolation scheme characterized by matrix equation of the form,
> > !			 A.t = B.s			       (*)
> > !            Where s is the vector of "source" values, t the staggered "target" 
> > !            values.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     NA  - number of t-points operated on by this row of the A of (*)
> > !     NB  - number of s-points operated on by this row of the B of (*)
> > !     ZA  - coordinates of t-points used in this row of (*)
> > !     ZB  - coordinates of s-points used in this row of (*)
> > !     Z0  - nominal point of application of this row of (*)
> > !
> > !   output argument list:
> > !     A   - the NA coefficients A for this scheme
> > !     B   - the NB coefficients B for this scheme
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: na,nb
> > REAL(r_kind)   , INTENT(IN   ) :: za(na),zb(nb),z0
> > REAL(r_kind)   , INTENT(  OUT) :: a(na),b(nb)
> > !-----------------------------------------------------------------------------
> > INTEGER(i_kind)                    :: na1,nab,i
> > REAL(r_kind),DIMENSION(na+nb,na+nb):: w
> > REAL(r_kind),DIMENSION(na)         :: za0,pa
> > REAL(r_kind),DIMENSION(nb)         :: zb0,pb
> > REAL(r_kind),DIMENSION(na+nb)      :: ab
> > !=============================================================================
> > na1=na+1; nab=na+nb
> > za0=za-z0  ; zb0=zb-z0
> > pa=one;     pb=-one
> > w=zero;     ab=zero
> > w(1,1:na)=one; ab(1)=one
> > DO i=2,nab; w(i,1:na)=pa;    pa=pa*za0; w(i,na1:nab)=pb; pb=pb*zb0; ENDDO
> > CALL inv_d(w,ab)
> > a=ab(1:na); b=ab(na1:nab)
> > END SUBROUTINE davco
> > 
> > 
> > !=============================================================================
> > SUBROUTINE avco(na,nb,za,zb,z0,a,b) 
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    avco
> > !
> > !   prgrmmr:    purser                                        1999
> > !
> > ! abstract:  Compute one row of the coefficients for the compact mid-interval
> > !            interpolation scheme characterized by matrix equation of the form,
> > !                        A.t = B.s                             (*)
> > !            Where s is the vector of "source" values, t the staggered "target"
> > !            values.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     NA  - number of t-points operated on by this row of the A of (*)
> > !     NB  - number of s-points operated on by this row of the B of (*)
> > !     ZA  - coordinates of t-points used in this row of (*)
> > !     ZB  - coordinates of s-points used in this row of (*)
> > !     Z0  - nominal point of application of this row of (*)
> > !
> > !   output argument list:
> > !     A   - the NA coefficients A for this scheme
> > !     B   - the NB coefficients B for this scheme
> > !   
> > ! attributes:  
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: na,nb
> > REAL(r_kind),    INTENT(IN   ) :: za(na),zb(nb),z0
> > REAL(r_kind),    INTENT(  OUT) :: a(na),b(nb)
> > !-----------------------------------------------------------------------------
> > INTEGER(i_kind)                     :: na1,nab,i
> > REAL(r_kind), DIMENSION(na+nb,na+nb):: w
> > REAL(r_kind), DIMENSION(na)         :: za0,pa
> > REAL(r_kind), DIMENSION(nb)         :: zb0,pb
> > REAL(r_kind), DIMENSION(na+nb)      :: ab
> > !=============================================================================
> > na1=na+1; nab=na+nb
> > za0=za-z0  ; zb0=zb-z0
> > pa=one;     pb=-one
> > w=zero;     ab=zero
> > w(1,1:na)=one; ab(1)=one
> > DO i=2,nab; w(i,1:na)=pa;    pa=pa*za0; w(i,na1:nab)=pb; pb=pb*zb0; ENDDO
> > CALL inv(w,ab)
> > a=ab(1:na); b=ab(na1:nab)
> > END SUBROUTINE avco 
> > 
> > 
> > !=============================================================================
> > SUBROUTINE ddfco(na,nb,za,zb,z0,a,b) 
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ddfco
> > !
> > !   prgrmmr:    purser                                        1999
> > !
> > ! abstract:  Compute one row of the coefficients for either the compact 
> > !            differencing or quadrature scheme characterized by matrix 
> > !            equation of the form,
> > !			 A.d = B.c			       (*)
> > !            In either case, d is the derivative of c.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     NA  - number of d-points operated on by this row of the A of (*)
> > !     NB  - number of c-points operated on by this row of the B of (*)
> > !     ZA  - coordinates of d-points used in this row of (*)
> > !     ZB  - coordinates of c-points used in this row of (*)
> > !     Z0  - nominal point of application of this row of (*)
> > !
> > !   output argument list:
> > !     A   - the A-coefficients for this scheme
> > !     B   - the B-coefficients for this scheme
> > !   
> > ! attributes:  
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: na,nb
> > REAL(r_kind)   , INTENT(IN   ) :: za(na),zb(nb),z0
> > REAL(r_kind)   , INTENT(  OUT) :: a(na),b(nb)
> > !-----------------------------------------------------------------------------
> > INTEGER(i_kind)                     :: na1,nab,i
> > REAL(r_kind), DIMENSION(na+nb,na+nb):: w
> > REAL(r_kind), DIMENSION(na)         :: za0,pa
> > REAL(r_kind), DIMENSION(nb)         :: zb0,pb
> > REAL(r_kind), DIMENSION(na+nb)      :: ab
> > !=============================================================================
> > na1=na+1; nab=na+nb
> > za0=za-z0  ; zb0=zb-z0
> > pa=one;     pb=-one
> > w=zero;     ab=zero
> > w(1,1:na)=one; ab(1)=one
> > DO i=3,nab; w(i,1:na)   =pa*(i-2); pa=pa*za0; ENDDO
> > DO i=2,nab; w(i,na1:nab)=pb;              pb=pb*zb0; ENDDO
> > CALL inv_d(w,ab)
> > a=ab(1:na); b=ab(na1:nab)
> > END SUBROUTINE ddfco 
> > 
> > 
> > !=============================================================================
> > SUBROUTINE dfco(na,nb,za,zb,z0,a,b)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dfco
> > !
> > !   prgrmmr:    purser                                        1999
> > !
> > ! abstract:  Compute one row of the coefficients for either the compact
> > !            differencing or quadrature scheme characterized by matrix
> > !            equation of the form,
> > !                        A.d = B.c                             (*)
> > !            In either case, d is the derivative of c.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     NA  - number of d-points operated on by this row of the A of (*)
> > !     NB  - number of c-points operated on by this row of the B of (*)
> > !     ZA  - coordinates of d-points used in this row of (*)
> > !     ZB  - coordinates of c-points used in this row of (*)
> > !     Z0  - nominal point of application of this row of (*)
> > !
> > !   output argument list:
> > !     A   - the A-coefficients for this scheme
> > !     B   - the B-coefficients for this scheme
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: na,nb
> > REAL(r_kind),    INTENT(IN   ) :: za(na),zb(nb),z0
> > REAL(r_kind),    INTENT(  OUT) :: a(na),b(nb)
> > !-----------------------------------------------------------------------------
> > INTEGER(i_kind)                     :: na1,nab,i
> > REAL(r_kind), DIMENSION(na+nb,na+nb):: w
> > REAL(r_kind), DIMENSION(na)         :: za0,pa
> > REAL(r_kind), DIMENSION(nb)         :: zb0,pb
> > REAL(r_kind), DIMENSION(na+nb)      :: ab
> > !=============================================================================
> > na1=na+1; nab=na+nb
> > za0=za-z0  ; zb0=zb-z0
> > pa=one;     pb=-one
> > w=zero;     ab=zero
> > w(1,1:na)=one; ab(1)=one
> > DO i=3,nab; w(i,1:na)   =pa*(i-2); pa=pa*za0; ENDDO
> > DO i=2,nab; w(i,na1:nab)=pb;              pb=pb*zb0; ENDDO
> > CALL inv(w,ab)
> > a=ab(1:na); b=ab(na1:nab)
> > END SUBROUTINE dfco 
> > 
> > 
> > !=============================================================================
> > SUBROUTINE ddfco2(na,nb,za,zb,z0,a,b) 
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ddfco2
> > !
> > !   prgrmmr:    purser                                        1999
> > !
> > ! abstract:  Compute one row of the coefficients for either the compact second-
> > !            differencing scheme characterized by matrix equation of the form,
> > !			 A.d = B.c			       (*)
> > !            Where d is the second-derivative of c.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     NA   - number of d-points operated on by this row of the A of (*)
> > !     NB   - number of c-points operated on by this row of the B of (*)
> > !     ZA   - coordinates of d-points used in this row of (*)
> > !     ZB   - coordinates of c-points used in this row of (*)
> > !     Z0   - nominal point of application of this row of (*)
> > !
> > !   output argument list:
> > !     A    - the NA coefficients A for this scheme
> > !     B    - the NB coefficients B for this scheme
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: na,nb
> > REAL(r_kind)   , INTENT(IN   ) :: za(na),zb(nb),z0
> > REAL(r_kind)   , INTENT(  OUT) :: a(na),b(nb)
> > !-----------------------------------------------------------------------------
> > INTEGER(i_kind)                     :: na1,nab,i
> > REAL(r_kind), DIMENSION(na+nb,na+nb):: w
> > REAL(r_kind), DIMENSION(na)         :: za0,pa
> > REAL(r_kind), DIMENSION(nb)         :: zb0,pb
> > REAL(r_kind), DIMENSION(na+nb)      :: ab
> > !=============================================================================
> > na1=na+1; nab=na+nb
> > za0=za-z0  ; zb0=zb-z0
> > pa=one;     pb=-one
> > w=zero;     ab=zero
> > w(1,1:na)=one; ab(1)=one
> > DO i=4,nab; w(i,1:na)   =pa*(i-2)*(i-3); pa=pa*za0; ENDDO
> > DO i=2,nab; w(i,na1:nab)=pb;                           pb=pb*zb0; ENDDO
> > CALL inv_d(w,ab)
> > a=ab(1:na); b=ab(na1:nab)
> > END SUBROUTINE ddfco2 
> > 
> > 
> > !=============================================================================
> > SUBROUTINE dfco2(na,nb,za,zb,z0,a,b) 
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dfco2
> > !
> > !   prgrmmr:    purser                                        1999
> > !
> > ! abstract:  Compute one row of the coefficients for either the compact second-
> > !            differencing scheme characterized by matrix equation of the form,
> > !                        A.d = B.c                             (*)
> > !            Where d is the second-derivative of c.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     NA   - number of d-points operated on by this row of the A of (*)
> > !     NB   - number of c-points operated on by this row of the B of (*)
> > !     ZA   - coordinates of d-points used in this row of (*)
> > !     ZB   - coordinates of c-points used in this row of (*)
> > !     Z0   - nominal point of application of this row of (*)
> > !
> > !   output argument list:
> > !     A    - the NA coefficients A for this scheme
> > !     B    - the NB coefficients B for this scheme
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: na,nb
> > REAL(r_kind),    INTENT(IN   ) :: za(na),zb(nb),z0
> > REAL(r_kind),    INTENT(  OUT) :: a(na),b(nb)
> > !-----------------------------------------------------------------------------
> > INTEGER(i_kind)                     :: na1,nab,i
> > REAL(r_kind), DIMENSION(na+nb,na+nb):: w
> > REAL(r_kind), DIMENSION(na)         :: za0,pa
> > REAL(r_kind), DIMENSION(nb)         :: zb0,pb
> > REAL(r_kind), DIMENSION(na+nb)      :: ab
> > !=============================================================================
> > na1=na+1; nab=na+nb
> > za0=za-z0  ; zb0=zb-z0
> > pa=one;     pb=-one
> > w=zero;     ab=zero
> > w(1,1:na)=one; ab(1)=one
> > DO i=4,nab; w(i,1:na)   =pa*(i-2)*(i-3); pa=pa*za0; ENDDO
> > DO i=2,nab; w(i,na1:nab)=pb;                           pb=pb*zb0; ENDDO
> > CALL inv(w,ab)
> > a=ab(1:na); b=ab(na1:nab)
> > END SUBROUTINE dfco2 
> > 
> > 
> > !=============================================================================
> > SUBROUTINE clib(a,m1,m2,mah1,mah2) ! Clip the dead space of the band matrix, a
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    clib
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Clip the dead space of the band matrix 
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1, m2, mah1, mah2  - 
> > !
> > !   output argument list:
> > !     a                   -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind)   , INTENT(INOUT) :: a(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                :: j
> > 
> > IF(m2-m1+mah1 < 0)STOP 'In CLIB, form of band matrix implies redundant rows'
> > DO j=1,mah1; a(1:min(m1,j),-j)=zero; ENDDO; DO j=m2-m1+1,mah2; a(max(1,m2-j+1):m1,j)=zero; ENDDO
> > END SUBROUTINE clib
> > 
> > 
> > !=============================================================================
> > SUBROUTINE dclib(a,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dclib
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Clip the dead space of the band matrix
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1, m2, mah1, mah2  - 
> > !
> > !   output argument list:
> > !     a                   - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind)   , INTENT(INOUT) :: a(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                :: j
> > 
> > IF(m2-m1+mah1 < 0)STOP 'In CLIB_d, form of band matrix implies redundant rows'
> > DO j=1,mah1; a(1:min(m1,j),-j)=zero; ENDDO; DO j=m2-m1+1,mah2; a(max(1,m2-j+1):m1,j)=zero; ENDDO
> > END SUBROUTINE dclib
> > 
> > 
> > !=============================================================================
> > SUBROUTINE cad1b(a,m1,mah1,mah2,mirror2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    cad1b
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Incorporate operand symmetry near end-1 of a band matrix operator
> > !
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A          -  Input as unclipped operator, output as symmetrized and clipped.
> > !     m1         - Sizes of implied full matrix
> > !     mah1, mah2 - Left and right semi-bandwidths of A.
> > !     mirror2    - 2*location of symmetry axis relative to end-1 operand element.
> > !
> > !   output argument list:
> > !     A          -  Input as unclipped operator, output as symmetrized and clipped.
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1,mah1,mah2,mirror2
> > REAL(r_kind),     INTENT(INOUT) :: a(0:m1-1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                :: i,i2,jm,jp,jpmax
> > 
> > IF(mirror2+mah1 > mah2)STOP 'In cad1b, mah2 insufficient'
> > DO i=0,m1-1; i2=i*2; jpmax=mirror2+mah1-i2; IF(jpmax <= -mah1)EXIT
> >    DO jm=-mah1,mah2; jp=mirror2-jm-i2; IF(jp <= jm)EXIT
> >       a(i,jp)=a(i,jp)+a(i,jm) ! Reflect and add
> >       a(i,jm)=zero            ! zero the exterior part
> >    ENDDO
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY     csb1b(a,m1,mah1,mah2,mirror2)
> > !=============================================================================
> > ! Like cad1b, but for antisymmetric operand
> > IF(mirror2+mah1 > mah2)STOP 'In csb1b, mah2 insufficient'
> > DO i=0,m1-1; i2=i*2; jpmax=mirror2+mah1-i2; IF(jpmax < -mah1)EXIT
> >    DO jm=-mah1,mah2; jp=mirror2-jm-i2; IF(jp < jm)EXIT
> >       a(i,jp)=a(i,jp)-a(i,jm) ! Reflect and subtract
> >       a(i,jm)=zero            ! zero the exterior part
> >    ENDDO
> > ENDDO
> > END SUBROUTINE cad1b
> > 
> > 
> > !=============================================================================
> > SUBROUTINE cad2b(a,m1,m2,mah1,mah2,mirror2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    cad2b
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Incorporate operand symmetry near end-2 of a band matrix operator
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A          - Input as unclipped operator, output as symmetrized and clipped.
> > !     m1, m2     - Sizes of implied full matrix
> > !     mah1, mah2 - Left and right semi-bandwidths of A.
> > !     mirror2    - 2*location of symmetry axis relative to end-2 operand element.
> > !
> > !   output argument list:
> > !     A         - Input as unclipped operator, output as symmetrized and clipped.
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1,m2,mah1,mah2,mirror2
> > REAL(r_kind),     INTENT(INOUT) :: a(1-m1:0,m1-m2-mah1:m1-m2+mah2)
> > 
> > INTEGER(i_kind)                :: i,i2,jm,jp,jmmin,nah1,nah2,mirror,j0
> > 
> > nah1=mah1+m2-m1; nah2=mah2+m1-m2 ! Effective 2nd-index bounds of A
> > IF(mirror2-nah1 > -nah2)STOP 'In cad2b, mah1 insufficient'
> > DO i=0,1-m1,-1; i2=i*2; jmmin=mirror2-nah2-i2; IF(jmmin >= nah2)EXIT
> >    DO jp=nah2,nah1,-1; jm=mirror2-jp-i2; IF(jm >= jp)EXIT
> >       a(i,jm)=a(i,jm)+a(i,jp) ! Reflect and add
> >       a(i,jp)=zero            ! zero the exterior part
> >    ENDDO
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY    csb2b(a,m1,m2,mah1,mah2,mirror2)
> > !=============================================================================
> > nah1=mah1+m2-m1; nah2=mah2+m1-m2 ! Effective 2nd-index bounds of A
> > IF(mirror2-nah1 > -nah2)STOP 'In csb2b, mah1 insufficient'
> > DO i=0,1-m1,-1; i2=i*2; jmmin=mirror2-nah2-i2; IF(jmmin > nah2)EXIT
> >    DO jp=nah2,nah1,-1; jm=mirror2-jp-i2; IF(jm > jp)EXIT
> >       a(i,jm)=a(i,jm)-a(i,jp) ! Reflect and subtract
> >       a(i,jp)=zero            ! zero the exterior part
> >    ENDDO
> > ENDDO
> > !=============================================================================
> > ENTRY    cex2b(a,m1,m2,mah1,mah2,mirror2)
> > !=============================================================================
> > nah1=mah1+m2-m1; nah2=mah2+m1-m2 ! Effective 2nd-index bounds of A
> > IF(mirror2-nah1 > -nah2)STOP 'In cex2b, mah1 insufficient'
> > mirror=mirror2/2
> > IF(mirror*2 /= mirror2)STOP 'In cex2b, mirror2 is not even'
> > DO i=0,1-m1,-1; i2=i*2; jmmin=mirror2-nah2-i2; IF(jmmin >= nah2)EXIT
> >    j0=mirror-i
> >    DO jp=nah2,nah1,-1; jm=mirror2-jp-i2; IF(jm >= jp)EXIT
> >       a(i,jm)=a(i,jm)-a(i,jp)    ! Reflect and subtract
> >       a(i,j0)=a(i,j0)+two*a(i,jp)! Apply double the coefficient to end
> >       a(i,jp)=zero               ! zero the exterior part
> >    ENDDO
> > ENDDO
> > END SUBROUTINE cad2b
> > 
> > 
> > !=============================================================================
> > SUBROUTINE copbt(a,b,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    copbt
> > !
> > !   prgrmmr:  R.J.Purser, National Meteorological Center, Washington D.C.  1994
> > !
> > ! abstract:  Copy transpose of rectangular banded matrix A to B
> > !
> > !     Note:  This routine expects A and B always to occupy separate storage.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A      - input matrix in banded format
> > !     M1     - number of rows of A, columns of B
> > !     M2     - number of columns of A, rows of B
> > !     MAH1   - left-half-bandwidth of A, right-half-bandwidth of B
> > !     MAH2   - right-half-bandwidth of A, left-half-bandwidth of B
> > !
> > !   output argument list:
> > !     B      - output matrix in banded format
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2)
> > REAL(r_kind),     INTENT(  OUT) :: b(m2,-mah2:mah1)
> > 
> > INTEGER(i_kind)                 :: j, i
> > 
> > CALL clib(b,mah2,mah1,m2,m1)
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); b(j+i,-j)=a(i,j); ENDDO
> > ENDDO
> > RETURN
> > ENTRY	 conbt(a,b,m1,m2,mah1,mah2)
> > CALL clib(b,mah2,mah1,m2,m1)
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); b(j+i,-j)=-a(i,j); ENDDO
> > ENDDO
> > END SUBROUTINE copbt
> > 
> > 
> > !=============================================================================
> > SUBROUTINE copmb(afull,aband,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    copmb
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1, m2, mah1, mah2  - 
> > !     afull               -
> > !
> > !   output argument list:
> > !     aband               - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),                           INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     DIMENSION(m1,m2),        INTENT(IN   ) :: afull
> > REAL(r_kind),     DIMENSION(m1,-mah1:mah2),INTENT(  OUT) :: aband
> > 
> > INTEGER(i_kind)                                          :: i1,i2, i, j
> > 
> > CALL clib(aband,m1,m2,mah1,mah2)
> > DO j=1,m1; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    DO i=i1,i2; aband(i,j)= afull(i,j+i); ENDDO
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY      conmb(afull,aband,m1,m2,mah1,mah2)
> > !=============================================================================
> > CALL clib(aband,m1,m2,mah1,mah2)
> > DO j=1,m1; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    DO i=i1,i2; aband(i,j)=-afull(i,j+i); ENDDO
> > ENDDO
> > END SUBROUTINE copmb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE copbm(aband,afull,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    copbm
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1, m2, mah1, mah2  - 
> > !     aband               -
> > !
> > !   output argument list:
> > !     afull               - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),                           INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     DIMENSION(m1,-mah1:mah2),INTENT(IN   ) :: aband
> > REAL(r_kind),     DIMENSION(m1,m2),        INTENT(  OUT) :: afull
> > 
> > INTEGER(i_kind)                                          :: i1,i2, i, j
> > 
> > afull=zero
> > DO j=1,m1; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    DO i=i1,i2; afull(i,j+i)= aband(i,j); ENDDO
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY      conbm(aband,afull,m1,m2,mah1,mah2)
> > !=============================================================================
> > afull=zero
> > DO j=1,m1; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    DO i=i1,i2; afull(i,j+i)=-aband(i,j); ENDDO
> > ENDDO
> > END SUBROUTINE copbm
> > 
> >  
> > !=============================================================================
> > SUBROUTINE mulbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulbb
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1, m2, mah1, mah2     - 
> > !     mbh1, mbh2, mch1, mch2 - 
> > !     a, b                   -
> > !     c                      -
> > !
> > !   output argument list:
> > !     c                   - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mbh1, mbh2, mch1, mch2
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), b(m2,-mbh1:mbh2)
> > REAL(r_kind),     INTENT(INOUT) :: c(m1,-mch1:mch2)
> > 
> > INTEGER(i_kind)                :: nch1, nch2, j, k, jpk, i1,i2
> > 
> > c=zero
> > ENTRY      madbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
> > nch1=mah1+mbh1; nch2=mah2+mbh2
> > IF(nch1 /= mch1 .OR. nch2 /= mch2)STOP 'In MULBB, dimensions inconsistent'
> > DO j=-mah1,mah2
> >    DO k=-mbh1,mbh2; jpk=j+k; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >       c(i1:i2,jpk)=c(i1:i2,jpk)+a(i1:i2,j)*b(j+i1:j+i2,k)
> >    ENDDO
> > ENDDO
> > END SUBROUTINE mulbb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE msbbb(a,b,c,m1,m2,mah1,mah2,mbh1,mbh2,mch1,mch2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    msbbb
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1, m2, mah1, mah2     - 
> > !     mbh1, mbh2, mch1, mch2 -
> > !     a, b                   -
> > !
> > !   output argument list:
> > !     c                      - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mbh1, mbh2, mch1, mch2
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), b(m2,-mbh1:mbh2)
> > REAL(r_kind),     INTENT(  OUT) :: c(m1,-mch1:mch2)
> > 
> > INTEGER(i_kind)                 :: nch1, nch2, j, k, jpk, i1,i2
> > 
> > nch1=mah1+mbh1; nch2=mah2+mbh2
> > IF(nch1 /= mch1 .OR. nch2 /= mch2)STOP 'In MSBBB, dimensions inconsistent'
> > DO j=-mah1,mah2
> >    DO k=-mbh1,mbh2; jpk=j+k; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >       c(i1:i2,jpk)=c(i1:i2,jpk)-a(i1:i2,j)*b(j+i1:j+i2,k)
> >    ENDDO
> > ENDDO
> > END SUBROUTINE msbbb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE LDUB(a,m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ldub
> > !
> > !   prgrmmr:    R.J.Purser, 1994
> > !
> > ! abstract:  Compute [L]*[D**-1]*[U] decomposition of asymmetric band-matrix
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A       - input as the asymmetric band matrix. On output, it contains
> > !               the [L]*[D**-1]*[U] factorization of the input matrix, where
> > !               [L] is lower triangular with unit main diagonal
> > !               [D] is a diagonal matrix
> > !               [U] is upper triangular with unit main diagonal
> > !     M       - The number of rows of array A
> > !     MAH1    - The left half-bandwidth of fortran array A
> > !     MAH2    - The right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     A       - input as the asymmetric band matrix. On output, it contains
> > !               the [L]*[D**-1]*[U] factorization of the input matrix, where
> > !               [L] is lower triangular with unit main diagonal
> > !               [D] is a diagonal matrix
> > !               [U] is upper triangular with unit main diagonal
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m,mah1, mah2 
> > REAL(r_kind),    INTENT(INOUT) :: a(m,-mah1:mah2) 
> > 
> > INTEGER(i_kind)               :: j, imost, jmost, jp, i
> > REAL(r_kind)                  :: ajj, ajji, aij
> > 
> > DO j=1,m
> >    imost=MIN(m,j+mah1)
> >    jmost=MIN(m,j+mah2)
> >    jp=j+1
> >    ajj=a(j,0)
> >    IF(ajj == zero)THEN
> >       PRINT '(" Failure in LDUB:"/" Matrix requires pivoting or is singular")'
> >       STOP
> >    ENDIF
> >    ajji=one/ajj
> >    a(j,0)=ajji
> >    DO i=jp,imost
> >       aij=ajji*a(i,j-i)
> >       a(i,j-i)=aij
> >       a(i,jp-i:jmost-i)=a(i,jp-i:jmost-i)-aij*a(j,jp-j:jmost-j)
> >    ENDDO
> >    a(j,jp-j:jmost-j)=ajji*a(j,jp-j:jmost-j)
> > ENDDO
> > END SUBROUTINE LDUB
> > 
> > 
> > !=============================================================================
> > SUBROUTINE DLDUB(a,m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dldub
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m, mah1, mah2  - 
> > !     a              - 
> > !
> > !   output argument list:
> > !     a              - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m,mah1, mah2 
> > REAL(r_kind)   ,  INTENT(INOUT) :: a(m,-mah1:mah2) 
> > 
> > INTEGER(i_kind)                :: j, imost, jmost, jp, i
> > REAL(r_kind)                   :: ajj, ajji, aij
> > 
> > DO j=1,m
> >    imost=MIN(m,j+mah1)
> >    jmost=MIN(m,j+mah2)
> >    jp=j+1
> >    ajj=a(j,0)
> >    IF(ajj == zero)THEN
> >       PRINT '(" Fails in LDUB_d:"/" Matrix requires pivoting or is singular")'
> >       STOP
> >    ENDIF
> >    ajji=one/ajj
> >    a(j,0)=ajji
> >    DO i=jp,imost
> >       aij=ajji*a(i,j-i)
> >       a(i,j-i)=aij
> >       a(i,jp-i:jmost-i)=a(i,jp-i:jmost-i)-aij*a(j,jp-j:jmost-j)
> >    ENDDO
> >    a(j,jp-j:jmost-j)=ajji*a(j,jp-j:jmost-j)
> > ENDDO
> > END SUBROUTINE DLDUB
> > 
> > !=============================================================================
> > SUBROUTINE L1UBB(a,b,m,mah1,mah2,mbh1,mbh2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    l1ubb
> > !
> > !   prgrmmr:    R.J.Purser, 1996
> > !
> > ! abstract:  Form the [L]*[D]*[U] decomposition of asymmetric band-matrix  
> > !            [A] replace lower triangular elements of [A] by [D**-1]*[L]*[D], 
> > !            the upper by [U], replace matrix [B] by [D**-1]*[B].
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !     M     - Number of rows of A and B
> > !     MAH1  - left half-width of fortran array A
> > !     MAH2  - right half-width of fortran array A
> > !     MBH1  - left half-width of fortran array B
> > !     MBH2  - right half-width of fortran array B
> > !
> > !   output argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) ::  m,mah1, mah2, mbh1, mbh2 
> > REAL(r_kind)   , INTENT(INOUT) :: a(m,-mah1:mah2), b(m,-mbh1:mbh2)
> > 
> > INTEGER(i_kind)                :: j, imost, jmost, jleast, jp, i
> > REAL(r_kind)                   :: ajj, ajji, aij
> > 
> > DO j=1,m
> >    imost=MIN(m,j+mah1)
> >    jmost=MIN(m,j+mah2)
> >    jleast=MAX(1,j-mah1)
> >    jp=j+1
> >    ajj=a(j,0)
> >    IF(ajj == zero)STOP 'failure in L1UBB'
> >    ajji=one/ajj
> >    a(j,jleast-j:jmost-j) = ajji * a(j,jleast-j:jmost-j)
> >    DO i=jp,imost
> >       aij=a(i,j-i)
> >       a(i,jp-i:jmost-i) = a(i,jp-i:jmost-i) - aij*a(j,jp-j:jmost-j)
> >    ENDDO
> >    a(j,0)=one
> >    b(j,-mbh1:mbh2) = ajji * b(j,-mbh1:mbh2)
> > ENDDO
> > END SUBROUTINE L1UBB
> > 
> > 
> > !=============================================================================
> > SUBROUTINE DL1UBB(a,b,m,mah1,mah2,mbh1,mbh2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dl1ubb
> > !
> > !   prgrmmr:    R.J.Purser, 1996
> > !
> > ! abstract:  Form the [L]*[D]*[U] decomposition of asymmetric band-matrix
> > !            [A] replace lower triangular elements of [A] by [D**-1]*[L]*[D],
> > !            the upper by [U], replace matrix [B] by [D**-1]*[B].
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !     M     - Number of rows of A and B
> > !     MAH1  - left half-width of fortran array A
> > !     MAH2  - right half-width of fortran array A
> > !     MBH1  - left half-width of fortran array B
> > !     MBH2  - right half-width of fortran array B
> > !
> > !   output argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) ::  mah1, mah2, mbh1, mbh2 
> > REAL(r_kind)   ,  INTENT(INOUT) :: a(m,-mah1:mah2), b(m,-mbh1:mbh2)
> > 
> > INTEGER(i_kind)                :: m,j, imost, jmost, jleast, jp, i
> > REAL(r_kind)                   :: ajj, ajji, aij
> > 
> > DO j=1,m
> >    imost=MIN(m,j+mah1)
> >    jmost=MIN(m,j+mah2)
> >    jleast=MAX(1,j-mah1)
> >    jp=j+1
> >    ajj=a(j,0)
> >    IF(ajj == zero)STOP 'failure in DL1UBB'
> >    AJJI=one/AJJ
> >    a(j,jleast-j:jmost-j) = ajji * a(j,jleast-j:jmost-j)
> >    DO I=JP,IMOST
> >       AIJ=A(I,J-I)
> >       a(i,jp-i:jmost-i) = a(i,jp-i:jmost-i) - aij*a(j,jp-j:jmost-j)
> >    ENDDO
> >    A(J,0)=one
> >    b(j,-mbh1:mbh2) = ajji * b(j,-mbh1:mbh2)
> > ENDDO
> > END SUBROUTINE DL1UBB
> > 
> > 
> > !=============================================================================
> > SUBROUTINE l1ueb(a,b,m,mah1,mah2,mbh1,mbh2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    l1ueb
> > !
> > !   prgrmmr:    R.J.Purser, 1998
> > !
> > ! abstract:  Form the [L]*[D]*[U] decomposition of asymmetric band-matrix
> > !            [A] replace all but row zero of the lower triangular
> > !            elements of [A] by [D**-1]*[L]*[D], the upper by [U],
> > !            replace matrix [B] by [D**-1]*[B].
> > !            This is a special adaptation of L1UBB used to process quadarature weights
> > !            for QEDBV etc in which the initial quadrature value is provided as input
> > !            instead of being implicitly assumed zero (which is the case for QZDBV etc).
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !     M     - number of rows of B, one less than the rows of A (which has "row 0")
> > !     MAH1  - left half-width of fortran array A
> > !     MAH2  - right half-width of fortran array A
> > !     MBH1  - left half-width of fortran array B
> > !     MBH2  - right half-width of fortran array B
> > !
> > !   output argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m,mah1, mah2, mbh1, mbh2 
> > REAL(r_kind)   , INTENT(INOUT) :: a(0:m,-mah1:mah2), b(m,-mbh1:mbh2)
> > 
> > INTEGER(i_kind) :: j, imost, jmost, jleast, jp, i
> > REAL(r_kind)    :: ajj, ajji, aij
> > 
> > DO j=1,m
> >    imost=MIN(m,j+mah1)
> >    jmost=MIN(m,j+mah2)
> >    jleast=MAX(0,j-mah1)
> >    jp=j+1
> >    ajj=a(j,0)
> >    IF(ajj == zero)STOP 'failure in L1UEB'
> >    ajji=one/ajj
> >    a(j,jleast-j:jmost-j) = ajji * a(j,jleast-j:jmost-j)
> >    DO i=jp,imost
> >       aij=a(i,j-i)
> >       a(i,jp-i:jmost-i) = a(i,jp-i:jmost-i) - aij*a(j,jp-j:jmost-j)
> >    ENDDO
> >    a(j,0)=one
> >    b(j,-mbh1:mbh2) = ajji * b(j,-mbh1:mbh2)
> > ENDDO
> > END SUBROUTINE l1ueb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE dl1ueb(a,b,m,mah1,mah2,mbh1,mbh2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dl1ueb
> > !
> > !   prgrmmr:    R.J.Purser, 1998
> > !
> > ! abstract:  Form the [L]*[D]*[U] decomposition of asymmetric band-matrix
> > !            [A] replace all but row zero of the lower triangular
> > !            elements of [A] by [D**-1]*[L]*[D], the upper by [U],
> > !            replace matrix [B] by [D**-1]*[B].
> > !            This is a special adaptation of L1UBB used to process quadarature weights
> > !            for QEDBV etc in which the initial quadrature value is provided as input
> > !            instead of being implicitly assumed zero (which is the case for QZDBV etc).
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !     M     - number of rows of B, one less than the rows of A (which has "row 0")
> > !     MAH1  - left half-width of fortran array A
> > !     MAH2  - right half-width of fortran array A
> > !     MBH1  - left half-width of fortran array B
> > !     MBH2  - right half-width of fortran array B
> > !
> > !   output argument list:
> > !     A     - input as band matrix, output as lower and upper triangulars with 1s
> > !             implicitly assumed to lie on the main diagonal. The product of these
> > !             triangular matrices is [D**-1]*[A], where [D] is a diagonal matrix.
> > !     B     - in as band matrix, out as same but premultiplied by diagonal [D**-1]
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m,mah1, mah2, mbh1, mbh2 
> > REAL(r_kind)   ,  INTENT(INOUT) :: a(0:,-mah1:), b(:,-mbh1:)
> > 
> > INTEGER(i_kind)                   :: j, imost, jmost, jleast, jp, i
> > REAL(r_kind)                      :: ajj, ajji, aij
> > 
> > DO j=1,m
> >    imost=MIN(m,j+mah1)
> >    jmost=MIN(m,j+mah2)
> >    jleast=MAX(0,j-mah1)
> >    jp=j+1
> >    ajj=a(j,0)
> >    IF(ajj == zero)STOP 'failure in L1UEB_d'
> >    ajji=one/ajj
> >    a(j,jleast-j:jmost-j) = ajji * a(j,jleast-j:jmost-j)
> >    DO i=jp,imost
> >       aij=a(i,j-i)
> >       a(i,jp-i:jmost-i) = a(i,jp-i:jmost-i) - aij*a(j,jp-j:jmost-j)
> >    ENDDO
> >    a(j,0)=one
> >    b(j,-mbh1:mbh2) = ajji * b(j,-mbh1:mbh2)
> > ENDDO
> > END SUBROUTINE dl1ueb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE L1LB(a,b,m,mah)   ! Cholesky LU decomposition of Banded.
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    l1lb
> > !
> > !   prgrmmr: 
> > !
> > ! abstract:  Cholesky LU decomposition of Banded.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A     - 
> > !     M     - 
> > !     MAH   - 
> > !
> > !   output argument list:
> > !     B     - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m, mah
> > REAL(r_kind),     INTENT(IN   ) :: a(m,-mah:mah)
> > REAL(r_kind),     INTENT(  OUT) :: b(m,-mah:0)
> > 
> > INTEGER(i_kind)                 :: i, j,jmi
> > REAL(r_kind)                    :: s
> > 
> > CALL clib(b,m,m,mah,0)
> > DO j=1,m
> >    s=a(j,0)-DOT_PRODUCT(b(j,-mah:-1),b(j,-mah:-1))
> >    IF(s <= zero)THEN
> >       PRINT '(" L1LB detects non-positivity at diagonal index",i5)',j
> >       STOP
> >    ENDIF
> >    s=SQRT(s); b(j,0)=s; s=one/s
> >    DO i=j+1,MIN(m,j+mah); jmi=j-i
> >       b(i,jmi)=s*(a(i,jmi)-DOT_PRODUCT(b(i,-mah:jmi-1),b(j,-mah-jmi:-1)))
> >    ENDDO
> > ENDDO
> > END SUBROUTINE L1LB
> > 
> > !=============================================================================
> > SUBROUTINE LDLB(a,b,d,m,mah) ! Modified Cholesky [L(D**-1)U, without sqrt]
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    ldlb
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:   Modified Cholesky [L(D**-1)U, without sqrt]
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a     - 
> > !     m     - 
> > !     mah   - 
> > !
> > !   output argument list:
> > !     b     - 
> > !     d     - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m, mah
> > REAL(r_kind),     INTENT(IN   ) :: a(m,-mah:mah)
> > REAL(r_kind),     INTENT(  OUT) :: b(m,-mah:0)
> > REAL(r_kind),     INTENT(  OUT) :: d(m) 
> > 
> > INTEGER(i_kind)                 :: i, j,k,jmi,lj,li
> > REAL(r_kind)                    :: s,t
> > 
> > CALL clib(b,m,m,mah,0); b(:,0)=one
> > DO j=1,m; lj=MAX(-mah,1-j)
> >    s=a(j,0)
> >    do k=lj,-1
> >       s=s-b(j,k)**2*d(k+j)
> >    enddo
> >    IF(s <= zero)THEN
> >       PRINT '(" LDLB detects non-positivity at diagonal index",i5)',j
> >       STOP
> >    ENDIF
> >    d(j)=s; s=one/s
> >    DO i=j+1,MIN(m,j+mah); jmi=j-i; li=MAX(-mah,1-i); lj=li-jmi
> >       t=a(i,jmi)
> >       do k=li,jmi-1
> >          t=t-b(i,k)*b(j,k-jmi)*d(i+k)
> >       enddo
> >       b(i,jmi)=s*t
> >    ENDDO
> > ENDDO
> > d=one/d
> > END SUBROUTINE LDLB
> > 
> > !=============================================================================
> > SUBROUTINE DLDLB(a,b,d,m,mah) ! Modified Cholesky [L(D**-1)U, without sqrt]
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dl1lb
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:  Modified Cholesky [L(D**-1)U, without sqrt]
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a     - 
> > !     m     - 
> > !     mah   - 
> > !
> > !   output argument list:
> > !     b     - 
> > !     d     - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m, mah
> > REAL(r_kind)   ,  INTENT(IN   ) :: a(m,-mah:mah)
> > REAL(r_kind)   ,  INTENT(  OUT) :: b(m,-mah:0)
> > REAL(r_kind)   ,  INTENT(  OUT) :: d(m) 
> > 
> > INTEGER(i_kind)                 :: i, j,k,jmi,lj,li
> > REAL(r_kind)                    :: s,t
> > 
> > CALL clib_d(b,m,m,mah,0); b(:,0)=one
> > DO j=1,m; lj=MAX(-mah,1-j)
> >    s=a(j,0)
> >    do k=lj,-1
> >       s=s-b(j,k)**2*d(k+j)
> >    enddo
> >    IF(s <= zero)THEN
> >       PRINT '(" DLDLB detects non-positivity at diagonal index",i5)',j
> >       STOP
> >    ENDIF
> >    d(j)=s; s=one/s
> >    DO i=j+1,MIN(m,j+mah); jmi=j-i;  
> >       li=MAX(-mah,1-i); 
> >       lj=li-jmi; 
> >       t=a(i,jmi)
> >       do k=li,jmi-1
> >          t=t-b(i,k)*b(j,k-jmi)*d(i+k)
> >       enddo
> >       b(i,jmi)=s*t
> >    ENDDO
> > ENDDO
> > d=one/d
> > END SUBROUTINE DLDLB
> > 
> > !=============================================================================
> > SUBROUTINE UDUB(a,b,d,m,mah) ! Modified reverse Cholesky [U(D**-1)U^t],
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udub
> > !
> > !   prgrmmr:    
> > !
> > ! abstract:   Modified reverse Cholesky [U(D**-1)U^t],
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a     - 
> > !     m     - 
> > !     mah   - 
> > !
> > !   output argument list:
> > !     b     - 
> > !     d     - 
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),        INTENT(IN   ) :: m, mah
> > REAL(r_kind),           INTENT(IN   ) :: a(m,-mah:mah)
> > REAL(r_kind),           INTENT(  OUT) :: b(m,0:mah)
> > REAL(r_kind),           INTENT(  OUT) :: d(m) 
> > 
> > REAL(r_kind), DIMENSION(m,-mah:mah  ) :: at
> > REAL(r_kind), DIMENSION(m,-mah:0)     :: bt
> > REAL(r_kind), DIMENSION(m)            :: dt
> > 
> > at=a(m:1:-1,mah:-mah:-1); CALL ldlb(at,bt,dt,m,mah);
> > b=bt(m:1:-1,0:-mah:-1); d=dt(m:1:-1)
> > END SUBROUTINE UDUB
> > 
> > 
> > !=============================================================================
> > SUBROUTINE DUDUB(a,b,d,m,mah) ! Modified reverse Cholesky [U(D**-1)U^t],
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    dudub
> > !
> > !   prgrmmr:       
> > !
> > ! abstract:   Modified reverse Cholesky [U(D**-1)U^t],
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     a     - 
> > !     m     - 
> > !     mah   - 
> > !
> > !   output argument list:
> > !     b     -
> > !     d     -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),        INTENT(IN   ) :: m, mah
> > REAL(r_kind),           INTENT(IN   ) :: a(m,-mah:mah)
> > REAL(r_kind),           INTENT(  OUT) :: b(m,0:mah)
> > REAL(r_kind),           INTENT(  OUT) :: d(m) 
> > 
> > REAL(r_kind), DIMENSION(m,-mah:mah  ) :: at
> > REAL(r_kind), DIMENSION(m,-mah:0)     :: bt
> > REAL(r_kind), DIMENSION(m)            :: dt
> > 
> > at=a(m:1:-1,mah:-mah:-1); CALL ldlb_d(at,bt,dt,m,mah);
> > b=bt(m:1:-1,0:-mah:-1);   d=dt(m:1:-1)
> > END SUBROUTINE DUDUB
> > 
> > 
> > !=============================================================================
> > SUBROUTINE mulbv(a,v1,v2, m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulbv
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of a Banded matrix times a Vector.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - is the matrix
> > !     V1   - the input vector
> > !     M1   - the number of rows assumed for A and for V2
> > !     M2   - the number of columns assumed for A and rows for V1
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     V2   - the output vector
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), v1(m2)
> > REAL(r_kind),     INTENT(  OUT) :: v2(m1)
> > 
> > INTEGER(i_kind)                 :: j, i1,i2 
> > 
> > v2 = zero
> > !=============================================================================
> > ENTRY	 madbv(a,v1,v2, m1,m2,mah1,mah2)
> > !=============================================================================
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    v2(i1:i2) = v2(i1:i2) + a(i1:i2,j)*v1(j+i1:j+i2)
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY	 msbbv(a,v1,v2, m1,m2,mah1,mah2)
> > !=============================================================================
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    v2(i1:i2) = v2(i1:i2) - a(i1:i2,j)*v1(j+i1:j+i2)
> > ENDDO
> > END SUBROUTINE mulbv
> > 
> > 
> > !=============================================================================
> > SUBROUTINE mulbx(a,v1,v2, m1,m2,mah1,mah2,my)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulbx
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of a Banded matrix times parallel X-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - is the matrix
> > !     V1   - the array of input vectors
> > !     M1   - the number of rows assumed for A and for V2
> > !     M2   - the number of columns assumed for A and rows for V1
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MY   - the number of parallel X-vectors
> > !
> > !   output argument list:
> > !     V2   - the array of output vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, my
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), v1(m2,my)
> > REAL(r_kind),     INTENT(  OUT) :: v2(m1,my)
> > 
> > INTEGER(i_kind)                 :: i,j
> > 
> > v2=zero
> > !=============================================================================
> > ENTRY	 madbx(a,v1,v2, m1,m2,mah1,mah2,my)
> > !=============================================================================
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(i,:)=v2(i,:)+a(i,j)*v1(i+j,:); ENDDO
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY	 msbbx(a,v1,v2, m1,m2,mah1,mah2,my)
> > !=============================================================================
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(i,:)=v2(i,:)-a(i,j)*v1(i+j,:); ENDDO
> > ENDDO
> > END SUBROUTINE mulbx
> > 
> > 
> > !=============================================================================
> > SUBROUTINE mulby(a,v1,v2, m1,m2,mah1,mah2,mx)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulby
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of a Banded matrix times parallel Y-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - is the matrix
> > !     V1   - the array of input vectors
> > !     M1   - the number of rows assumed for A and for V2
> > !     M2   - the number of columns assumed for A and rows for V1
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MX   - the length of each of the of parallel Y-vectors
> > !
> > !   output argument list:
> > !     V2   - the array of output vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mx
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2), v1(mx,m2)
> > REAL(r_kind),     INTENT(  OUT) :: v2(mx,m1)
> > 
> > INTEGER(i_kind)                 :: i,j
> > 
> > v2(1:mx,1:m1) = zero
> > ENTRY	 madby(a,v1,v2, m1,m2,mah1,mah2,mx)
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(:,i)=v2(:,i)+a(i,j)*v1(:,i+j); ENDDO
> > ENDDO
> > RETURN
> > ENTRY	 msbby(a,v1,v2, m1,m2,mah1,mah2,mx)
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(:,i)=v2(:,i)-a(i,j)*v1(:,i+j); ENDDO
> > ENDDO
> > END SUBROUTINE mulby
> > 
> > 
> > !=============================================================================
> > SUBROUTINE MULVB(v1,a,v2, m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulvb
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of a Vector times a Banded matrix.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V1   - the input row-vector
> > !     A    - is the matrix
> > !     M1   - the number of rows assumed for A and columns for V1
> > !     M2   - the number of columns assumed for A and for V2
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     V2   - the output vector
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: v1(m1), a(m1,-mah1:mah2)
> > REAL(r_kind),     INTENT(  OUT) :: v2(m2)
> > 
> > INTEGER(i_kind)                 :: j, i1,i2
> > 
> > v2=zero
> > !=============================================================================
> > ENTRY	 madvb(v1,a,v2, m1,m2,mah1,mah2)
> > !=============================================================================
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    v2(j+i1:j+i2)=v2(j+i1:j+i2)+v1(i1:i2)*a(i1:i2,j)
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY	 msbvb(v1,a,v2, m1,m2,mah1,mah2)
> > !=============================================================================
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    v2(j+i1:j+i2)=v2(j+i1:j+i2)-v1(i1:i2)*a(i1:i2,j)
> > ENDDO
> > END SUBROUTINE mulvb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE mulxb(v1,a,v2, m1,m2,mah1,mah2,my)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulxb
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of X-Vectors times Banded matrix.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V1   - the array of input row-vectors
> > !     A    - is the matrix
> > !     M1   - the number of rows assumed for A and columns for V1
> > !     M2   - the number of columns assumed for A and V2
> > !     MAH1 -  the left half-bandwidth of fortran array A
> > !     MAH2 -  the right half-bandwidth of fortran array A
> > !     MY   - the number of parallel X-vectors
> > !
> > !   output argument list:
> > !     V2   - the array of output vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, my
> > REAL(r_kind),     INTENT(IN   ) :: v1(m1,my), a(m1,-mah1:mah2)
> > REAL(r_kind),     INTENT(  OUT) :: v2(m2,my)
> > 
> > INTEGER(i_kind)                 :: i,j
> > 
> > v2=zero
> > !=============================================================================
> > ENTRY	 madxb(v1,a,v2, m1,m2,mah1,mah2,my)
> > !=============================================================================
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(j+i,:)=v2(j+i,:)+v1(i,:)*a(i,j); ENDDO
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY	 msbxb(v1,a,v2, m1,m2,mah1,mah2,my)
> > !=============================================================================
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(j+i,:)=v2(j+i,:)-v1(i,:)*a(i,j); ENDDO
> > ENDDO
> > END SUBROUTINE mulxb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE mulyb(v1,a,v2, m1,m2,mah1,mah2,mx)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulyb
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of Y-Vectors times a Banded matrix.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - is the matrix
> > !     V1   - the array of input row-vectors
> > !     M1   - the number of rows assumed for A and colums for V1
> > !     M2   - the number of columns assumed for A and V2
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MX   - the length of each of the parallel Y-vectors
> > !
> > !   output argument list:
> > !     V2   - the array of output vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2, mx
> > REAL(r_kind),     INTENT(IN   ) :: v1(mx,m1), a(m1,-mah1:mah2)
> > REAL(r_kind),     INTENT(  OUT) :: v2(mx,m2)
> > 
> > INTEGER(i_kind)                 :: i,j
> > 
> > v2=zero
> > ENTRY	 madyb(v1,a,v2, m1,m2,mah1,mah2,mx)
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(:,j+i)=v2(:,j+i)+v1(:,i)*a(i,j); ENDDO
> > ENDDO
> > RETURN
> > ENTRY	 msbyb(v1,a,v2, m1,m2,mah1,mah2,mx)
> > DO j=-mah1,mah2
> >    DO i=MAX(1,1-j),MIN(m1,m2-j); v2(:,j+i)=v2(:,j+i)-v1(:,i)*a(i,j); ENDDO
> > ENDDO
> > END SUBROUTINE mulyb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE mulbd(a,d,b,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    mulbd
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of a Banded matrix times a Diagonal
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - is the input banded-matrix
> > !     D    - the diagonal matrix
> > !     M1   - the number of rows assumed for A and for B
> > !     M2   - number of columns assumed for A and B, number of elements of D
> > !     MAH1 - the left half-bandwidth of arrays A and B
> > !     MAH2 - the right half-bandwidth of arrays A and B
> > !
> > !   output argument list:
> > !     B    - the output matrix
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: d(m2)
> > REAL(r_kind),     INTENT(INOUT) :: a(m1,-mah1:mah2),b(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                :: j, i1,i2
> > 
> > CALL clib(b,m1,m2,mah1,mah2)
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    b(i1:i2,j)=a(i1:i2,j)*d(j+i1:j+i2)
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY	 madbd(a,d,b,m1,m2,mah1,mah2)
> > !=============================================================================
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    b(i1:i2,j) = b(i1:i2,j)+a(i1:i2,j)*d(j+i1:j+i2)
> > ENDDO
> > RETURN
> > !=============================================================================
> > ENTRY	 msbbd(a,d,b,m1,m2,mah1,mah2)
> > !=============================================================================
> > DO j=-mah1,mah2; i1=MAX(1,1-j); i2=MIN(m1,m2-j)
> >    b(i1:i2,j) = b(i1:i2,j)-a(i1:i2,j)*d(j+i1:j+i2)
> > ENDDO
> > END SUBROUTINE mulbd
> > 
> > 
> > !=============================================================================
> > SUBROUTINE muldb(d,a,b,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    muldb
> > !
> > !   prgrmmr:     R.J.Purser,  1994
> > !
> > ! abstract:      MULtipication of a Banded matrix times a Diagonal
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     D    - the diagonal matrix
> > !     A    - is the input banded-matrix ! <->  if A and B are actually
> > !     M1   - the number of rows assumed for A and for B
> > !     M2   - number of columns assumed for A and B, number of elements of D
> > !     MAH1 - the left half-bandwidth of arrays A and B
> > !     MAH2 - the right half-bandwidth of arrays A and B
> > !
> > !   output argument list:
> > !     B    - the output matrix          ! <->  equivalent arrays.
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: d(m1)
> > REAL(r_kind),     INTENT(INOUT) :: a(m1,-mah1:mah2),b(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                 :: j
> > 
> > CALL clib(b,m1,m2,mah1,mah2)
> > DO j=-mah1,mah2; b(:,j)=d(:)*a(:,j); ENDDO
> > END SUBROUTINE muldb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE maddb(d,a,b,m1,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    maddb
> > !
> > !   prgrmmr:     
> > !
> > ! abstract:      
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d    - 
> > !     M1   - 
> > !     MAH1 - 
> > !     MAH2 -
> > !     a    -
> > !     b    -
> > !
> > !   output argument list:
> > !     a    -
> > !     b    -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: d(m1)
> > REAL(r_kind),     INTENT(INOUT) :: a(m1,-mah1:mah2),b(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                 :: j
> > 
> > DO j=-mah1,mah2; b(:,j)=b(:,j)+d(:)*a(:,j); ENDDO
> > END SUBROUTINE maddb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE msbdb(d,a,b,m1,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    msbdb
> > !
> > !   prgrmmr:
> > !
> > ! abstract:
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     d    - 
> > !     M1   - 
> > !     MAH1 - 
> > !     MAH2 - 
> > !     a    -
> > !     b    -
> > !
> > !   output argument list:
> > !     a    -
> > !     b    -
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: d(m1) 
> > REAL(r_kind),     INTENT(INOUT) :: a(m1,-mah1:mah2),b(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)                 :: j
> > 
> > DO j=-mah1,mah2; b(:,j)=b(:,j)-d(:)*a(:,j); ENDDO
> > END SUBROUTINE msbdb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE udlbv(a,v, m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlbv
> > !
> > !   prgrmmr:     R.J.Purser, 1994
> > !
> > ! abstract:      BACk-substitution step of linear inversion involving
> > !                Banded matrix and Vector.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the (L)*(D**-1)*(U) factorization of the linear-system
> > !            matrix, as supplied by subroutine LDUB
> > !     V    - input as right-hand-side vector, output as solution vector
> > !     M    - the number of rows assumed for A and for V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vector, output as solution vector
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ):: m, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ):: a(m,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT):: v(m)
> > 
> > INTEGER(i_kind)                :: i, j
> > REAL(r_kind)                   :: vj
> > 
> > DO j=1,m
> >    vj=v(j)
> >    DO i=j+1,MIN(m,j+mah1); v(i)=v(i)-a(i,j-i)*vj; ENDDO; v(j)=a(j,0)*vj
> > ENDDO
> > DO j=m,2,-1
> >    vj=v(j)
> >    DO i=MAX(1,j-mah2),j-1; v(i)=v(i)-a(i,j-i)*vj; ENDDO
> > ENDDO
> > END SUBROUTINE udlbv
> > 
> > 
> > !=============================================================================
> > SUBROUTINE udlbx(a,v, mx,mah1,mah2,my)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlbx
> > !
> > !   prgrmmr:     R.J.Purser, 1994
> > !
> > ! abstract:      BACk-substitution step of parallel linear inversion involving
> > !                Banded matrix and X-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the (L)*(D**-1)*(U) factorization of the linear-system
> > !            matrix, as supplied by subroutine LDUB or, if N=NA, by LDUB
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     MX   - the number of rows assumed for A and length of
> > !            X-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MY   - number of parallel X-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: mx, mah1, mah2, my
> > REAL(r_kind),     INTENT(IN   ) :: a(mx,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: jx, ix
> > 
> > DO jx=1,mx
> >    DO ix=jx+1,MIN(mx,jx+mah1); v(ix,:) = v(ix,:) - a(ix,jx-ix)*v(jx,:); ENDDO
> >    v(jx,:) = a(jx,0) * v(jx,:)
> > ENDDO
> > DO jx=mx,2,-1
> >    DO ix=MAX(1,jx-mah2),jx-1; v(ix,:) = v(ix,:) - a(ix,jx-ix)*v(jx,:); ENDDO
> > ENDDO
> > END SUBROUTINE udlbx
> > 
> > 
> > !=============================================================================
> > SUBROUTINE udlby(a,v, my,mah1,mah2,mx)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlby
> > !
> > !   prgrmmr:     R.J.Purser, 1994
> > !
> > ! abstract:      BACk-substitution step of parallel linear inversion involving
> > !                Banded matrix and Y-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the (L)*(D**-1)*(U) factorization of the linear-system
> > !            matrix, as supplied by subroutine LDUB or, if N=NA, by LDUB
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     MY   - the number of rows assumed for A and length of
> > !            Y-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MX   - number of parallel Y-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: my, mah1, mah2, mx
> > REAL(r_kind),     INTENT(IN   ) :: a(my,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: iy, jy
> > 
> > DO jy=1,my
> >    DO iy=jy+1,MIN(my,jy+mah1); v(:,iy) = v(:,iy)-a(iy,jy-iy)*v(:,jy); ENDDO
> >    v(:,jy)=a(jy,0)*v(:,jy)
> > ENDDO
> > DO jy=my,2,-1
> >    DO iy=MAX(1,jy-mah2),jy-1; v(:,iy)=v(:,iy)-a(iy,jy-iy)*v(:,jy); ENDDO
> > ENDDO
> > END SUBROUTINE udlby
> > 
> > 
> > !=============================================================================
> > SUBROUTINE udlvb(v,a, m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlvb
> > !
> > !   prgrmmr:     R.J.Purser, 1994
> > !
> > ! abstract:      BACk-substitution step of linear inversion involving
> > !                row-Vector and Banded matrix.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the (L)*(D**-1)*(U) factorization of the linear-system
> > !            matrix, as supplied by subroutine LDUB
> > !     M    - the number of rows assumed for A and columns for V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side row-vector, output as solution vector
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: a(m,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(m)
> > 
> > INTEGER(i_kind)                :: i, j
> > REAL(r_kind)                   :: vi
> > 
> > DO i=1,m
> >    vi=v(i)
> >    DO j=i+1,MIN(m,i+mah2); v(j)=v(j)-vi*a(i,j-i); ENDDO
> >    v(i)=vi*a(i,0)
> > ENDDO
> > DO i=m,2,-1
> >    vi=v(i)
> >    DO j=MAX(1,i-mah1),i-1; v(j)=v(j)-vi*a(i,j-i); ENDDO
> > ENDDO
> > END SUBROUTINE udlvb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE udlxb(v,a, mx,mah1,mah2,my)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlxb
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1994
> > !
> > ! abstract:     BACk-substitution step of parallel linear inversion involving
> > !               Banded matrix and row-X-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     A    - encodes the (L)*(D**-1)*(U) factorization of the linear-system
> > !            matrix, as supplied by subroutine LDUB
> > !     MX   - the number of rows assumed for A and length of
> > !            X-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MY   - number of parallel X-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: mx, mah1, mah2, my
> > REAL(r_kind),     INTENT(IN   ) :: a(mx,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: ix, jx
> > 
> > DO ix=1,mx
> >    DO jx=ix+1,MIN(mx,ix+mah2); v(jx,:)=v(jx,:)-v(ix,:)*a(ix,jx-ix); ENDDO
> >    v(ix,:)=v(ix,:)*a(ix,0)
> > ENDDO
> > DO ix=mx,2,-1
> >    DO jx=MAX(1,ix-mah1),ix-1; v(jx,:)=v(jx,:)-v(ix,:)*a(ix,jx-ix); ENDDO
> > ENDDO
> > END SUBROUTINE udlxb
> > 
> > !=============================================================================
> > SUBROUTINE udlyb(v,a, my,mah1,mah2,mx)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    udlyb
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1994
> > !
> > ! abstract:      BACk-substitution step of parallel linear inversion involving
> > !                Banded matrix and row-Y-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     A    - encodes the (L)*(D**-1)*(U) factorization of the linear-system
> > !            matrix, as supplied by subroutine LDUB
> > !     MY   - the number of rows assumed for A and length of
> > !            Y-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MX   - number of parallel Y-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: my, mah1, mah2, mx
> > REAL(r_kind),     INTENT(IN   ) :: a(my,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: iy, jy
> > 
> > DO iy=1,my
> >    DO jy=iy+1,MIN(my,iy+mah2); v(:,jy)=v(:,jy)-v(:,iy)*a(iy,jy-iy); ENDDO
> >    v(:,iy)=v(:,iy)*a(iy,0)
> > ENDDO
> > DO iy=my,2,-1
> >    DO jy=MAX(1,iy-mah1),iy-1; v(:,jy)=v(:,jy)-v(:,iy)*a(iy,jy-iy); ENDDO
> > ENDDO
> > END SUBROUTINE udlyb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE u1lbv(a,v, m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    u1lbv
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1996
> > !
> > ! abstract:      BACk-substitution step ((U**-1)*(L**-1)) of linear inversion 
> > !                involving special Banded matrix and right-Vector.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the [L]*[U] factorization of the linear-system
> > !            matrix, as supplied by subroutine L1UBB
> > !     V    - input as right-hand-side vector, output as solution vector
> > !     M    - the number of rows assumed for A and for V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vector, output as solution vector
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: a(m,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(m)
> > 
> > INTEGER(i_kind)                :: i, j
> > REAL(r_kind)                   :: vj
> > 
> > DO j=1,m
> >    vj=v(j)
> >    DO i=j+1,MIN(m,j+mah1); v(i)=v(i)-a(i,j-i)*vj; ENDDO
> > ENDDO
> > DO j=m,2,-1
> >    vj=v(j)
> >    DO i=MAX(1,j-mah2),j-1; v(i)=v(i)-a(i,j-i)*vj; ENDDO
> > ENDDO
> > END SUBROUTINE u1lbv
> > 
> > 
> > !=============================================================================
> > SUBROUTINE u1lbx(a,v, mx,mah1,mah2,my)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    u1lbx
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1996
> > !
> > ! abstract:      Special BaCk-substitution step of parallel linear inversion 
> > !                involving Banded matrix and X-right-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the [L]*[U] factorization of the linear-system
> > !            matrix, as supplied by subroutine L1UBB
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     MX   - the number of rows assumed for A and length of
> > !            X-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MY   - number of parallel X-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: mx, mah1, mah2, my
> > REAL(r_kind),     INTENT(IN   ) :: a(mx,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: ix, jx
> > 
> > DO jx=1,mx
> >    DO ix=jx+1,MIN(mx,jx+mah1); v(ix,:)=v(ix,:)-a(ix,jx-ix)*v(jx,:); ENDDO
> > ENDDO
> > DO jx=mx,2,-1
> >    DO ix=MAX(1,jx-mah2),jx-1; v(ix,:)=v(ix,:)-a(ix,jx-ix)*v(jx,:); ENDDO
> > ENDDO
> > END SUBROUTINE u1lbx
> > 
> > 
> > !=============================================================================
> > SUBROUTINE u1lby(a,v, my,mah1,mah2,mx)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    u1lby
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1996
> > !
> > ! abstract:      Special BaCk-substitution step of parallel linear inversion 
> > !                involving Banded matrix and Y-right-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - encodes the [L]*[U] factorization of the linear-system
> > !            matrix, as supplied by subroutine L1UBB
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     MY   - the number of rows assumed for A and length of
> > !            Y-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MX   - number of parallel Y-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: my, mah1, mah2, mx
> > REAL(r_kind),     INTENT(IN   ) :: a(my,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: iy, jy
> > 
> > DO jy=1,my
> >    DO iy=jy+1,MIN(my,jy+mah1); v(:,iy)=v(:,iy)-a(iy,jy-iy)*v(:,jy); ENDDO
> > ENDDO
> > DO jy=my,2,-1
> >    DO iy=MAX(1,jy-mah2),jy-1; v(:,iy)=v(:,iy)-a(iy,jy-iy)*v(:,jy); ENDDO
> > ENDDO
> > END SUBROUTINE u1lby
> > 
> > 
> > !=============================================================================
> > SUBROUTINE u1lvb(v,a, m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    u1lvb
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1996
> > !
> > ! abstract:      Special BaCk-substitution step of linear inversion involving
> > !                left-Vector and Banded matrix.
> > !
> > ! program history log:
> > !   2008-04-28  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V    - input as right-hand-side row-vector, output as solution vector
> > !     A    - encodes the special [L]*[U] factorization of the linear-system
> > !            matrix, as supplied by subroutine L1UBB
> > !     M    - the number of rows assumed for A and columns for V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side row-vector, output as solution vector
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m, mah1, mah2
> > REAL(r_kind),    INTENT(IN   ) :: a(m,-mah1:mah2)
> > REAL(r_kind),    INTENT(INOUT) :: v(m)
> > 
> > INTEGER(i_kind)               :: i, j
> > REAL(r_kind)                  :: vi
> > 
> > DO i=1,m
> >    vi=v(i)
> >    DO j=i+1,MIN(m,i+mah2); v(j)=v(j)-vi*a(i,j-i); ENDDO
> > ENDDO
> > DO i=m,2,-1
> >    vi=v(i)
> >    DO j=MAX(1,i-mah1),i-1; v(j)=v(j)-vi*a(i,j-i); ENDDO
> > ENDDO
> > END SUBROUTINE u1lvb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE u1lxb(v,a, mx,mah1,mah2,my)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    u1lxb
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1996
> > !
> > ! abstract:      Special BaCk-substitution step of parallel linear inversion 
> > !                involving Banded matrix and X-left-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     A    - encodes the special [L]*[U] factorization of the linear-system
> > !            matrix, as supplied by subroutine L1UBB
> > !     MX   - the number of rows assumed for A and length of
> > !            X-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MY   - number of parallel X-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: mx, mah1, mah2, my
> > REAL(r_kind),     INTENT(IN   ) :: a(mx,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: ix, jx
> > 
> > DO ix=1,mx
> >    DO jx=ix+1,MIN(mx,ix+mah2); v(jx,:)=v(jx,:)-v(ix,:)*a(ix,jx-ix); ENDDO
> > ENDDO
> > DO ix=mx,2,-1
> >    DO jx=MAX(1,ix-mah1),ix-1;  v(jx,:)=v(jx,:)-v(ix,:)*a(ix,jx-ix); ENDDO
> > ENDDO
> > END SUBROUTINE u1lxb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE u1lyb(v,a, my,mah1,mah2,mx)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    u1lyb
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1996
> > !
> > ! abstract:      Special BaCk-substitution step of parallel linear inversion 
> > !                involving special Banded matrix and Y-left-Vectors.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !     A    - encodes the [L]*[U] factorization of the linear-system
> > !            matrix, as supplied by subroutine L1UBB
> > !     MY   - the number of rows assumed for A and length of
> > !            Y-vectors stored in V
> > !     MAH1 - the left half-bandwidth of fortran array A
> > !     MAH2 - the right half-bandwidth of fortran array A
> > !     MX   - number of parallel Y-vectors inverted
> > !
> > !   output argument list:
> > !     V    - input as right-hand-side vectors, output as solution vectors
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: my, mah1, mah2, mx
> > REAL(r_kind),     INTENT(IN   ) :: a(my,-mah1:mah2)
> > REAL(r_kind),     INTENT(INOUT) :: v(mx,my)
> > 
> > INTEGER(i_kind)                :: iy, jy
> > 
> > DO iy=1,my
> >    DO jy=iy+1,MIN(my,iy+mah2); v(:,jy)=v(:,jy)-v(:,iy)*a(iy,jy-iy); ENDDO
> > ENDDO
> > DO iy=my,2,-1
> >    DO jy=MAX(1,iy-mah1),iy-1;  v(:,jy)=v(:,jy)-v(:,iy)*a(iy,jy-iy); ENDDO
> > ENDDO
> > END SUBROUTINE u1lyb
> > 
> > 
> > !=============================================================================
> > SUBROUTINE linbv(a,v,m,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    linbv
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1994
> > !
> > ! abstract:      Solve LINear system with square Banded-matrix and vector V
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     A    - system matrix on input, its [L]*[D**-1]*[U] factorization on exit
> > !     V    - vector of right-hand-sides on input, solution vector on exit
> > !     M    - order of matrix A
> > !     MAH1 - left half-bandwidth of A
> > !     MAH2 - right half-bandwidth of A
> > !
> > !   output argument list:
> > !     A    - system matrix on input, its [L]*[D**-1]*[U] factorization on exit
> > !     V    - vector of right-hand-sides on input, solution vector on exit
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind), INTENT(IN   ) :: m, mah1, mah2
> > REAL(r_kind),    INTENT(INOUT) :: a(m,-mah1:mah2), v(m)
> > 
> > CALL ldub(a,m,mah1,mah2)
> > CALL udlbv(a,v,m,mah1,mah2)
> > END SUBROUTINE linbv
> > 
> > 
> > !=============================================================================
> > SUBROUTINE wrtb(a,m1,m2,mah1,mah2)
> > !=============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    wrtb
> > !
> > !   prgrmmr:     
> > !
> > ! abstract:     
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     m1   -
> > !     m2   -
> > !     mah1 - 
> > !     mah2 -
> > !     a    -
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > implicit none
> > 
> > INTEGER(i_kind),  INTENT(IN   ) :: m1, m2, mah1, mah2
> > REAL(r_kind),     INTENT(IN   ) :: a(m1,-mah1:mah2)
> > 
> > INTEGER(i_kind)              :: i1, i2, i, j1, j2, j, nj1
> > 
> > DO i1=1,m1,20
> >    i2=MIN(i1+19,m1)
> >    PRINT '(7x,6(i2,10x))',(j,j=-mah1,mah2)
> >    DO i=i1,i2
> >       j1=MAX(-mah1,1-i)
> >       j2=MIN(mah2,m2-i)
> >       nj1=j1+mah1
> >       IF(nj1==0)PRINT '(1x,i3,6(1x,e12.5))',i,(a(i,j),j=j1,j2)
> >       IF(nj1==1)PRINT '(1x,i3,12x,5(1x,e12.5))',i,(a(i,j),j=j1,j2)
> >       IF(nj1==2)PRINT '(1x,i3,24x,4(1x,e12.5))',i,(a(i,j),j=j1,j2)
> >       IF(nj1==3)PRINT '(1x,i3,36x,3(1x,e12.5))',i,(a(i,j),j=j1,j2)
> >       IF(nj1==4)PRINT '(1x,i3,48x,2(1x,e12.5))',i,(a(i,j),j=j1,j2)
> >       IF(nj1==5)PRINT '(1x,i3,60x,1(1x,e12.5))',i,(a(i,j),j=j1,j2)
> >    ENDDO
> >    READ(*,*)
> > ENDDO
> > END SUBROUTINE wrtb
> > 
> > END MODULE MODULE_pmat2
> > 
> > module module_fitcons
> > !$$$ module documentation block
> > !           .      .    .                                       .
> > ! module:  module_fitcons
> > !  prgmmr: purser
> > !
> > ! abstract:
> > !
> > ! program history log:
> > !   1994-  -    purser
> > !   2008-04-28  safford - add stander module documentation block
> > !
> > ! subroutines included:
> > !   setq
> > !   lagw
> > !   infit
> > !
> > ! variable definitions:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > !============================================================================
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> > use constants, only: zero,one,two,three,five
> > implicit none
> > 
> > ! set default to private
> >   private
> > ! set subroutines to public
> >   public :: setq
> >   public :: lagw
> >   public :: infit
> > ! set passed variables to public
> >   public :: qco,dco,ldsig4,ldsig,nohp,sigc,nohm,no,sigb,noh,ico,wt,dwt
> >   public :: nop,hunit2,nom,nnit,rcrit,q,hunit,dwt1,wt1,q1,hunit1
> > 
> > integer(i_kind),parameter         :: noh=3,    nohm=noh-1,   nohp=noh+1,&
> >                                      no=noh*2, nom=no-1,     nop=no+1,   nnit=7
> > real(r_kind),parameter            :: sigc=three,  sigb=two
> > real(r_kind),dimension(no)        :: hunit,q,wt,dwt
> > real(r_kind),dimension(nom)       :: hunit1,hunit2,q1,wt1,dwt1
> > real(r_kind),dimension(-noh:noh)  :: qco
> > real(r_kind),dimension(-1-noh:noh):: ico,dco
> > real(r_kind)                      :: rcrit,ldsig,ldsig4
> > !============================================================================
> > 
> > contains
> > 
> > 
> > !============================================================================
> > SUBROUTINE setq(q,x,n) 
> > !============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    setq
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1994
> > !
> > ! abstract:      Precompute the N constant denominator factors of the 
> > !                N-point Lagrange polynomial interpolation formula.
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     X -   The N abscissae.
> > !     N -   The number of points involved.
> > !
> > !   output argument list:
> > !     Q -   The N denominator constants.
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> >   IMPLICIT NONE
> > 
> >   INTEGER(i_kind),          INTENT(in   ) :: n
> >   REAL(r_kind),DIMENSION(n),INTENT(in   ) :: x
> >   REAL(r_kind),DIMENSION(n),INTENT(  out) :: q
> > !-----------------------------------------------------------------------------
> >   INTEGER(i_kind)                         :: i,j
> > !=============================================================================
> > DO i=1,n
> >    q(i)=one
> >    DO j=1,n
> >       IF(j /= i)q(i)=q(i)/(x(i)-x(j))
> >    ENDDO
> > ENDDO
> > END SUBROUTINE setq 
> > 
> > 
> > !============================================================================
> > SUBROUTINE lagw(x,xt,q,w,dw,n) 
> > !============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    lagw
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1994
> > !
> > ! abstract:      Construct the Lagrange weights and their derivatives when 
> > !                target abscissa is known and denominators Q have already 
> > !                been precomputed
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block
> > !
> > !   input argument list:
> > !     X   - Grid abscissae
> > !     XT  - Target abscissa
> > !     Q   - Q factors (denominators of the Lagrange weight formula)
> > !     N   - Number of grid points involved in the interpolation
> > !
> > !   output argument list:
> > !     W   - Lagrange weights
> > !     DW  - Derivatives, dW/dX, of Lagrange weights W
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> >   IMPLICIT NONE
> > 
> >   INTEGER(i_kind),          INTENT(in   ) :: n
> >   REAL(r_kind),             INTENT(in   ) :: xt
> >   REAL(r_kind),DIMENSION(n),INTENT(in   ) :: x,q
> >   REAL(r_kind),DIMENSION(n),INTENT(  out) :: w,dw
> > !-----------------------------------------------------------------------------
> >   REAL(r_kind),DIMENSION(n)               :: sdit,d,di
> >   INTEGER(i_kind)                         :: i,j
> >   REAL(r_kind)                            :: p,s,sdil,sdir
> > !============================================================================
> > p=one      ! ...will become product of all the d(i)=xt-x(i)
> > DO i=1,n
> >    d(i)=xt-x(i)
> >    p=p*d(i)
> > ENDDO
> > 
> > !   test p to reveal whether any of the d(i) vanish:
> > IF(p == zero)THEN   ! xt coincides with a grid point - use special code:
> >    p=one            ! p will become the product of the nonzero d(i),
> >    s=zero           ! s will become the corresponding sum of q(i)/d(i)
> >    DO i=1,n
> >       IF(d(i) == zero)THEN
> >          j=i            ! identify the grid index corresponding to present xt
> >          w(j)=one       ! interpolation weighted entirely to this one.
> >       ELSE
> >          w(i)=zero
> >          p=p*d(i)
> >          dw(i)=q(i)/d(i)
> >          s=s+dw(i)
> >       ENDIF
> >    ENDDO
> >    dw(j)=-s*p
> >    DO i=1,n
> >       IF(i /= j)dw(i)=dw(i)*p
> >    ENDDO
> > ELSE             ! xt is not a grid point - use generic code:
> >    sdil=zero            ! will become the sum of terms to the left.
> >    sdir=zero            ! will become the sum of terms to the right.
> >    DO i=1,n
> >       di(i)=one/d(i)
> >       sdit(i)=sdil
> >       sdil=sdil+di(i)
> >       w(i)=q(i)*p*di(i)
> >    ENDDO
> >    DO i=n,1,-1
> >       sdit(i)=sdit(i)+sdir
> >       sdir=sdir+di(i)
> >       dw(i)=w(i)*sdit(i)
> >    ENDDO
> > ENDIF
> > END SUBROUTINE lagw 
> > 
> > 
> > 
> > !============================================================================
> > subroutine infit
> > !============================================================================
> > !$$$  subprogram documentation block
> > !                .      .    .
> > ! subprogram:    infit
> > !
> > !   prgrmmr:     R.J.Purser, National Meteorological Center, 1994
> > !
> > ! abstract:     
> > !
> > ! program history log:
> > !   2008-04-25  safford -- add subprogram doc block, rm unused vars
> > !
> > !   input argument list:
> > !
> > !   output argument list:
> > !
> > ! attributes:
> > !   language:  f90
> > !   machine:   ibm RS/6000 SP
> > !
> > !$$$ end documentation block
> > 
> > implicit none
> > 
> > integer(i_kind) :: i
> > real(r_kind)    :: divq,divd
> > !============================================================================
> > ! Initialize quantities that relate to interpolations:
> > do i=1,no; hunit(i)=i-noh; enddo
> > hunit1=hunit(:nom)    ; hunit2=hunit(2:)
> > call setq(q,hunit,no) ; call setq(q1,hunit1,nom)
> > rcrit=SQRT(EPSILON(one))
> > !------------------------------------
> > ! Initialize coefficients for quadrature, differencing and mdpt interpolation:
> > divq=967680_r_kind        ; divd=1024_r_kind
> > qco(0)=862564_r_kind/divq ; dco(0)=1225_r_kind/divd     ; ico(0)=1225_r_kind/(2*divd)
> > qco(1)= 57249_r_kind/divq ; dco(1)=-245_r_kind/(3*divd) ; ico(1)=-245_r_kind/(2*divd)
> > qco(2)= -5058_r_kind/divq ; dco(2)=  49_r_kind/(5*divd) ; ico(2)=  49_r_kind/(2*divd)
> > qco(3)=   367_r_kind/divq ; dco(3)=      -five/(7*divd) ; ico(3)=      -five/(2*divd)
> > qco(-1:-noh:-1)  = qco(1:noh) ! complete the stencil of quadrature coeffs.
> > dco(-1:-nohp:-1) =-dco(0:noh) ! complete the stencil of difference coeffs
> > ico(-1:-nohp:-1) = ico(0:noh) ! complete the stencil of interpolation coeffs.
> > !------------------------------------
> > ! Initial coefficients related to control of working grid resolution:
> > ldsig =log(sigc/sigb)
> > ldsig4=ldsig**4
> > end subroutine infit
> > end module module_fitcons
> > 
> > 
> > 
> 29,31c6646,6648
> < use m_plib8mat2, only: ldlb,mulbd,muldb,madbb,mulbb
> < use m_kinds, only: i_kind
> < use m_kinds, only: r_kind
> ---
> > use module_pmat2
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> 41,45c6658,6662
> < real(r_kind)  , dimension(n,-m:m)           :: s
> < real(r_kind)  , dimension(n,-m:0)           :: sl
> < real(r_kind)  , dimension(n,-m:m,m)         :: k,l
> < real(r_kind)  , dimension(n)                :: eta
> < real(r_kind)  , dimension(irmax)            :: bcofi,bcofh
> ---
> > real(r_kind), dimension(n,-m:m)             :: s
> > real(r_kind), dimension(n,-m:0)             :: sl
> > real(r_kind), dimension(n,-m:m,m)           :: k,l
> > real(r_kind), dimension(n)                  :: eta
> > real(r_kind), dimension(irmax)              :: bcofi,bcofh
> 150,151c6767,6768
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 216,217c6833,6834
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 230c6847
> <   real(r_kind)                     :: s
> ---
> >   real(r_kind)                   :: s
> 284,285c6901,6902
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 352,353c6969,6970
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 422,423c7039,7040
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 494,495c7111,7112
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 563,564c7180,7181
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 634,635c7251,7252
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 709,710c7326,7327
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 782,783c7399,7400
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 863,864c7480,7481
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 932,933c7549,7550
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 1007,1008c7624,7625
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 1081,1082c7698,7699
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 1146,1147c7763,7764
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 1211,1212c7828,7829
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 1281,1282c7898,7899
> <   use m_kinds, only: i_kind
> <   use m_kinds, only: r_kind
> ---
> >   use kinds, only: i_kind
> >   use kinds, only: r_kind => r_double
> 1353,1354c7970,7971
> < use m_kinds, only: i_kind
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> 1356c7973
> < use m_fitcons
> ---
> > use module_fitcons
> 1367,1370c7984,7987
> < real(r_kind)                                 :: t
> < real(r_kind)   , dimension(-nohm:ng+noh)     :: dcdg
> < real(r_kind)   , dimension(-noh:ng+noh)      :: cofg,cofs
> < real(r_kind)   , dimension(ng)               :: dsdg,dhdg
> ---
> > real(r_kind)                                   :: t
> > real(r_kind)   , dimension(-nohm:ng+noh)       :: dcdg
> > real(r_kind)   , dimension(-noh:ng+noh)        :: cofg,cofs
> > real(r_kind)   , dimension(ng)                 :: dsdg,dhdg
> 1541,1542c8158,8159
> < use m_kinds, only: i_kind
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> 1544c8161
> < use m_fitcons
> ---
> > use module_fitcons
> 1555c8172
> < real(r_kind) , dimension(-noh:ng+noh)                 :: sofg,dsdgt
> ---
> > real(r_kind)   , dimension(-noh:ng+noh)               :: sofg,dsdgt
> 1743,1744c8360,8361
> < use m_kinds, only: i_kind
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> 1800,1801c8417,8418
> < use m_kinds, only: i_kind
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: i_kind
> > use kinds, only: r_kind => r_double
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pmat4.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pmat6.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pmat.f90
> diff -r ./polcarf.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/polcarf.f90
> 1,2c1
> < subroutine polcasl(sl,sl1,sl2,mf,nf,mrr,nrr,nor,rs,df,nxe,nxg,nlat,nlon) !  RT_INTERFACE_CHG
> < !subroutine polcasl(sl,sl1,sl2,mf,nf,mrr,nrr,nor,rs,df,nxe,nxg) !  RT_INTERFACE_CHG
> ---
> > subroutine polcasl(sl,sl1,sl2,mf,nf,mrr,nrr,nor,rs,df,nxe,nxg)
> 30,31c29,30
> <   use m_kinds, only: r_kind,i_kind
> < !_RT  use gridmod, only: nlat,nlon
> ---
> >   use kinds, only: r_kind,i_kind
> >   use gridmod, only: nlat,nlon
> 34d32
> <   integer(i_kind)                      ,intent(in   ) :: nlat,nlon
> 125c123
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 251c249
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 410c408
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 515c513
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 622c620
> <   valp=valp/float(naxr)
> ---
> >   valp=valp/real(naxr,r_kind)
> 662c660
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 697c695
> <   valp=valp/float(naxr)
> ---
> >   valp=valp/real(naxr,r_kind)
> 777c775
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 827c825
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: prad_bias.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: precond.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: precpd_ad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: prewgt.f90
> Only in ./: prewgt.F90
> diff -r ./prewgt_reg.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/prewgt_reg.f90
> 76c76
> <   use m_kinds, only: r_kind,i_kind,r_quad
> ---
> >   use kinds, only: r_kind,i_kind,r_quad
> 81,84c81,82
> <   use m_mpimod, only: nvar_id,levs_id,mpi_sum,gsi_mpi_comm_world,mpi_rtype
> <   !use jfunc, only: varq,qoption,varcw,cwoption
> <   use jfunc, only: qoption,cwoption
> <   use m_berror_stats, only: varq,varcw
> ---
> >   use mpimod, only: nvar_id,levs_id,mpi_sum,mpi_comm_world,mpi_rtype
> >   use jfunc, only: varq,qoption,varcw,cwoption
> 818c816
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 957c955
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: r_kind
> 1351c1349
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: r_kind
> 1745c1743
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: r_kind
> 2139c2137
> < use m_kinds, only: r_kind
> ---
> > use kinds, only: r_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: projmethod_support.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: prt_guess.f90
> diff -r ./psichi2uv_reg.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/psichi2uv_reg.f90
> 43c43
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 185c185
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 338c338
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./psichi2uvt_reg.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/psichi2uvt_reg.f90
> 42c42
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 249c249
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 409c409
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: psort.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pvqc.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: pvqc_tables.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: qcmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: q_diag.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: qnewton3.f90
> diff -r ./radarZ_global_module.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/radarZ_global_module.f90
> 26c26
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: radarZ_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: radarZ_module.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: radiance_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: radinfo.f90
> diff -r ./raflib.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/raflib.f90
> 66,67c66,67
> < use m_kinds,only: r_double,r_quad,r_single,i_byte,i_long,i_llong,i_short
> < use m_mpimod,only: gsi_mpi_comm_world,mpi_integer,mpi_integer1,mpi_integer2,mpi_integer4, &
> ---
> > use kinds,only: r_double,r_quad,r_single,i_byte,i_long,i_llong,i_short
> > use mpimod,only: mpi_comm_world,mpi_integer,mpi_integer1,mpi_integer2,mpi_integer4, &
> 70,71c70
> < !_RT use gsi_io, only: verbose
> < 
> ---
> > use gsi_io, only: verbose
> 179,180d177
> < logical :: verbose=.false.
> < 
> 543,544c540,541
> <      call mpi_gather(yty,1,mpi_real8 ,yty0,1,mpi_real8 ,0,gsi_mpi_comm_world,ierror)
> <      call mpi_gather(xtz,1,mpi_real8 ,xtz0,1,mpi_real8 ,0,gsi_mpi_comm_world,ierror)
> ---
> >      call mpi_gather(yty,1,mpi_real8 ,yty0,1,mpi_real8 ,0,mpi_comm_world,ierror)
> >      call mpi_gather(xtz,1,mpi_real8 ,xtz0,1,mpi_real8 ,0,mpi_comm_world,ierror)
> 546,547c543,544
> <      call mpi_gather(yty,1,mpi_real16,yty0,1,mpi_real16,0,gsi_mpi_comm_world,ierror)
> <      call mpi_gather(xtz,1,mpi_real16,xtz0,1,mpi_real16,0,gsi_mpi_comm_world,ierror)
> ---
> >      call mpi_gather(yty,1,mpi_real16,yty0,1,mpi_real16,0,mpi_comm_world,ierror)
> >      call mpi_gather(xtz,1,mpi_real16,xtz0,1,mpi_real16,0,mpi_comm_world,ierror)
> 1681,1682c1678,1679
> <   call mpi_reduce(aspect_max,aspect_max_all,3*nvars,mpi_real4,mpi_max,0,gsi_mpi_comm_world,ierr)
> <   call mpi_reduce(aspect_min,aspect_min_all,3*nvars,mpi_real4,mpi_min,0,gsi_mpi_comm_world,ierr)
> ---
> >   call mpi_reduce(aspect_max,aspect_max_all,3*nvars,mpi_real4,mpi_max,0,mpi_comm_world,ierr)
> >   call mpi_reduce(aspect_min,aspect_min_all,3*nvars,mpi_real4,mpi_min,0,mpi_comm_world,ierr)
> 1825c1822
> <         call mpi_allreduce(nstrings,nstringsall,1,mpi_integer4,mpi_sum,gsi_mpi_comm_world,ierr)
> ---
> >         call mpi_allreduce(nstrings,nstringsall,1,mpi_integer4,mpi_sum,mpi_comm_world,ierr)
> 1899c1896
> <                            filter(icolor)%npointsmaxall,1,mpi_integer4,mpi_max,gsi_mpi_comm_world,ierr)
> ---
> >                            filter(icolor)%npointsmaxall,1,mpi_integer4,mpi_max,mpi_comm_world,ierr)
> 1997c1994
> <         call mpi_reduce(lenbar,lenbarall(1,icolor),nvars,mpi_real8,mpi_sum,0,gsi_mpi_comm_world,ierr)
> ---
> >         call mpi_reduce(lenbar,lenbarall(1,icolor),nvars,mpi_real8,mpi_sum,0,mpi_comm_world,ierr)
> 1999,2008c1996,2005
> <                      mpi_integer4,mpi_sum,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(lenmax,lenmaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(lenmin,lenminall(1,icolor),nvars,mpi_integer4,mpi_min,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(npoints1,totalpoints1(1,icolor),nvars,mpi_integer4,mpi_sum,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(jumpxmax,jumpxmaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(jumpymax,jumpymaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(jumpzmax,jumpzmaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(jumpxmin,jumpxminall(1,icolor),nvars,mpi_integer4,mpi_min,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(jumpymin,jumpyminall(1,icolor),nvars,mpi_integer4,mpi_min,0,gsi_mpi_comm_world,ierr)
> <         call mpi_reduce(jumpzmin,jumpzminall(1,icolor),nvars,mpi_integer4,mpi_min,0,gsi_mpi_comm_world,ierr)
> ---
> >                      mpi_integer4,mpi_sum,0,mpi_comm_world,ierr)
> >         call mpi_reduce(lenmax,lenmaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,mpi_comm_world,ierr)
> >         call mpi_reduce(lenmin,lenminall(1,icolor),nvars,mpi_integer4,mpi_min,0,mpi_comm_world,ierr)
> >         call mpi_reduce(npoints1,totalpoints1(1,icolor),nvars,mpi_integer4,mpi_sum,0,mpi_comm_world,ierr)
> >         call mpi_reduce(jumpxmax,jumpxmaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,mpi_comm_world,ierr)
> >         call mpi_reduce(jumpymax,jumpymaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,mpi_comm_world,ierr)
> >         call mpi_reduce(jumpzmax,jumpzmaxall(1,icolor),nvars,mpi_integer4,mpi_max,0,mpi_comm_world,ierr)
> >         call mpi_reduce(jumpxmin,jumpxminall(1,icolor),nvars,mpi_integer4,mpi_min,0,mpi_comm_world,ierr)
> >         call mpi_reduce(jumpymin,jumpyminall(1,icolor),nvars,mpi_integer4,mpi_min,0,mpi_comm_world,ierr)
> >         call mpi_reduce(jumpzmin,jumpzminall(1,icolor),nvars,mpi_integer4,mpi_min,0,mpi_comm_world,ierr)
> 2065c2062
> <                         mpi_real4,mpi_sum,0,gsi_mpi_comm_world,ierr)
> ---
> >                         mpi_real4,mpi_sum,0,mpi_comm_world,ierr)
> 2151c2148
> <   call mpi_bcast(flips,2**27-8,mpi_integer1,0,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_bcast(flips,2**27-8,mpi_integer1,0,mpi_comm_world,ierror)
> 2303c2300
> <                      work(1,1,2),filter%nrecv,filter%ndrecv,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                      work(1,1,2),filter%nrecv,filter%ndrecv,mpi_string,mpi_comm_world,ierr)
> 2348c2345
> <                         work(1,1,1),filter%nsend,filter%ndsend,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                         work(1,1,1),filter%nsend,filter%ndsend,mpi_string,mpi_comm_world,ierr)
> 2441c2438
> <                      work(1,1,1,2),filter%nrecv,filter%ndrecv,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                      work(1,1,1,2),filter%nrecv,filter%ndrecv,mpi_string,mpi_comm_world,ierr)
> 2490c2487
> <                        work(1,1,1,1),filter%nsend,filter%ndsend,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                        work(1,1,1,1),filter%nsend,filter%ndsend,mpi_string,mpi_comm_world,ierr)
> 2941c2938
> <          nrecv,1,mpi_integer,gsi_mpi_comm_world,ierr)
> ---
> >          nrecv,1,mpi_integer,mpi_comm_world,ierr)
> 2958c2955
> <                         info_string,nrecv,ndrecv,mpi_string1,gsi_mpi_comm_world,ierr)
> ---
> >                         info_string,nrecv,ndrecv,mpi_string1,mpi_comm_world,ierr)
> 2961c2958
> <                         aspect_full,nrecv,ndrecv,mpi_real4,gsi_mpi_comm_world,ierr)
> ---
> >                         aspect_full,nrecv,ndrecv,mpi_real4,mpi_comm_world,ierr)
> 3088c3085
> <      call mpi_allgather(nstrings,1,mpi_integer4,nrecv,1,mpi_integer4,gsi_mpi_comm_world,ierr)
> ---
> >      call mpi_allgather(nstrings,1,mpi_integer4,nrecv,1,mpi_integer4,mpi_comm_world,ierr)
> 3172c3169
> <      call mpi_allreduce(nrecv,npoints_recv,npes,mpi_integer4,mpi_sum,gsi_mpi_comm_world,ierr)
> ---
> >      call mpi_allreduce(nrecv,npoints_recv,npes,mpi_integer4,mpi_sum,mpi_comm_world,ierr)
> 3232c3229
> < call mpi_gatherv(local1,nlocal1,mpi_integer8,global1,nrecv1,ndrecv1,mpi_integer8,0,gsi_mpi_comm_world,ierr)
> ---
> > call mpi_gatherv(local1,nlocal1,mpi_integer8,global1,nrecv1,ndrecv1,mpi_integer8,0,mpi_comm_world,ierr)
> 3301c3298
> < call mpi_scatterv(global1,nrecv1,ndrecv1,mpi_integer8,local1,nlocal1,mpi_integer8,0,gsi_mpi_comm_world,ierr)
> ---
> > call mpi_scatterv(global1,nrecv1,ndrecv1,mpi_integer8,local1,nlocal1,mpi_integer8,0,mpi_comm_world,ierr)
> 3411c3408
> <   call mpi_allreduce(ijglob_pe0,ijglob_pe,(ide-ids+1)*(jde-jds+1),mpi_integer4,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_allreduce(ijglob_pe0,ijglob_pe,(ide-ids+1)*(jde-jds+1),mpi_integer4,mpi_sum,mpi_comm_world,ierror)
> 3434c3431
> <   call mpi_alltoall(nrecv_halo,1,mpi_integer4,nsend_halo,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_alltoall(nrecv_halo,1,mpi_integer4,nsend_halo,1,mpi_integer4,mpi_comm_world,ierror)
> 3460c3457
> <                      info_send_halo,nsend_halo,ndsend_halo,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_send_halo,nsend_halo,ndsend_halo,mpi_string1,mpi_comm_world,ierror)
> 3556c3553
> <   call mpi_allreduce(ijglob_pe0,ijglob_pe,(ide-ids+1)*(jde-jds+1),mpi_integer4,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_allreduce(ijglob_pe0,ijglob_pe,(ide-ids+1)*(jde-jds+1),mpi_integer4,mpi_sum,mpi_comm_world,ierror)
> 3579c3576
> <   call mpi_alltoall(nrecv_halo,1,mpi_integer4,nsend_halo,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_alltoall(nrecv_halo,1,mpi_integer4,nsend_halo,1,mpi_integer4,mpi_comm_world,ierror)
> 3605c3602
> <                      info_send_halo,nsend_halo,ndsend_halo,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_send_halo,nsend_halo,ndsend_halo,mpi_string1,mpi_comm_world,ierror)
> 3711c3708
> <                      bufrecv,filter%nrecv_halox,filter%ndrecv_halox,mpi_string2,gsi_mpi_comm_world,ierror)
> ---
> >                      bufrecv,filter%nrecv_halox,filter%ndrecv_halox,mpi_string2,mpi_comm_world,ierror)
> 3789c3786
> <                      bufrecv,filter%nrecv_haloy,filter%ndrecv_haloy,mpi_string2,gsi_mpi_comm_world,ierror)
> ---
> >                      bufrecv,filter%nrecv_haloy,filter%ndrecv_haloy,mpi_string2,mpi_comm_world,ierror)
> 3889c3886
> <                      work(1,1,2),filter%nrecv,filter%ndrecv,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                      work(1,1,2),filter%nrecv,filter%ndrecv,mpi_string,mpi_comm_world,ierr)
> 3933c3930
> <                        work(1,1,1),filter%nsend,filter%ndsend,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                        work(1,1,1),filter%nsend,filter%ndsend,mpi_string,mpi_comm_world,ierr)
> 4025c4022
> <                      work(1,1,1,2),filter%nrecv,filter%ndrecv,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                      work(1,1,1,2),filter%nrecv,filter%ndrecv,mpi_string,mpi_comm_world,ierr)
> 4073c4070
> <                        work(1,1,1,1),filter%nsend,filter%ndsend,mpi_string,gsi_mpi_comm_world,ierr)
> ---
> >                        work(1,1,1,1),filter%nsend,filter%ndsend,mpi_string,mpi_comm_world,ierr)
> 4341c4338
> < use m_plib8mat2,only: mulbb,l1lb
> ---
> > use module_pmat2,only: mulbb,l1lb
> 4429c4426
> <       use m_kinds, only: r_kind,i_kind
> ---
> >       use kinds, only: r_kind,i_kind
> 4494c4491
> <          ANRMX=ANORM*RANGE/FLOAT(N)
> ---
> >          ANRMX=ANORM*RANGE/real(N,r_kind)
> 4501c4498
> <             THR=THR/FLOAT(N)
> ---
> >             THR=THR/real(N,r_kind)
> 4654c4651
> < use m_kinds, only: r_kind,i_kind
> ---
> > use kinds, only: r_kind,i_kind
> 4725c4722
> < use m_kinds, only: r_kind,i_kind
> ---
> > use kinds, only: r_kind,i_kind
> 4844c4841
> < use m_kinds, only: i_kind
> ---
> > use kinds, only: i_kind
> 4904c4901
> < use m_kinds, only: i_kind
> ---
> > use kinds, only: i_kind
> 4948c4945
> <   use m_kinds,only: r_single,i_long
> ---
> >   use kinds,only: r_single,i_long
> 5053c5050
> <   use m_kinds,only: r_single,i_long
> ---
> >   use kinds,only: r_single,i_long
> 5102c5099
> <   use m_kinds,only: r_single,i_long
> ---
> >   use kinds,only: r_single,i_long
> 5152c5149
> <   use m_kinds,only: r_single,i_long
> ---
> >   use kinds,only: r_single,i_long
> 5261c5258
> <   use m_kinds,only: r_single,i_long
> ---
> >   use kinds,only: r_single,i_long
> 5367c5364
> <   use m_kinds,only: r_single,r_double,i_long
> ---
> >   use kinds,only: r_single,r_double,i_long
> diff -r ./rapidrefresh_cldsurf_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/rapidrefresh_cldsurf_mod.f90
> 200,223d199
> < !      corp_gust      - namelist real, static BE of gust (standard error deviation)
> < !                          note: 1. initialised to be an arbitary negative value, in order to skip this 
> < !                                   negative value, instead to use value (3.0 m/s) set in subroutine 
> < !                                   berror_read_wgt_reg as default.
> < !                                2. (3drtma only) if a user-specified value (e.g., 2.0 m/s) is preferred 
> < !                                   for corp_gust, in GSI namelist session "rapidrefresh_cldsurf",
> < !                                   set "corp_gust=2.0,"
> < !      hwllp_gust     - namelist real, static BE de-correlation length scale of gust
> < !                          note: 1. initialised to be an arbitary negative value, in order to skip this 
> < !                                   negative value, instead to use value (same value for q) set in
> < !                                   subroutine berror_read_wgt_reg as default
> < !                                2. (3drtma only) if a user-specified value (e.g., 100 km) is preferred 
> < !                                   for hwllp_gust, in GSI namelist session "rapidrefresh_cldsurf",
> < !                                   set "hwllp_gust=100000.0,"
> < !      oerr_gust      - namelist real, observation error of gust
> < !                          note: 1. initialised to be an arbitary negative value, in order to skip this 
> < !                                   negative value, instead to use value (1.0 m/s) set in read_prepbufr.f90
> < !                                2. (3drtma only) if a user-specified value (e.g., 1.5 m/s ) is preferred 
> < !                                   for oerr_gust, in GSI namelist session "rapidrefresh_cldsurf",
> < !                                   set "oerr_gust=1.5,"
> < !      i_gust_3dda    - integer, control the analysis of gust in 3D analysis (either var or hybrid)
> < !                          = 0 (gust-off: default) : no analysis of gust in 3D analysis.
> < !                          = 1 (gust-on) : if variable name "gust" is found in anavinfo,
> < !                                          set it to be 1 to turn on analysis of gust;
> 231c207
> <   use m_kinds, only: r_kind, i_kind
> ---
> >   use kinds, only: r_kind, i_kind
> 297,298d272
> <   public :: corp_gust, hwllp_gust, oerr_gust
> <   public :: i_gust_3dda
> 359,360d332
> <   real(r_kind)      :: corp_gust, hwllp_gust, oerr_gust
> <   integer(i_kind)   :: i_gust_3dda
> 388c360
> <     use m_kinds, only: i_kind 
> ---
> >     use kinds, only: i_kind 
> 390c362
> <     use m_mpimod, only: mype
> ---
> >     use mpimod, only: mype
> 478,493d449
> <     corp_gust           = -1.50_r_kind                ! initialised as negative & void to be skipped, in order to use
> <                                                       ! the value (3.0 m/s) set in sub berror_read_wgt_reg (as default).
> <                                                       ! If user-specified value is preferred, set it in session
> <                                                       ! "rapidrefresh_cldsurf" of GSI namelist file
> < 
> <     hwllp_gust          = -90000.0_r_kind             ! initialised as a value, in order to skip this negative value
> <                                                       ! and to use the value (used for q) set in sub berror_read_wgt_reg.
> <                                                       ! If user-specified value is preferred, set it in session
> <                                                       ! "rapidrefresh_cldsurf" of GSI namelist file
> < 
> <     oerr_gust           = -2.5_r_kind                 ! initialised as a negative value, in order to skip this negative value
> <                                                       ! and to use the value (1.0 m/s) set in read_prepbufr.f90
> <                                                       ! If user-specified value is preferred, set it in session
> <                                                       ! "rapidrefresh_cldsurf" of GSI namelist file
> < 
> <     i_gust_3dda         = 0                           ! no analysis of wind gust (gust) in 3D analysis (default)
> 501,506d456
> <         end if
> <       end if
> <       if ( trim(svars2d(i2))=='gust' .or. trim(svars2d(i2))=='GUST'   ) then
> <         i_gust_3dda = 1
> <         if ( mype == 0 ) then
> <           write(6,'(1x,A,1x,A8,1x,A,1x,I4)')"init_rapidrefresh_cldsurf: anavinfo svars2d (state variable): ",trim(adjustl(svars2d(i2))), " is found in anavinfo, set i_gust_3dda = ", i_gust_3dda
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: rdgrbsst.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_abi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_aerosol.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_ahi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_airs.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_amsr2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_amsre.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_anowbufr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_atms.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_avhrr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_avhrr_navy.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_bufrtovs.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_co.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_cris.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_dbz_nc.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_dbz_netcdf.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_diag.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_fed.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_fl_hdob.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_gfs_ozone_for_regional.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_gmi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_goesglm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_goesimg.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_goesimgr_skycover.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_goesndr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_gps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_guess.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_iasi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_l2bufr_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_lag.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_lidar.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_Lightning.f90
> Only in ./: README
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_mitm_mxtm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_modsbufr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_NASA_LaRC_cloud.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_nasa_larc.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_nsstbufr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_obs.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_ozone.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_pblh.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_pcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_prepbufr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_radar.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_radarref_mosaic_directDA.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_radarref_mosaic.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_radar_wind_ascii.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_rapidscat.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_saphir.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_satmar.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_satwnd.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_seviri.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_sfcwnd.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_ssmi.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_ssmis.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_tcps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_viirs.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: read_wcpbufr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: reorg_metar_cloud.f90
> diff -r ./rfdpar.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/rfdpar.f90
> 46c46
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 74c74
> <      cof(i)=half*cof(i-1)/float(i)
> ---
> >      cof(i)=half*cof(i-1)/real(i,r_kind)
> 157c157
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 242c242
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 301c301
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 342c342
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 447c447
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 507c507
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 549c549
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 633c633
> <   use m_kinds, only: r_kind,i_kind,r_single,r_double
> ---
> >   use kinds, only: r_kind,i_kind,r_single,r_double
> diff -r ./rsearch.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/rsearch.F90
> 60c60
> <   use m_kinds, only: r_kind,r_double,i_kind,i_long
> ---
> >   use kinds, only: r_kind,r_double,i_kind,i_long
> 191c191
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./rtlnmc_version3.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/rtlnmc_version3.f90
> 22c22
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 624c624
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 659c659
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 699c699
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 758c758
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 824c824
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 924c924
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 2817c2817
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> 2846c2846
> <   use m_kinds, only: r_kind,i_kind,r_single
> ---
> >   use kinds, only: r_kind,i_kind,r_single
> 2917c2917
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 2921c2921
> <   use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_sum,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,ierror,mpi_sum,mpi_rtype
> 3054,3055c3054,3055
> <       call mpi_allreduce(bal_a,bal_a0,nvmodes_keep,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> <       call mpi_allreduce(bal_b,bal_b0,nvmodes_keep,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >       call mpi_allreduce(bal_a,bal_a0,nvmodes_keep,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> >       call mpi_allreduce(bal_b,bal_b0,nvmodes_keep,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3132c3132
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3137c3137
> <   use m_mpimod, only: gsi_mpi_comm_world,mpi_sum,mpi_rtype
> ---
> >   use mpimod, only: mpi_comm_world,mpi_sum,mpi_rtype
> 3290,3291c3290,3291
> <            use m_mpimod, only: mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror
> <   use m_kinds, only: r_kind,i_kind
> ---
> >            use mpimod, only: mpi_rtype,mpi_sum,mpi_comm_world,ierror
> >   use kinds, only: r_kind,i_kind
> 3332c3332
> <        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3348c3348
> <        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3376c3376
> <        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3392c3392
> <        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3414,3415c3414,3415
> <            use m_mpimod, only: mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror
> <   use m_kinds, only: r_kind,i_kind
> ---
> >            use mpimod, only: mpi_rtype,mpi_sum,mpi_comm_world,ierror
> >   use kinds, only: r_kind,i_kind
> 3442c3442
> <        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3452c3452
> <        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3472c3472
> <        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(yty,yty0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3482c3482
> <        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >        call mpi_allreduce(xtz,xtz0,1,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> 3501c3501
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3516c3516
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3546c3546
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3597c3597
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3641c3641
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 3742,3743c3742,3743
> <   use m_kinds, only: i_kind,r_kind
> <   use m_mpimod, only: npe
> ---
> >   use kinds, only: i_kind,r_kind
> >   use mpimod, only: npe
> 3809,3810c3809,3810
> <   use m_kinds, only: i_kind,r_kind
> <   use m_mpimod, only: npe
> ---
> >   use kinds, only: i_kind,r_kind
> >   use mpimod, only: npe
> 3870,3871c3870,3871
> <   use m_kinds, only: i_kind,r_kind
> <   use m_mpimod, only: npe
> ---
> >   use kinds, only: i_kind,r_kind
> >   use mpimod, only: npe
> 3930,3931c3930,3931
> <   use m_kinds, only: i_kind,r_kind
> <   use m_mpimod, only: npe
> ---
> >   use kinds, only: i_kind,r_kind
> >   use mpimod, only: npe
> 4030c4030
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe
> ---
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe
> 4032c4032
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4058c4058
> <                 tempa,sendcounts,sdispls,mpi_rtype,gsi_mpi_comm_world,ierror)
> ---
> >                 tempa,sendcounts,sdispls,mpi_rtype,mpi_comm_world,ierror)
> 4072,4073c4072,4073
> <     use m_mpimod, only: npe
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use mpimod, only: npe
> >     use kinds, only: r_kind,i_kind
> 4182c4182
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe
> ---
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe
> 4184c4184
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4220c4220
> <        all_loc,recvcounts,rdispls,mpi_rtype,gsi_mpi_comm_world,ierror)
> ---
> >        all_loc,recvcounts,rdispls,mpi_rtype,mpi_comm_world,ierror)
> 4229c4229
> <   use m_mpimod, only: npe
> ---
> >   use mpimod, only: npe
> 4231c4231
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4302c4302
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4325c4325
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4351c4351
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 4374c4374
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: rtma_comp_fact10.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: satthin.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: set_crtm_aerosolmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: set_crtm_cloudmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupaod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupbend.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupcldch.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupcldtot.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupco.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupdbz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupdbz_lib.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupdw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupfed.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupgust.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuphowv.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuplag.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuplcbas.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuplight.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuplwcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupmitm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupmxtm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupoz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuppblh.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuppcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuppm10.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuppm2_5.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuppmsl.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuppw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupq.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuprad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupref.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuprhsall.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuprw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupspd.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupsst.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupswcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuptcamt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuptcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setuptd2m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupuwnd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupvis.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupvwnd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: setupwspd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sfc_model.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sfcobsqc.f90
> diff -r ./simpin1.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/simpin1.f90
> 48c48
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 396c396
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 510c510
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./simpin1_init.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/simpin1_init.f90
> 32c32
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./smooth_polcarf.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/smooth_polcarf.f90
> 82c82
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 106,107d105
> <   logical, save :: smooth_polcas_set_ = .false.
> < 
> 158,165c156
> <     if(allocated(xwtxys)) deallocate(xwtxys)
> <     if(allocated(ywtxys)) deallocate(ywtxys)
> <     if(allocated(ixwtxys)) deallocate(ixwtxys)
> <     if(allocated(iywtxys)) deallocate(iywtxys)
> <     if(allocated(nxwtxys)) deallocate(nxwtxys)
> <     if(allocated(nywtxys)) deallocate(nywtxys)
> < 
> <     smooth_polcas_set_ = .false.
> ---
> >     deallocate(xwtxys,ywtxys,ixwtxys,iywtxys,nxwtxys,nywtxys)
> 205,206d195
> <   if ( smooth_polcas_set_ ) return
> < 
> 308,309d296
> < 
> <   smooth_polcas_set_ = .true.
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: smoothrf.f90
> Only in ./: smoothrf.F90
> diff -r ./smoothwwrf.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/smoothwwrf.f90
> 30c30
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./smoothzrf.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/smoothzrf.f90
> 35c35
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 336c336
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 405c405
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 543c543
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sparsearr.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sqrtmin.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ssmis_spatial_average_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sst_retrieval.f90
> diff -r ./state_vectors.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/state_vectors.f90
> 48c48
> < use m_kinds, only: r_kind,i_kind,r_single,r_double,r_quad
> ---
> > use kinds, only: r_kind,i_kind,r_single,r_double,r_quad
> 50,53c50,51
> < use m_mpimod, only: mype
> < !use file_utility, only : get_lun
> < use mpeu_util, only: get_lun => luavail
> < use mpeu_util, only: warn
> ---
> > use mpimod, only: mype
> > use file_utility, only : get_lun
> 67,68c65
> < use mpeu_util, only: gettable
> < use mpeu_util, only: perr,die
> ---
> > use mpeu_util, only: gettable,getindex
> 88a86,87
> >   public  qgpresent,qspresent,qrpresent,qipresent,qlpresent
> >   public  cldchpresent,lcbaspresent,howvpresent,wspd10mpresent,pblhpresent,vispresent,gustpresent
> 106a106,107
> > logical qgpresent,qspresent,qrpresent,qipresent,qlpresent
> > logical cldchpresent,lcbaspresent,howvpresent,wspd10mpresent,pblhpresent,vispresent,gustpresent
> 162a164,165
> >   llinit = .true.
> > 
> 171c174
> < subroutine init_anasv(rcname)
> ---
> > subroutine init_anasv
> 173,175c176,177
> < character(len=*),optional,intent(in) :: rcname
> < !character(len=*),parameter:: rcname_def='anavinfo.txt'
> < character(len=*),parameter:: rcname_def='anavinfo'  ! filename should have extension
> ---
> > !character(len=*),parameter:: rcname='anavinfo.txt'
> > character(len=*),parameter:: rcname='anavinfo'  ! filename should have extension
> 183,187d184
> < if(llinit) then
> <   if(mype==0) call warn(myname_,': SV already initialized')
> <   return
> < endif
> < 
> 190,194c187
> < if(present(rcname)) then
> <   open(luin,file=trim(rcname),form='formatted')
> < else
> <   open(luin,file=rcname_def,form='formatted')
> < endif
> ---
> > open(luin,file=rcname,form='formatted')
> 259c252,263
> < llinit = .true.
> ---
> > qgpresent=getindex(svars3d,'qg')>0
> > qspresent=getindex(svars3d,'qs')>0
> > qrpresent=getindex(svars3d,'qr')>0
> > qipresent=getindex(svars3d,'qi')>0
> > qlpresent=getindex(svars3d,'ql')>0
> > cldchpresent=getindex(svars2d,'cldch')>0
> > lcbaspresent=getindex(svars2d,'lcbas')>0
> > howvpresent=getindex(svars2d,'howv')>0
> > wspd10mpresent=getindex(svars2d,'wspd10m')>0
> > pblhpresent=getindex(svars2d,'pblh')>0
> > vispresent=getindex(svars2d,'vis')>0
> > gustpresent=getindex(svars2d,'gust')>0
> 264,270c268,269
> < integer :: istatus
> < character(len=*),parameter :: myname_ = myname//'*final_anasv'
> < deallocate(svars,stat=istatus)
> < if(istatus/=0) call die(myname_)
> < deallocate(svars3d,svars2d,levels,stat=istatus)
> < if(istatus/=0) call die(myname_)
> < llinit = .false.
> ---
> > deallocate(svars)
> > deallocate(svars3d,svars2d,levels)
> 273c272
> < subroutine allocate_state(yst,whocalled)
> ---
> > subroutine allocate_state(yst)
> 297d295
> <   character(len=*), optional, intent(in) :: whocalled
> 300d297
> <   character(len=*), parameter :: myname_ = myname//'*allocate_state'
> 303,305d299
> <   if(ns2d<0.and.ns3d<0) then
> <     call die(myname_,': dims are not good ',ns2d+ns3d)
> <   endif
> 310,312d303
> <   if(ierror/=0) then
> <     call die(myname_,': error from create bundle',ierror)
> <   endif
> 315,319c306
> <      if (present(whocalled)) then
> <      write(6,*) myname_,'>',trim(whocalled),': error length, (ndim,nval_len):', yst%ndim,nval_len,lat2,lon2,nsig
> <      else
> <      write(6,*) myname_,': error length, (ndim,nval_len):', yst%ndim,nval_len,lat2,lon2,nsig
> <      endif
> ---
> >      write(6,*)'allocate_state: error length'
> 394c381
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_rtype,npe
> ---
> >   use mpimod, only: ierror,mpi_comm_world,mpi_rtype,npe
> 402c389
> <   integer(i_kind) :: i,ii
> ---
> >   integer(i_kind) :: i
> 415,416c402,403
> < ! Sum
> <   ii=0
> ---
> > ! Sum,Max,Min and number of points
> > !$omp parallel do schedule(static,1) private(i)
> 418d404
> <      ii=ii+1
> 420c406,408
> <         zloc(ii)= sum_mask(xst%r3(i)%qr4,ihalo=1)
> ---
> >         zloc(i)= sum_mask(xst%r3(i)%qr4,ihalo=1)
> >         zloc(nvars+i)= minval(xst%r3(i)%qr4)
> >         zloc(2*nvars+i)= maxval(xst%r3(i)%qr4)
> 422c410,412
> <         zloc(ii)= sum_mask(xst%r3(i)%q,ihalo=1)
> ---
> >         zloc(i)= sum_mask(xst%r3(i)%q,ihalo=1)
> >         zloc(nvars+i)= minval(xst%r3(i)%q)
> >         zloc(2*nvars+i)= maxval(xst%r3(i)%q)
> 424c414
> <      nloc(ii) = real((lat2-2)*(lon2-2)*levels(i), r_kind) ! dim of 3d fields
> ---
> >      nloc(i) = real((lat2-2)*(lon2-2)*levels(i), r_kind) ! dim of 3d fields
> 425a416
> > !$omp parallel do schedule(static,1) private(i)
> 427d417
> <      ii=ii+1
> 429c419,421
> <         zloc(ii)= sum_mask(xst%r2(i)%qr4,ihalo=1)
> ---
> >         zloc(ns3d+i)= sum_mask(xst%r2(i)%qr4,ihalo=1)
> >         zloc(nvars+ns3d+i)= minval(xst%r2(i)%qr4)
> >         zloc(2*nvars+ns3d+i)= maxval(xst%r2(i)%qr4)
> 431,466c423,425
> <         zloc(ii)= sum_mask(xst%r2(i)%q,ihalo=1)
> <      endif
> <      nloc(ii) = real((lat2-2)*(lon2-2), r_kind)           ! dim of 2d fields
> <   enddo
> < ! Min
> <   do i = 1,ns3d
> <      ii=ii+1
> <      if(xst%r3(i)%mykind==r_single)then
> <         zloc(ii)= minval(xst%r3(i)%qr4)
> <      else
> <         zloc(ii)= minval(xst%r3(i)%q)
> <      endif
> <   enddo
> <   do i = 1,ns2d
> <      ii=ii+1
> <      if(xst%r2(i)%mykind==r_single)then
> <         zloc(ii)= minval(xst%r2(i)%qr4)
> <       else
> <         zloc(ii)= minval(xst%r2(i)%q)
> <      endif
> <   enddo
> < ! Max
> <   do i = 1,ns3d
> <      ii=ii+1
> <      if(xst%r3(i)%mykind==r_single)then
> <         zloc(ii)= maxval(xst%r3(i)%qr4)
> <      else
> <         zloc(ii)= maxval(xst%r3(i)%q)
> <      endif
> <   enddo
> <   do i = 1,ns2d
> <      ii=ii+1
> <      if(xst%r2(i)%mykind==r_single)then
> <         zloc(ii)= maxval(xst%r2(i)%qr4)
> <      else
> <         zloc(ii)= maxval(xst%r2(i)%q)
> ---
> >         zloc(ns3d+i)= sum_mask(xst%r2(i)%q,ihalo=1)
> >         zloc(nvars+ns3d+i)= minval(xst%r2(i)%q)
> >         zloc(2*nvars+ns3d+i)= maxval(xst%r2(i)%q)
> 467a427
> >      nloc(ns3d+i) = real((lat2-2)*(lon2-2), r_kind)           ! dim of 2d fields
> 472c432
> <                    & zall,size(zloc),mpi_rtype, gsi_mpi_comm_world,ierror)
> ---
> >                    & zall,size(zloc),mpi_rtype, mpi_comm_world,ierror)
> 474c434
> <                    & nall,size(nloc),mpi_rtype, gsi_mpi_comm_world,ierror)
> ---
> >                    & nall,size(nloc),mpi_rtype, mpi_comm_world,ierror)
> 476,489c436,441
> <   ii=0
> <   do i=1,ns3d
> <      ii=ii+1
> <      psum(ii)=SUM(zall(ii,:))
> <      pnum(ii)=SUM(nall(ii,:))
> <   enddo
> <   do i=1,ns2d
> <      ii=ii+1
> <      psum(ii)=SUM(zall(ii,:))
> <      pnum(ii)=SUM(nall(ii,:))
> <   enddo
> <   do ii=1,nvars
> <      pmin(ii)=MINVAL(zall(  nvars+ii,:))
> <      pmax(ii)=MAXVAL(zall(2*nvars+ii,:))
> ---
> > !$omp parallel do schedule(static,1) private(i)
> >   do i=1,nvars
> >      psum(i)=SUM(zall(i,:))
> >      pnum(i)=SUM(nall(i,:))
> >      pmin(i)=MINVAL(zall(  nvars+i,:))
> >      pmax(i)=MAXVAL(zall(2*nvars+i,:))
> 605d556
> < !   2020-05-08  Todling - a litte more check on dims
> 620c571
> <   character(len=*),optional, intent(in) :: which  ! variable name
> ---
> >   character(len=*)  ,optional, intent(in) :: which  ! variable name
> 623c574
> <   integer(i_kind) :: i,ii,ipntx,ipnty,irkx,irky,ier,ist,n2d,n3d
> ---
> >   integer(i_kind) :: i,ii,ipntx,ipnty,irkx,irky,ier,ist
> 627,634d577
> <      if(xst%n3d/=yst%n3d .or. xst%n2d/=yst%n2d) then
> <        if(mype==0) &
> <        write(6,*) 'dot_prod_st: improper dims (x,y)', xst%n3d,yst%n3d,xst%n2d,yst%n2d
> <        call stop2(998)
> <      else
> <         n2d=xst%n2d
> <         n3d=xst%n3d
> <      endif
> 637c580
> <      do i = 1,n3d
> ---
> >      do i = 1,ns3d
> 648c591
> <      do i = 1,n2d
> ---
> >      do i = 1,ns2d
> 707a651
> >   use mpeu_util, only: perr,die
> 727a672
> >   use mpeu_util, only: perr,die
> 755a701
> >   use mpeu_util, only: perr,die
> 777a724
> >   use mpeu_util, only: perr,die
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: statsco.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: statsconv.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: statslight.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: statsoz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: statspcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: statsrad.f90
> diff -r ./stop1.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/stop1.f90
> 25,26c25,27
> <   use m_kinds, only: i_kind
> <   use m_mpimod, only: gsi_mpi_comm_world,ierror
> ---
> >   use kinds, only: i_kind
> >   use mpimod, only: mpi_comm_world,ierror,mype
> >   use gsi_io, only: verbose
> 31,33c32,40
> <   write(6,*)'****STOP2****  ABORTING EXECUTION w/code=',ierror_code
> <   write(0,*)'****STOP2****  ABORTING EXECUTION w/code=',ierror_code
> <   call mpi_abort(gsi_mpi_comm_world,ierror_code,ierror)
> ---
> >   if (verbose) then
> >      write(6,*)'****STOP2****  ABORTING EXECUTION w/code=',ierror_code
> >      write(0,*)'****STOP2****  ABORTING EXECUTION w/code=',ierror_code
> >   elseif (mype==0) then
> >      write(6,*)'****STOP2****  ABORTING EXECUTION w/code=',ierror_code
> >      write(0,*)'****STOP2****  ABORTING EXECUTION w/code=',ierror_code
> >   endif
> >      
> >   call mpi_abort(mpi_comm_world,ierror_code,ierror)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpaod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpcalc.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpcldch.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpco.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpdbz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpdw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpfed.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpgps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpgust.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stphowv.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpjcmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpjo.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stplcbas.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stplight.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stplwcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpmitm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpmxtm.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpoz.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stppblh.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stppcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stppm10.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stppm2_5.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stppmsl.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpps.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stppw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpq.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stprad.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stprw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpspd.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpsst.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpswcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stptcamt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stptcp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stptd2m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpt.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpuwnd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpvis.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpvwnd10m.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpw.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stpwspd10m.f90
> diff -r ./strong_bal_correction.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/strong_bal_correction.f90
> 61c61
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 156c156
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> diff -r ./strong_baldiag_inc.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/strong_baldiag_inc.f90
> 40,41c40,41
> <   use m_kinds, only: i_kind,r_kind
> <   use m_mpimod, only: mype
> ---
> >   use kinds, only: i_kind,r_kind
> >   use mpimod, only: mype
> diff -r ./strong_fast_global_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/strong_fast_global_mod.f90
> 46c46
> <   use m_kinds, only: i_kind,r_kind
> ---
> >   use kinds, only: i_kind,r_kind
> 50c50
> <   use m_mpimod, only: ierror,gsi_mpi_comm_world,mpi_integer4,mpi_rtype,mpi_sum,npe
> ---
> >   use mpimod, only: ierror,mpi_comm_world,mpi_integer4,mpi_rtype,mpi_sum,npe
> 104d103
> <   logical, save :: initialized_ = .false.
> 135d133
> <   if(initialized_) return
> 143d140
> <   initialized_ = .true.
> 625c622
> <   call mpi_allgather(mthis,1,mpi_integer4,mthis0,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_allgather(mthis,1,mpi_integer4,mthis0,1,mpi_integer4,mpi_comm_world,ierror)
> 631c628
> <                       indexglob,mthis0,ndisp,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >                       indexglob,mthis0,ndisp,mpi_integer4,mpi_comm_world,ierror)
> 673c670
> <                      work,mthis0,ndisp,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      work,mthis0,ndisp,mpi_string1,mpi_comm_world,ierror)
> 849c846
> <   call mpi_alltoall(nsend_sd2ew,1,mpi_integer4,nrecv_sd2ew,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_alltoall(nsend_sd2ew,1,mpi_integer4,nrecv_sd2ew,1,mpi_integer4,mpi_comm_world,ierror)
> 859c856
> <                      info_recv_sd2ew,nrecv_sd2ew,ndrecv_sd2ew,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_recv_sd2ew,nrecv_sd2ew,ndrecv_sd2ew,mpi_string1,mpi_comm_world,ierror)
> 925c922
> <                      recvbuf,nrecv_sd2ew,ndrecv_sd2ew,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      recvbuf,nrecv_sd2ew,ndrecv_sd2ew,mpi_string1,mpi_comm_world,ierror)
> 1021c1018
> <   call mpi_alltoall(nsend_ew2sd,1,mpi_integer4,nrecv_ew2sd,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_alltoall(nsend_ew2sd,1,mpi_integer4,nrecv_ew2sd,1,mpi_integer4,mpi_comm_world,ierror)
> 1031c1028
> <                      info_recv_ew2sd,nrecv_ew2sd,ndrecv_ew2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_recv_ew2sd,nrecv_ew2sd,ndrecv_ew2sd,mpi_string1,mpi_comm_world,ierror)
> 1094c1091
> <                      recvbuf,nrecv_ew2sd,ndrecv_ew2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      recvbuf,nrecv_ew2sd,ndrecv_ew2sd,mpi_string1,mpi_comm_world,ierror)
> 1628c1625
> <   call mpi_allreduce(ibad,ibad0,1,mpi_integer4,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_allreduce(ibad,ibad0,1,mpi_integer4,mpi_sum,mpi_comm_world,ierror)
> 1635c1632
> <   call mpi_alltoall(nsend,1,mpi_integer4,nrecv,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >   call mpi_alltoall(nsend,1,mpi_integer4,nrecv,1,mpi_integer4,mpi_comm_world,ierror)
> 1645c1642
> <                      info_recv,nrecv,ndrecv,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_recv,nrecv,ndrecv,mpi_string1,mpi_comm_world,ierror)
> 1702c1699
> <                      recvbuf,nrecv,ndrecv,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      recvbuf,nrecv,ndrecv,mpi_string1,mpi_comm_world,ierror)
> 1772c1769
> <                      sendbuf,nsend,ndsend,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      sendbuf,nsend,ndsend,mpi_string1,mpi_comm_world,ierror)
> Only in ./: stub_bacio_mod.F90
> diff -r ./stub_ensmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/stub_ensmod.f90
> 61c61
> <   subroutine get_user_ens(this,grd,member,nymd,nhms,tau,atm_bundle,iret)
> ---
> >   subroutine get_user_ens(this,grd,member,ntindex,atm_bundle,iret)
> 63c63
> <      use m_kinds, only: i_kind
> ---
> >      use kinds, only: i_kind
> 73,74c73
> <      integer(i_kind),     intent(in   ) :: nymd,nhms
> <      integer(i_kind),     intent(in   ) :: tau
> ---
> >      integer(i_kind),     intent(in   ) :: ntindex
> 85c84
> <   subroutine get_user_Nens(this,grd,members,nymd,nhms,tau,atm_bundle,iret)
> ---
> >   subroutine get_user_Nens(this,grd,members,ntindex,atm_bundle,iret)
> 87c86
> <      use m_kinds, only: i_kind
> ---
> >      use kinds, only: i_kind
> 97,98c96
> <      integer(i_kind),     intent(in   ) :: nymd,nhms
> <      integer(i_kind),     intent(in   ) :: tau
> ---
> >      integer(i_kind),     intent(in   ) :: ntindex
> 110c108
> <      use m_kinds, only: i_kind
> ---
> >      use kinds, only: i_kind
> 142c140
> <      use m_kinds, only: i_kind
> ---
> >      use kinds, only: i_kind
> 163c161
> <      use m_kinds, only: r_kind
> ---
> >      use kinds, only: r_kind
> diff -r ./stub_get_pseudo_ensperts.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/stub_get_pseudo_ensperts.f90
> 32c32
> <     use m_kinds, only: i_kind
> ---
> >     use kinds, only: i_kind
> 35c35
> <     type(gsi_bundle),allocatable, intent(in   ) :: en_perts(:,:)
> ---
> >     type(gsi_bundle),allocatable, intent(in   ) :: en_perts(:,:,:)
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_get_wrf_mass_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_get_wrf_nmm_ensperts.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_nstmod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_pertmod.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_read_wrf_mass_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_read_wrf_mass_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_read_wrf_nmm_files.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_read_wrf_nmm_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_regional_io.f90
> Only in ./: stub_sp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_wrf_binary_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_wrf_netcdf_interface.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_wrwrfmassa.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: stub_wrwrfnmma.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sub2fslab_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: sumslightbias.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: support_2dvar.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: tcv_mod.f90
> diff -r ./tendsmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/tendsmod.f90
> 52c52
> <   use m_kinds, only: i_kind,r_kind
> ---
> >   use kinds, only: i_kind,r_kind
> 55,56c55
> <   use m_mpimod, only : mype
> <   use mpeu_util, only: die,warn
> ---
> >   use mpimod, only : mype
> 127c126
> < use mpeu_util, only: get_lun => luavail
> ---
> > use file_utility, only : get_lun
> 313c312
> < subroutine create_ges_tendencies(tendsflag,rcfile)
> ---
> > subroutine create_ges_tendencies(tendsflag)
> 316d314
> <   character(len=*), intent(in) :: rcfile
> 318d315
> <   character(len=*),parameter::myname_=myname//'*create_ges_tendencies'
> 327c324
> <   call set_(rcname=rcfile)
> ---
> >   call set_(rcname='anavinfo')
> 342c339
> <       if(mype==0) call warn(myname_,'no tendency fields requested')
> ---
> >        call stop2(999) ! should never get here
> 344d340
> < ! call GSI_GridDestroy(
> 387a384
> >   use mpimod, only: mpi_comm_world
> 400c397,401
> <   call unset_
> ---
> >   if(allocated(tvars2d))deallocate(tvars2d)
> >   if(allocated(tvars3d))deallocate(tvars3d)
> >   if(allocated(tsrcs2d))deallocate(tsrcs2d)
> >   if(allocated(tsrcs3d))deallocate(tsrcs3d)
> >   if(allocated(levels))deallocate(levels)
> 405,413d405
> < 
> < subroutine unset_
> < if(allocated(tvars2d)) deallocate(tvars2d)
> < if(allocated(tvars3d)) deallocate(tvars3d)
> < if(allocated(tsrcs2d)) deallocate(tsrcs2d)
> < if(allocated(tsrcs3d)) deallocate(tsrcs3d)
> < if(allocated(levels)) deallocate(levels)
> < tnd_set_= .false.
> < end subroutine unset_
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: test_obsens.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: timermod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: tintrp2a.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: tintrp3.f90
> diff -r ./tpause.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/tpause.f90
> 41c41
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 70d69
> <   integer(i_kind) ifound_tv,ifound_vor
> 96,107c95,100
> <   call gsi_bundlegetpointer (gsi_metguess_bundle(nt),'tv',ges_tv_nt,ifound_tv)
> <   if (ifound_tv/=0) then
> <      if (mype==0) then
> <          write(6,*) trim(myname), ': Warning, tv-not avail not t-pause calc'
> <      endif
> <      return
> <   endif
> <   pvoz_capable=ifound_tv==0
> <   call gsi_bundlegetpointer (gsi_metguess_bundle(nt),'oz',ges_oz_nt,ifound_oz)
> <   pvoz_capable=pvoz_capable.and.ifound_oz==0
> <   call gsi_bundlegetpointer (gsi_metguess_bundle(nt),'vor',ges_vor_nt,ifound_vor)
> <   pvoz_capable=pvoz_capable.and.ifound_vor==0
> ---
> >   call gsi_bundlegetpointer (gsi_metguess_bundle(nt),'tv',ges_tv_nt,istatus)
> >   pvoz_capable=istatus==0
> >   call gsi_bundlegetpointer (gsi_metguess_bundle(nt),'oz',ges_oz_nt,istatus)
> >   pvoz_capable=pvoz_capable.and.istatus==0
> >   call gsi_bundlegetpointer (gsi_metguess_bundle(nt),'vor',ges_vor_nt,istatus)
> >   pvoz_capable=pvoz_capable.and.istatus==0
> 113c106
> <               ' identify tropaupose,'
> ---
> >               'identify tropaupose,'
> 116d108
> <          write(6,*) '(tv,oz,vor) = (',ifound_tv,ifound_oz,ifound_vor, ')'
> diff -r ./tpause_t.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/tpause_t.F90
> 37c37
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> Only in ./: tt
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: tune_pbl_height.f90
> diff -r ./turbl_ad.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/turbl_ad.f90
> 41c41
> <   use m_kinds, only: r_kind,i_kind 
> ---
> >   use kinds, only: r_kind,i_kind 
> 43d42
> <   use turblmod, only: use_pbl
> 78,79d76
> < 
> <   if(.not. use_pbl)return
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: turbl.f90
> diff -r ./turblmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/turblmod.f90
> 25c25
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 118,119d117
> <   logical, save :: turbl_initialized_=.false. 
> < 
> 179d176
> <     if(turbl_initialized_) return
> 198d194
> <     turbl_initialized_ = .true.
> 227d222
> <     if(.not. turbl_initialized_)return
> 246d240
> <     turbl_initialized_ = .false.
> diff -r ./turbl_tl.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/turbl_tl.f90
> 38c38
> <   use m_kinds,only: r_kind,i_kind
> ---
> >   use kinds,only: r_kind,i_kind
> 40d39
> <   use turblmod, only: use_pbl
> 73d71
> <   if(.not. use_pbl)return
> diff -r ./tv_to_tsen.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/tv_to_tsen.f90
> 28c28
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 32,33c32
> <   use guess_grids, only: tsensible
> < ! use jfunc, only: tsensible
> ---
> >   use jfunc, only: tsensible
> 95c94
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 99,100c98
> <   use guess_grids, only: tsensible
> < ! use jfunc, only: tsensible
> ---
> >   use jfunc, only: tsensible
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: unfill_mass_grid2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: unfill_nmm_grid2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: unhalf_nmm_grid2.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: update_guess.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: ut_gsibundle.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: vqc_int.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: vqc_setup.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: vqc_stp.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: wind_fft.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: windht.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: wrf_mass_guess_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: wrf_params_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: wrf_vars_mod.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: write_all.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: write_bkgvars_grid.f90
> Only in ./: write_bkgvars_grid.F90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: write_fv3_spread.f90
> Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/: write_incr.f90
> diff -r ./xhat_vordivmod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/xhat_vordivmod.f90
> 27c27
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 44c44
> <   public xhat_vordiv_final
> ---
> >   public xhat_vordiv_clean
> 49c49
> <   interface xhat_vordiv_final; module procedure clean_; end interface
> ---
> >   interface xhat_vordiv_clean; module procedure clean_; end interface
> 78,79c78,81
> <   if(.not.allocated(xhat_vor)) allocate(xhat_vor(lat2,lon2,nsig,nobs_bins))
> <   if(.not.allocated(xhat_div)) allocate(xhat_div(lat2,lon2,nsig,nobs_bins))
> ---
> >   allocate(xhat_vor(lat2,lon2,nsig,nobs_bins))
> >   allocate(xhat_div(lat2,lon2,nsig,nobs_bins))
> >   xhat_vor=zero
> >   xhat_div=zero
> 142c144
> <   real(r_kind),dimension(:,:),allocatable:: usm,vsm
> ---
> >   real(r_kind),dimension(nlat,nlon):: usm,vsm
> 144,145c146
> <   real(r_kind),pointer,dimension(:,:,:):: uptr=>NULL()
> <   real(r_kind),pointer,dimension(:,:,:):: vptr=>NULL()
> ---
> >   real(r_kind),pointer,dimension(:,:,:):: uptr,vptr
> 150,161d150
> < ! Initialize local arrays
> <   do ii=1,nobs_bins
> <      do k=1,nsig
> <         do j=1,lon2
> <            do i=1,lat2
> <               xhat_vor(i,j,k,ii) = zero
> <               xhat_div(i,j,k,ii) = zero
> <            end do
> <         end do
> <      end do
> <   end do
> < 
> 181d169
> <      allocate(usm(nlat,nlon),vsm(nlat,nlon))
> 237d224
> <      deallocate(usm,vsm)
> 281c268
> <   real(r_kind),dimension(:,:),allocatable:: usm,vsm
> ---
> >   real(r_kind),dimension(nlat,nlon):: usm,vsm
> 315d301
> <      allocate(usm(nlat,nlon),vsm(nlat,nlon))
> 361d346
> <      deallocate(usm,vsm)
> diff -r ./zrnmi_mod.f90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/static_BEC/rrfsv1-bec/gsi/zrnmi_mod.f90
> 89c89
> <   use m_kinds, only: r_kind,i_kind
> ---
> >   use kinds, only: r_kind,i_kind
> 281c281
> <   use m_mpimod, only:  npe
> ---
> >   use mpimod, only:  npe
> 364c364
> <     use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mpi_integer4
> ---
> >     use mpimod, only: npe,mpi_comm_world,ierror,mpi_integer4
> 427c427
> <     call mpi_alltoall(nsend_sd2x,1,mpi_integer4,nrecv_sd2x,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_alltoall(nsend_sd2x,1,mpi_integer4,nrecv_sd2x,1,mpi_integer4,mpi_comm_world,ierror)
> 437c437
> <                      info_recv_sd2x,nrecv_sd2x,ndrecv_sd2x,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_recv_sd2x,nrecv_sd2x,ndrecv_sd2x,mpi_string1,mpi_comm_world,ierror)
> 467c467
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 469c469
> <     use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mpi_integer4
> ---
> >     use mpimod, only: npe,mpi_comm_world,ierror,mpi_integer4
> 524c524
> <     call mpi_alltoall(nsend_x2sd,1,mpi_integer4,nrecv_x2sd,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_alltoall(nsend_x2sd,1,mpi_integer4,nrecv_x2sd,1,mpi_integer4,mpi_comm_world,ierror)
> 534c534
> <                        info_recv_x2sd,nrecv_x2sd,ndrecv_x2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        info_recv_x2sd,nrecv_x2sd,ndrecv_x2sd,mpi_string1,mpi_comm_world,ierror)
> 566c566
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 568c568
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 594c594
> <                        recvbuf,nrecv_sd2x,ndrecv_sd2x,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_sd2x,ndrecv_sd2x,mpi_string1,mpi_comm_world,ierror)
> 635c635
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 637c637
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 664c664
> <                        recvbuf,nrecv_sd2x,ndrecv_sd2x,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_sd2x,ndrecv_sd2x,mpi_string1,mpi_comm_world,ierror)
> 706c706
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 708c708
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 731c731
> <                        recvbuf,nrecv_x2sd,ndrecv_x2sd,mpi_rtype,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_x2sd,ndrecv_x2sd,mpi_rtype,mpi_comm_world,ierror)
> 773c773
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 775c775
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 802c802
> <                        recvbuf,nrecv_x2sd,ndrecv_x2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_x2sd,ndrecv_x2sd,mpi_string1,mpi_comm_world,ierror)
> 848c848
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 850c850
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 879c879
> <                        recvbuf,nrecv_x2sd,ndrecv_x2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_x2sd,ndrecv_x2sd,mpi_string1,mpi_comm_world,ierror)
> 933c933
> <   use m_mpimod, only:  npe
> ---
> >   use mpimod, only:  npe
> 1012c1012
> <     use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mpi_integer4
> ---
> >     use mpimod, only: npe,mpi_comm_world,ierror,mpi_integer4
> 1084c1084
> <     call mpi_alltoall(nsend_sd2y,1,mpi_integer4,nrecv_sd2y,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_alltoall(nsend_sd2y,1,mpi_integer4,nrecv_sd2y,1,mpi_integer4,mpi_comm_world,ierror)
> 1094c1094
> <                        info_recv_sd2y,nrecv_sd2y,ndrecv_sd2y,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        info_recv_sd2y,nrecv_sd2y,ndrecv_sd2y,mpi_string1,mpi_comm_world,ierror)
> 1124c1124
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 1126c1126
> <     use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mpi_integer4
> ---
> >     use mpimod, only: npe,mpi_comm_world,ierror,mpi_integer4
> 1181c1181
> <     call mpi_alltoall(nsend_y2sd,1,mpi_integer4,nrecv_y2sd,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_alltoall(nsend_y2sd,1,mpi_integer4,nrecv_y2sd,1,mpi_integer4,mpi_comm_world,ierror)
> 1191c1191
> <                        info_recv_y2sd,nrecv_y2sd,ndrecv_y2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        info_recv_y2sd,nrecv_y2sd,ndrecv_y2sd,mpi_string1,mpi_comm_world,ierror)
> 1225c1225
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 1227c1227
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 1253c1253
> <                        recvbuf,nrecv_sd2y,ndrecv_sd2y,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_sd2y,ndrecv_sd2y,mpi_string1,mpi_comm_world,ierror)
> 1296c1296
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 1298c1298
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 1325c1325
> <                        recvbuf,nrecv_y2sd,ndrecv_y2sd,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_y2sd,ndrecv_y2sd,mpi_string1,mpi_comm_world,ierror)
> 1802c1802
> <     use m_mpimod, only:  npe
> ---
> >     use mpimod, only:  npe
> 1880c1880
> <     use m_mpimod, only: npe,gsi_mpi_comm_world,ierror,mpi_integer4
> ---
> >     use mpimod, only: npe,mpi_comm_world,ierror,mpi_integer4
> 1947c1947
> <     call mpi_alltoall(nsend_x2y,1,mpi_integer4,nrecv_x2y,1,mpi_integer4,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_alltoall(nsend_x2y,1,mpi_integer4,nrecv_x2y,1,mpi_integer4,mpi_comm_world,ierror)
> 1957c1957
> <                      info_recv_x2y,nrecv_x2y,ndrecv_x2y,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                      info_recv_x2y,nrecv_x2y,ndrecv_x2y,mpi_string1,mpi_comm_world,ierror)
> 1991c1991
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 2015c2015
> <                        recvbuf,nrecv_x2y,ndrecv_x2y,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        recvbuf,nrecv_x2y,ndrecv_x2y,mpi_string1,mpi_comm_world,ierror)
> 2059c2059
> <     use m_mpimod, only: gsi_mpi_comm_world,ierror,mpi_rtype
> ---
> >     use mpimod, only: mpi_comm_world,ierror,mpi_rtype
> 2083c2083
> <                        sendbuf,nsend_x2y,ndsend_x2y,mpi_string1,gsi_mpi_comm_world,ierror)
> ---
> >                        sendbuf,nsend_x2y,ndsend_x2y,mpi_string1,mpi_comm_world,ierror)
> 2550c2550
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 2676c2676
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 2736c2736
> <     use m_kinds, only: r_kind,i_kind
> ---
> >     use kinds, only: r_kind,i_kind
> 2799c2799
> <     use m_mpimod,only: mpi_rtype,mpi_integer,mpi_max,mpi_min,mpi_sum,gsi_mpi_comm_world,ierror
> ---
> >     use mpimod,only: mpi_rtype,mpi_integer,mpi_max,mpi_min,mpi_sum,mpi_comm_world,ierror
> 2884,2889c2884,2889
> <     call mpi_allreduce(rlenmax,rlenmax0,nvert,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <     call mpi_allreduce(permax,permax0,nvert,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <     call mpi_allreduce(pmaskmax,pmaskmax0,nvert,mpi_rtype,mpi_max,gsi_mpi_comm_world,ierror)
> <     call mpi_allreduce(pmaskmin,pmaskmin0,nvert,mpi_rtype,mpi_min,gsi_mpi_comm_world,ierror)
> <     call mpi_allreduce(numkeep,numkeep0,nvert,mpi_integer,mpi_sum,gsi_mpi_comm_world,ierror)
> <     call mpi_allreduce(numtot,numtot0,nvert,mpi_integer,mpi_sum,gsi_mpi_comm_world,ierror)
> ---
> >     call mpi_allreduce(rlenmax,rlenmax0,nvert,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> >     call mpi_allreduce(permax,permax0,nvert,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> >     call mpi_allreduce(pmaskmax,pmaskmax0,nvert,mpi_rtype,mpi_max,mpi_comm_world,ierror)
> >     call mpi_allreduce(pmaskmin,pmaskmin0,nvert,mpi_rtype,mpi_min,mpi_comm_world,ierror)
> >     call mpi_allreduce(numkeep,numkeep0,nvert,mpi_integer,mpi_sum,mpi_comm_world,ierror)
> >     call mpi_allreduce(numtot,numtot0,nvert,mpi_integer,mpi_sum,mpi_comm_world,ierror)
> 2951c2951
> <     use m_mpimod,only: mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror
> ---
> >     use mpimod,only: mpi_rtype,mpi_sum,mpi_comm_world,ierror
> 3036,3037c3036,3037
> <        call mpi_allreduce(balagt,balagt0,nvert,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
> <        call mpi_allreduce(baldt,baldt0,nvert,mpi_rtype,mpi_sum,gsi_mpi_comm_world,ierror)
15c22848,22849
< >   !deallocate(coeffx,coeffy)
---
> >        call mpi_allreduce(balagt,balagt0,nvert,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
> >        call mpi_allreduce(baldt,baldt0,nvert,mpi_rtype,mpi_sum,mpi_comm_world,ierror)
diff -r ../../../../../sorc/mpas/.github/CODEOWNERS /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/.github/CODEOWNERS
5c5
< * @jderrico-noaa @clark-evans
---
> * @jderrico-noaa
\ No newline at end of file
diff -r ../../../../../sorc/mpas/.gitmodules /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/.gitmodules
1,12c1,9
< [submodule "src/core_atmosphere/physics/physics_noaa/UGWP"]
< 	path = src/core_atmosphere/physics/physics_noaa/UGWP
< 	url = https://github.com/NOAA-GSL/UGWP
< [submodule "src/core_atmosphere/physics/physics_noaa/TEMPO"]
< 	path = src/core_atmosphere/physics/physics_noaa/TEMPO
< 	url = https://github.com/NCAR/TEMPO
< [submodule "src/core_atmosphere/physics/physics_noaa/MYNN-EDMF"]
< 	path = src/core_atmosphere/physics/physics_noaa/MYNN-EDMF
< 	url = https://github.com/NCAR/MYNN-EDMF
< [submodule "src/core_atmosphere/physics/physics_noaa/RUCLSM"]
< 	path = src/core_atmosphere/physics/physics_noaa/RUCLSM
< 	url = https://github.com/NOAA-GSL/RUCLSM.git
---
> [submodule "src/core_atmosphere/physics/TEMPO"]
> 	path = src/core_atmosphere/physics/TEMPO
> 	url = https://github.com/NCAR/TEMPO.git
> [submodule "src/core_atmosphere/physics/UGWP"]
> 	path = src/core_atmosphere/physics/UGWP
> 	url = https://github.com/mdtoyNOAA/UGWP.git
> [submodule "src/core_atmosphere/physics/MYNN-EDMF"]
> 	path = src/core_atmosphere/physics/MYNN-EDMF
> 	url = https://github.com/NCAR/MYNN-EDMF.git
diff -r ../../../../../sorc/mpas/Makefile /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/Makefile
3,4d2
< 
< 
100,105c98
< 	( PROMOTION=$${FFLAGS_PROMOTION:-"r8"}; \
< 	myFFLAGS=$${FFLAGS_OPT:-"-i4 -gopt -O2 -Mvect=nosse -Kieee -convert big_endian"}; \
< 	myCFLAGS=$${CFLAGS_OPT:-"-fast"}; \
< 	myCXXFLAGS=$${CXXFLAGS_OPT:-"-fast"}; \
< 	myLDFLAGS=$${LDFLAGS_OPT:-""}; \
< 	$(MAKE) all \
---
> 	( $(MAKE) all \
112,116c105,109
< 	"FFLAGS_PROMOTION = $${PROMOTION}" \
< 	"FFLAGS_OPT = $${myFFLAGS}" \
< 	"CFLAGS_OPT = $${myCFLAGS}" \
< 	"CXXFLAGS_OPT = $${myCXXFLAGS}" \
< 	"LDFLAGS_OPT = $${myLDFLAGS}" \
---
> 	"FFLAGS_PROMOTION = -r8" \
> 	"FFLAGS_OPT = -i4 -gopt -O2 -Mvect=nosse -Kieee -convert big_endian" \
> 	"CFLAGS_OPT = -fast" \
> 	"CXXFLAGS_OPT = -fast" \
> 	"LDFLAGS_OPT = " \
415,417c408
< 	( CC_STR=$${CC_SERIAL:-icc}; \
< 	CXX_STR=$${CXX_SERIAL:-icpc}; \
< 	$(MAKE) all \
---
> 	( $(MAKE) all \
422,423c413,414
< 	"CC_SERIAL = $${CC_STR}" \
< 	"CXX_SERIAL = $${CXX_STR}" \
---
> 	"CC_SERIAL = icc" \
> 	"CXX_SERIAL = icpc" \
diff -r ../../../../../sorc/mpas/README.md /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/README.md
1c1
< MPAS-v8.2.3-3.12
---
> MPAS-v8.2.2-2.12
diff -r ../../../../../sorc/mpas/src/core_atmosphere/CMakeLists.txt /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/CMakeLists.txt
87a88
>     module_sf_sfcdiags_ruclsm.F
93a95,96
>     module_ruc_ice.F90
>     module_ruc_land.F90
109c112
< # physics/physics_noaa/UGWP/
---
> # physics/UGWP/
119c122
< list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_UGWP_SOURCES PREPEND physics/physics_noaa/UGWP/)
---
> list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_UGWP_SOURCES PREPEND physics/UGWP/)
121c124
< # physics/physics_noaa/TEMPO/
---
> # physics/TEMPO/
126d128
<     module_mp_tempo_ml.F90
129c131
< list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_TEMPO_SOURCES PREPEND physics/physics_noaa/TEMPO/)
---
> list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_TEMPO_SOURCES PREPEND physics/TEMPO/)
131c133
< # physics/physics_noaa/MYNN-EDMF/
---
> # physics/MYNN-EDMF/
137,145c139
< list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_MYNN-EDMF_SOURCES PREPEND physics/physics_noaa/MYNN-EDMF/)
< 
< # physics/physics_noaa/RUCLSM/
< set(ATMOSPHERE_CORE_PHYSICS_RUCLSM_SOURCES
<     MPAS/module_ruc_land.F90
<     MPAS/module_ruc_ice.F90
<     MPAS/module_sf_sfcdiags_ruclsm.F
< )
< list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_RUCLSM_SOURCES PREPEND physics/physics_noaa/RUCLSM/)
---
> list(TRANSFORM ATMOSPHERE_CORE_PHYSICS_MYNN-EDMF_SOURCES PREPEND physics/MYNN-EDMF/)
399d392
<             ${ATMOSPHERE_CORE_PHYSICS_RUCLSM_SOURCES}
diff -r ../../../../../sorc/mpas/src/core_atmosphere/dynamics/mpas_atm_time_integration.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/dynamics/mpas_atm_time_integration.F
4799c4799
<                   kdiff(k  ,iCell) = max(kdiff(k  ,iCell),visc2cam)
---
>                   kdiff(k  ,iCell) = max(kdiff(nVertLevels  ,iCell),visc2cam)
diff -r ../../../../../sorc/mpas/src/core_atmosphere/mpas_atm_core.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/mpas_atm_core.F
61d60
< 
63c62
<       logical, pointer :: config_do_DAcycling
---
> 
120d118
<       call mpas_pool_get_config(domain % blocklist % configs, 'config_do_DAcycling', config_do_DAcycling)
142,143d139
<       elseif (config_do_DAcycling) then
<          init_stream_name = 'da_state'
165d160
<       call MPAS_stream_mgr_reset_alarms(domain % streamManager, streamID='da_state', direction=MPAS_STREAM_INPUT, ierr=ierr)
384d378
<       use mpas_atmphys_init_tempo
574d567
<          call tempo_ml_init(block % configs)
650,651d642
<       ! Avoid writing a mpasout file at the initial time
<       call MPAS_stream_mgr_reset_alarms(domain % streamManager, streamID='da_state', direction=MPAS_STREAM_OUTPUT, ierr=ierr)
965c956
<       real (kind=RKIND), dimension(:), pointer :: refl10cm_1km_max, max_hail_diameter_sfc_acc
---
>       real (kind=RKIND), dimension(:), pointer :: refl10cm_1km_max
969d959
<       call mpas_pool_get_array(diag_physics, 'max_hail_diameter_sfc_acc', max_hail_diameter_sfc_acc)
972,974d961
<       endif
<       if(associated(max_hail_diameter_sfc_acc)) then
<          max_hail_diameter_sfc_acc(:) = 0.
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/Makefile /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/Makefile
9c9
< 	$(MAKE) lookup_tables core_physics_init core_physics_mmm core_microphysics core_UGWP core_RUCLSM core_mynnedmf core_physics_wrf core_physics_noahmp core_physics
---
> 	$(MAKE) lookup_tables core_physics_init core_physics_mmm core_microphysics core_UGWP core_mynnedmf core_physics_wrf core_physics_noahmp core_physics
67c67
< 	(cd physics_noaa/TEMPO; cp ./drivers/mpas/module_mp_tempo.F90 .; $(MAKE) all COREDEF="$(COREDEF)")
---
> 	(cd TEMPO; cp ./drivers/mpas/module_mp_tempo.F90 .; $(MAKE) all COREDEF="$(COREDEF)")
70c70
< 	(cd physics_noaa/UGWP; $(MAKE) all)
---
> 	(cd UGWP; $(MAKE) all)
73,76c73
< 	(cd physics_noaa/MYNN-EDMF; cp ./MPAS/Makefile .; cp ./MPAS/module_bl_mynnedmf_driver.F90 .; cp ./MPAS/module_bl_mynnedmf_common.F90 .; $(MAKE) all)
< 
< core_RUCLSM: core_physics_init core_physics_mmm
< 	(cd physics_noaa/RUCLSM; cp ./MPAS/Makefile .; cp ./MPAS/module_ruc_land.F90 .; cp ./MPAS/module_ruc_ice.F90 .; cp ./MPAS/module_sf_sfcdiags_ruclsm.F .; $(MAKE) all COREDEF="$(COREDEF)")
---
> 	(cd MYNN-EDMF; cp ./MPAS/Makefile .; cp ./MPAS/module_bl_mynnedmf_driver.F90 .; cp ./MPAS/module_bl_mynnedmf_common.F90 .; $(MAKE) all)
88c85
< core_physics: core_microphysics core_mynnedmf core_RUCLSM core_physics_wrf core_physics_noahmp 
---
> core_physics: core_microphysics core_mynnedmf core_physics_wrf core_physics_noahmp
250a248,252
> mpas_atmphys_driver_seaice.o: \
> 	mpas_atmphys_constants.o \
> 	mpas_atmphys_lsm_shared.o \
> 	mpas_atmphys_vars.o
> 
275,278c277,279
< 	( cd physics_noaa/TEMPO; $(MAKE) clean )
< 	( cd physics_noaa/UGWP; $(MAKE) clean )
< 	( cd physics_noaa/RUCLSM; $(MAKE) -f MPAS/Makefile clean )
< 	( cd physics_noaa/MYNN-EDMF; cp ./MPAS/Makefile .; $(MAKE) clean )
---
> 	( cd TEMPO; $(MAKE) clean )
> 	( cd UGWP; $(MAKE) clean )
> 	( cd MYNN-EDMF; cp ./MPAS/Makefile .; $(MAKE) clean )
287c288
< 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./physics_noahmp -I./physics_noahmp/utility -I./physics_noahmp/drivers/mpas -I./physics_noahmp/src -I./physics_noaa/TEMPO -I./physics_noaa/UGWP -I./physics_noaa/MYNN-EDMF -I./physics_noaa/RUCLSM -I.. -I../../framework -I../../external/esmf_time_f90
---
> 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./physics_noahmp -I./physics_noahmp/utility -I./physics_noahmp/drivers/mpas -I./physics_noahmp/src -I./TEMPO -I./UGWP -I./MYNN-EDMF -I.. -I../../framework -I../../external/esmf_time_f90
289c290
< 	$(FC) $(CPPFLAGS) $(COREDEF) $(HYDROSATIC) $(FFLAGS) -c $*.F $(CPPINCLUDES) $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./physics_noahmp -I./physics_noahmp/utility -I./physics_noahmp/drivers/mpas -I./physics_noahmp/src -I./physics_noaa/TEMPO -I./physics_noaa/UGWP -I./physics_noaa/MYNN-EDMF -I./physics_noaa/RUCLSM -I.. -I../../framework -I../../external/esmf_time_f90
---
> 	$(FC) $(CPPFLAGS) $(COREDEF) $(HYDROSATIC) $(FFLAGS) -c $*.F $(CPPINCLUDES) $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./physics_noahmp -I./physics_noahmp/utility -I./physics_noahmp/drivers/mpas -I./physics_noahmp/src -I./TEMPO -I./UGWP -I./MYNN-EDMF -I.. -I../../framework -I../../external/esmf_time_f90
296c297
< 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./physics_noaa/TEMPO -I./physics_noaa/UGWP -I./physics_noaa/MYNN-EDMF -I./physics_noaa/RUCLSM -I.. -I../../framework -I../../external/esmf_time_f90
---
> 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./TEMPO -I./UGWP -I./MYNN-EDMF -I.. -I../../framework -I../../external/esmf_time_f90
298c299
< 	$(FC) $(CPPFLAGS) $(COREDEF) $(HYDROSATIC) $(FFLAGS) -c $*.F90 $(CPPINCLUDES) $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./physics_noaa/TEMPO -I./physics_noaa/UGWP -I./physics_noaa/MYNN-EDMF -I./physics_noaa/RUCLSM -I.. -I../../framework -I../../external/esmf_time_f90
---
> 	$(FC) $(CPPFLAGS) $(COREDEF) $(HYDROSATIC) $(FFLAGS) -c $*.F90 $(CPPINCLUDES) $(FCINCLUDES) -I./physics_mmm -I./physics_wrf -I./TEMPO -I./UGWP -I./MYNN-EDMF -I.. -I../../framework -I../../external/esmf_time_f90
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_control.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_control.F
286,294d285
<  if(.not. (config_pbl_scheme .eq. 'bl_mynn'     .or.   &
<            config_pbl_scheme .eq. 'bl_mynnedmf') .and. &
<            (config_radt_cld_scheme .eq. 'cld_fraction_mynn')) then
< 
<           write(mpas_err_message,'(A,A20)') 'illegal cloud fraction option for pbl_scheme: ', &
<                 trim(config_pbl_scheme)
<           call physics_error_fatal(mpas_err_message)
< 
<  endif
561c552
<  if (trim(gwdo_scheme) == 'bl_ysu_gwdo') then
---
>  if (trim(gwdo_scheme) /= 'off') then
595c586
<          call mpas_log_write('The YSU GWDO scheme requires valid var2d, con, oa{1,2,3,4}, and ol{1,2,3,4} fields,', &
---
>          call mpas_log_write('The GWDO scheme requires valid var2d, con, oa{1,2,3,4}, and ol{1,2,3,4} fields,', &
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_lsm.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_lsm.F
906d905
<  logical,pointer:: restart, cycling
922,923d920
<  call mpas_pool_get_config(configs,'config_do_restart',restart)
<  call mpas_pool_get_config(configs,'config_do_DAcycling',cycling)
995d991
<                     restart        = restart       , cycling      = cycling     ,                          &
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_microphysics.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_microphysics.F
113c113
<  logical,pointer:: config_tempo_ml_nc_pbl
---
> 
120d119
<  call mpas_pool_get_config(configs,'config_tempo_ml_nc_pbl',config_tempo_ml_nc_pbl)
158d156
<        if(.not.allocated(refl10cm_p)) allocate(refl10cm_p(ims:ime,kms:kme,jms:jme) )
164,184d161
<     microp2_select: select case(trim(microp_scheme))
<        case("mp_thompson","mp_thompson_aerosols")
<           if(.not.allocated(ntc_p)) allocate(ntc_p(ims:ime,jms:jme))
<           if(.not.allocated(muc_p)) allocate(muc_p(ims:ime,jms:jme))
<           if(.not.allocated(ni_p) ) allocate(ni_p(ims:ime,kms:kme,jms:jme))
<           if(.not.allocated(nr_p) ) allocate(nr_p(ims:ime,kms:kme,jms:jme))
< 
<          microp3_select: select case(trim(microp_scheme))
<             case("mp_thompson_aerosols")
<                if(.not.allocated(nifa2d_p)) allocate(nifa2d_p(ims:ime,jms:jme))
<                if(.not.allocated(nwfa2d_p)) allocate(nwfa2d_p(ims:ime,jms:jme))
<                if(.not.allocated(nc_p)    ) allocate(nc_p(ims:ime,kms:kme,jms:jme)  )
<                if(.not.allocated(nifa_p)  ) allocate(nifa_p(ims:ime,kms:kme,jms:jme))
<                if(.not.allocated(nwfa_p)  ) allocate(nwfa_p(ims:ime,kms:kme,jms:jme))
< 
<             case default
<          end select microp3_select
< 
<        case default
<     end select microp2_select
< 
207,208c184,191
<        microp2a_select: select case(trim(microp_scheme))
<         case("mp_tempo")
---
>     microp2_select: select case(trim(microp_scheme))
>        case("mp_thompson","mp_thompson_aerosols")
>           if(.not.allocated(ntc_p)) allocate(ntc_p(ims:ime,jms:jme))
>           if(.not.allocated(muc_p)) allocate(muc_p(ims:ime,jms:jme))
>           if(.not.allocated(ni_p) ) allocate(ni_p(ims:ime,kms:kme,jms:jme))
>           if(.not.allocated(nr_p) ) allocate(nr_p(ims:ime,kms:kme,jms:jme))
> 
>        case("mp_tempo")
216,217d198
<           if(.not.allocated(max_hail_diameter_sfc_p) ) allocate(max_hail_diameter_sfc_p(ims:ime,jms:jme) )
<           if(.not.allocated(max_hail_diameter_column_p) ) allocate(max_hail_diameter_column_p(ims:ime,jms:jme) )
226,230d206
<           if (config_tempo_ml_nc_pbl) then
<              if(.not.allocated(cldfrac_p) ) allocate(cldfrac_p(ims:ime,kms:kme,jms:jme))
<              if(.not.allocated(qcbl_p) ) allocate(qcbl_p(ims:ime,kms:kme,jms:jme))
<           endif
< 
239c215
<         case("mp_nssl2m")
---
>        case("mp_nssl2m")
257a234,241
>           microp3_select: select case(trim(microp_scheme))
>              case("mp_thompson_aerosols")
>                 if(.not.allocated(nifa2d_p)) allocate(nifa2d_p(ims:ime,jms:jme))
>                 if(.not.allocated(nwfa2d_p)) allocate(nwfa2d_p(ims:ime,jms:jme))
>                 if(.not.allocated(nc_p)    ) allocate(nc_p(ims:ime,kms:kme,jms:jme)  )
>                 if(.not.allocated(nifa_p)  ) allocate(nifa_p(ims:ime,kms:kme,jms:jme))
>                 if(.not.allocated(nwfa_p)  ) allocate(nwfa_p(ims:ime,kms:kme,jms:jme))
> 
259c243,246
<     end select microp2a_select
---
>        end select microp3_select
> 
>        case default
>     end select microp2_select
277d263
<  logical,pointer:: config_tempo_ml_nc_pbl
285d270
<  call mpas_pool_get_config(configs,'config_tempo_ml_nc_pbl',config_tempo_ml_nc_pbl)
328,349d312
<     microp2_select: select case(trim(microp_scheme))
<        case("mp_thompson","mp_thompson_aerosols")
<           if(allocated(ntc_p)) deallocate(ntc_p)
<           if(allocated(muc_p)) deallocate(muc_p)
<           if(allocated(ni_p) ) deallocate(ni_p )
<           if(allocated(nr_p) ) deallocate(nr_p )
<           if(allocated(refl10cm_p)  ) deallocate(refl10cm_p  )
< 
<           microp3_select: select case(trim(microp_scheme))
<              case("mp_thompson_aerosols")
<                 if(allocated(nifa2d_p)) deallocate(nifa2d_p)
<                 if(allocated(nwfa2d_p)) deallocate(nwfa2d_p)
<                 if(allocated(nc_p)    ) deallocate(nc_p    )
<                 if(allocated(nifa_p)  ) deallocate(nifa_p  )
<                 if(allocated(nwfa_p)  ) deallocate(nwfa_p  )
< 
<              case default
<           end select microp3_select
< 
<        case default
<     end select microp2_select
< 
372,373c335,342
<        microp2a_select: select case(trim(microp_scheme))
<         case("mp_tempo")
---
>     microp2_select: select case(trim(microp_scheme))
>        case("mp_thompson","mp_thompson_aerosols")
>           if(allocated(ntc_p)) deallocate(ntc_p)
>           if(allocated(muc_p)) deallocate(muc_p)
>           if(allocated(ni_p) ) deallocate(ni_p )
>           if(allocated(nr_p) ) deallocate(nr_p )
> 
>        case("mp_tempo")
381,382d349
<           if(allocated(max_hail_diameter_sfc_p) ) deallocate(max_hail_diameter_sfc_p)
<           if(allocated(max_hail_diameter_column_p) ) deallocate(max_hail_diameter_column_p)
389,393d355
<           if (config_tempo_ml_nc_pbl) then
<              if(allocated(cldfrac_p) ) deallocate(cldfrac_p)
<              if(allocated(qcbl_p) ) deallocate(qcbl_p)
<           endif
< 
402c364
<         case("mp_nssl2m")
---
>        case("mp_nssl2m")
423a386,396
>           microp3_select: select case(trim(microp_scheme))
>              case("mp_thompson_aerosols")
>                 if(allocated(nifa2d_p)) deallocate(nifa2d_p)
>                 if(allocated(nwfa2d_p)) deallocate(nwfa2d_p)
>                 if(allocated(nc_p)    ) deallocate(nc_p    )
>                 if(allocated(nifa_p)  ) deallocate(nifa_p  )
>                 if(allocated(nwfa_p)  ) deallocate(nwfa_p  )
> 
>           case default
>        end select microp3_select
> 
425c398
<     end select microp2a_select
---
>     end select microp2_select
505,506c478,480
<     case default
<  end select microp_select
---
>      case default
> 
>   end select microp_select
644d617
<                         qcbl      = qcbl_p      , cldfrac    = cldfrac_p                                , &
666d638
<                         !! qcbl      = qcbl_p      , cldfrac    = cldfrac_p                                , &
691,693d662
<                      max_hail_diameter_sfc = max_hail_diameter_sfc_p                                 , &
<                      max_hail_diameter_column = max_hail_diameter_column_p                           , &
<                      qcbl      = qcbl_p      , cldfrac    = cldfrac_p                                , &
721c690
<                   ntc       = ntc_p       , muc        = muc_p                                    , &
---
>                   ntc        = ntc_p      , muc        = muc_p                                    , &
726,729c695,698
<        istep = istep + 1
<        enddo
<        call mpas_timer_stop('mp_thompson')
< 
---
>           istep = istep + 1
>           enddo
>           call mpas_timer_stop('mp_thompson')
>           
869,874c838
< 
<  if(trim(microp_scheme) == "mp_tempo") then
<     call mpas_log_write('Computing accumulated max hail diameter at the surface')
<     call compute_accumulated_max_hail(diag_physics,its,ite)
<  endif
< 
---
>  
1293c1257
< 
---
>           
1404,1433d1367
< 
< !=================================================================================================================
<  subroutine compute_accumulated_max_hail(diag_physics,its,ite)
< !=================================================================================================================
< 
< !input arguments:
<  integer,intent(in):: its,ite
< 
< !inout arguments:
<  type(mpas_pool_type),intent(inout):: diag_physics
< 
< !local pointers:
<  real(kind=RKIND),dimension(:),pointer:: max_hail_diameter_sfc, max_hail_diameter_sfc_acc
< 
< !local variables and arrays:
<  integer:: i,j
< 
< !-----------------------------------------------------------------------------------------------------------------
< 
<  call mpas_pool_get_array(diag_physics,'max_hail_diameter_sfc',max_hail_diameter_sfc)
<  call mpas_pool_get_array(diag_physics,'max_hail_diameter_sfc_acc',max_hail_diameter_sfc_acc)
< 
<  do j = jts,jte ! Assuming here that jts == jte (2D arrays)
<     do i = its,ite
<        max_hail_diameter_sfc_acc(i) = max(max_hail_diameter_sfc_acc(i), max_hail_diameter_sfc_p(i,j))
<     enddo
<  enddo
< 
< end subroutine compute_accumulated_max_hail
< 
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_seaice.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_seaice.F
633a634
> 
697d697
<  logical,pointer:: restart, cycling
704,706d703
<  call mpas_pool_get_config(configs,'config_do_restart',restart)
<  call mpas_pool_get_config(configs,'config_do_DAcycling',cycling)
< 
784d780
<                     restart        = restart       , cycling      = cycling     ,                          &
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_sfclayer.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_driver_sfclayer.F
1165d1164
<  logical,pointer:: config_do_DAcycling     
1185,1189c1184,1187
<  call mpas_pool_get_config(configs,'config_do_restart'     ,config_do_restart  )
<  call mpas_pool_get_config(configs,'config_frac_seaice'    ,config_frac_seaice )
<  call mpas_pool_get_config(configs,'config_sfclayer_scheme',sfclayer_scheme    )
<  call mpas_pool_get_config(configs,'config_do_DAcycling'   ,config_do_DAcycling) 
<       
---
>  call mpas_pool_get_config(configs,'config_do_restart'     ,config_do_restart )
>  call mpas_pool_get_config(configs,'config_frac_seaice'    ,config_frac_seaice)
>  call mpas_pool_get_config(configs,'config_sfclayer_scheme',sfclayer_scheme   )
> 
1198c1196
<  if(config_do_restart .or. config_do_DAcycling .or. itimestep > 1) initflag = 0
---
>  if(config_do_restart .or. itimestep > 1) initflag = 0
1418,1421c1416
<                    iz0tlnd  = iz0tlnd                                                    , &
<                    itimestep= itimestep  , initflag  = initflag                          , &
<                    restart  = config_do_restart                                          , &
<                    cycling  = config_do_DAcycling                                        , &
---
>                    iz0tlnd  = iz0tlnd    , itimestep = initflag                          , &
1453,1456c1448
<                       iz0tlnd  = iz0tlnd                                                    , &
<                       itimestep= itimestep  , initflag  = initflag                          , &
<                       restart  = config_do_restart                                          , &
<                       cycling  = config_do_DAcycling                                        , &
---
>                       iz0tlnd  = iz0tlnd    , itimestep = initflag                          , &
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_init.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_init.F
110d109
<                    config_do_DAcycling,  &
148d146
<  real(kind=RKIND),pointer:: knob_ugwp_tauamp
166d163
<  call mpas_pool_get_config(configs,'config_do_DAcycling'     ,config_do_DAcycling     )
313c310
<  if(.not.config_do_restart .and. .not. config_do_DAcycling) then
---
>  if(.not.config_do_restart) then
323c320
<  if(.not. config_do_restart .and. .not. config_do_DAcycling) then
---
>  if(.not. config_do_restart) then
446d442
<        call mpas_pool_get_config(configs,'config_knob_ugwp_tauamp', knob_ugwp_tauamp)
455,456c451,452
<        call ugwpv1_ngw_init(latCell,nVertLevels,config_dt,rdzw,dzu,ntau_d1y,          &
<                knob_ugwp_tauamp,ugwp_taulat,jindx1_tau,jindx2_tau,ddy_j1tau,ddy_j2tau)
---
>        call ugwpv1_ngw_init(latCell,nVertLevels,config_dt,rdzw,dzu,           &
>                ntau_d1y,ugwp_taulat,jindx1_tau,jindx2_tau,ddy_j1tau,ddy_j2tau)
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_init_tempo.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_init_tempo.F
19,25c19,20
<       naCCN1,naCCN0,naIN0,naIN1,nwfa_default,aero_max, &
<       nc_ml_input, nc_ml_nodes, nc_ml_output, &
<       nr_ml_input, nr_ml_nodes, nr_ml_output, &
<       nc_ml_trans_mean, nc_ml_trans_var, &
<       nc_ml_w00, nc_ml_w01, nc_ml_b00, nc_ml_b01
<  use module_mp_tempo_ml, only: MLdata, tempo_save_or_read_ml_data
< 
---
>       naCCN1,naCCN0,naIN0,naIN1,nwfa_default,aero_max
>                               
28c23
<  public:: init_tempo_aerosols_forMPAS, tempo_ml_init
---
>  public:: init_tempo_aerosols_forMPAS
36,110d30
< !=================================================================================================================
<  subroutine tempo_ml_init(configs)
< ! Called once to initial data for tempo_ml
< !=================================================================================================================
< 
< !input arguments:
< type(mpas_pool_type),intent(in):: configs
< 
< !local variables and pointers:
<  type(MLdata), dimension(2) :: tempo_ml_data
<  logical,pointer:: config_tempo_ml_nc_pbl,config_tempo_ml_nc,config_tempo_ml_nr
< 
<  call mpas_pool_get_config(configs, 'config_tempo_ml_nc_pbl', config_tempo_ml_nc_pbl)
<  call mpas_pool_get_config(configs, 'config_tempo_ml_nc', config_tempo_ml_nc)
<  call mpas_pool_get_config(configs, 'config_tempo_ml_nr', config_tempo_ml_nr)
< 
<  if(.not. (config_tempo_ml_nc_pbl .or. config_tempo_ml_nc .or. config_tempo_ml_nr)) then
<     call mpas_log_write('--- All configuration flags for TEMPO ML are false... TEMPO ML will not be used')
<     return
<  endif
< 
<  if(config_tempo_ml_nc .or. config_tempo_ml_nr) then
<     call mpas_log_write('--- TEMPO ML for nc and nr prediction not yet working... These flags will be ignored')
<  endif
< 
<  if(config_tempo_ml_nc_pbl) then
<     call mpas_log_write('--- Using TEMPO ML prediction to give life to the PBL clouds')
<  endif
< 
<  ! Cloud water
<  tempo_ml_data(1)%input_size = nc_ml_input
<  tempo_ml_data(1)%node_size = nc_ml_nodes
<  tempo_ml_data(1)%output_size = nc_ml_output
< 
<  if (.not.allocated(tempo_ml_data(1)%transform_mean)) allocate(tempo_ml_data(1)%transform_mean(nc_ml_input))
<  if (.not.allocated(tempo_ml_data(1)%transform_var)) allocate(tempo_ml_data(1)%transform_var(nc_ml_input))
< 
<  tempo_ml_data(1)%transform_mean = nc_ml_trans_mean
<  tempo_ml_data(1)%transform_var = nc_ml_trans_var
< 
<  if (.not.allocated(tempo_ml_data(1)%weights00)) allocate(tempo_ml_data(1)%weights00(nc_ml_nodes,nc_ml_input))
<  if (.not.allocated(tempo_ml_data(1)%weights01)) allocate(tempo_ml_data(1)%weights01(nc_ml_output,nc_ml_nodes))
<  if (.not.allocated(tempo_ml_data(1)%bias00)) allocate(tempo_ml_data(1)%bias00(nc_ml_nodes))
<  if (.not.allocated(tempo_ml_data(1)%bias01)) allocate(tempo_ml_data(1)%bias01(nc_ml_output))
< 
<  tempo_ml_data(1)%weights00 = reshape(nc_ml_w00, (/nc_ml_nodes, nc_ml_input/))
<  tempo_ml_data(1)%weights01 = reshape(nc_ml_w01, (/nc_ml_output, nc_ml_nodes/))
<  tempo_ml_data(1)%bias00 = nc_ml_b00
<  tempo_ml_data(1)%bias01 = nc_ml_b01
< 
<  ! Rain water
<  tempo_ml_data(2)%input_size = nc_ml_input
<  tempo_ml_data(2)%node_size = nc_ml_nodes
<  tempo_ml_data(2)%output_size = nc_ml_output
< 
<  if (.not.allocated(tempo_ml_data(2)%transform_mean)) allocate(tempo_ml_data(2)%transform_mean(nc_ml_input))
<  if (.not.allocated(tempo_ml_data(2)%transform_var)) allocate(tempo_ml_data(2)%transform_var(nc_ml_input))
< 
<  tempo_ml_data(2)%transform_mean = nc_ml_trans_mean
<  tempo_ml_data(2)%transform_var = nc_ml_trans_var
< 
<  if (.not.allocated(tempo_ml_data(2)%weights00)) allocate(tempo_ml_data(2)%weights00(nc_ml_nodes,nc_ml_input))
<  if (.not.allocated(tempo_ml_data(2)%weights01)) allocate(tempo_ml_data(2)%weights01(nc_ml_output,nc_ml_nodes))
<  if (.not.allocated(tempo_ml_data(2)%bias00)) allocate(tempo_ml_data(2)%bias00(nc_ml_nodes))
<  if (.not.allocated(tempo_ml_data(2)%bias01)) allocate(tempo_ml_data(2)%bias01(nc_ml_output))
< 
<  tempo_ml_data(2)%weights00 = reshape(nc_ml_w00, (/nc_ml_nodes, nc_ml_input/))
<  tempo_ml_data(2)%weights01 = reshape(nc_ml_w01, (/nc_ml_output, nc_ml_nodes/))
<  tempo_ml_data(2)%bias00 = nc_ml_b00
<  tempo_ml_data(2)%bias01 = nc_ml_b01
< 
<  ! Save neural network
<  call tempo_save_or_read_ml_data(ml_data_in=tempo_ml_data)
< 
<  end subroutine tempo_ml_init
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_interface.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_interface.F
39c39
< ! * in subroutine MPAS_to_physics, moved the calculation of the local arrays qv_p,qc_p, and qr_p above the 
---
> ! * in subroutine MPAS_to_physics, moved the calculation of the local arrays qv_p,qc_p, and qr_p above the
41c41
< ! * in subroutine microphysics_from_MPAS, moved the calculation of the local arrays qv_p,qc_p, and qr_p above 
---
> ! * in subroutine microphysics_from_MPAS, moved the calculation of the local arrays qv_p,qc_p, and qr_p above
53c53
< ! * added calculation of the surface pressure tendency. Moved the calculation of znu_p below the calculation 
---
> ! * added calculation of the surface pressure tendency. Moved the calculation of znu_p below the calculation
55c55
< !   Laura D. Fowler (birch.mmm.ucar.ecu) / 2014-06-23. 
---
> !   Laura D. Fowler (birch.mmm.ucar.ecu) / 2014-06-23.
58c58
< ! * in subroutine microphysics_to_MPAS, reverted the calculation of cloud microphysics tendency rt_diabatic_tend, 
---
> ! * in subroutine microphysics_to_MPAS, reverted the calculation of cloud microphysics tendency rt_diabatic_tend,
61c61
< !   Laura D. Fowler (laura@ucar.edu) / 2014-01-015. 
---
> !   Laura D. Fowler (laura@ucar.edu) / 2014-01-015.
112c112
<  
---
> 
158c158
<  
---
> 
194,195c194,195
<  if(allocated(rho_p)   ) deallocate(rho_p   ) 
<  if(allocated(rh_p)    ) deallocate(rh_p    ) 
---
>  if(allocated(rho_p)   ) deallocate(rho_p   )
>  if(allocated(rh_p)    ) deallocate(rh_p    )
246c246
<  
---
> 
521c521
<  
---
> 
579c579
<     z1 = 0.5*(zgrid(k,i)+zgrid(k-1,i)) 
---
>     z1 = 0.5*(zgrid(k,i)+zgrid(k-1,i))
595c595
<     z1 = 0.5*(zgrid(k,i)+zgrid(k+1,i)) 
---
>     z1 = 0.5*(zgrid(k,i)+zgrid(k+1,i))
628c628
<        znu_hyd_p(i,k,j) = pres_hyd_p(i,k,j) / psfc_hyd_p(i,j) 
---
>        znu_hyd_p(i,k,j) = pres_hyd_p(i,k,j) / psfc_hyd_p(i,j)
636c636
<     plrad(i) = pres2_p(i,kte+1,j) 
---
>     plrad(i) = pres2_p(i,kte+1,j)
667d666
<  logical,pointer:: config_tempo_ml_nc_pbl
676,679c675,676
<  real(kind=RKIND),dimension(:,:),pointer  :: qv,qc,qr,qi,qs,qg
<  real(kind=RKIND),dimension(:,:),pointer  :: qh
<  real(kind=RKIND),dimension(:,:),pointer  :: nc,ni,nr,nifa,nwfa
<  real(kind=RKIND),dimension(:,:),pointer  :: ns,ng,nh,nccn
---
>  real(kind=RKIND),dimension(:,:),pointer  :: qv,qc,qr,qi,qs,qg,qh
>  real(kind=RKIND),dimension(:,:),pointer  :: ni,nr,nc,ns,ng,nh,nccn,nwfa,nifa
681,683c678
<  real(kind=RKIND),dimension(:,:),pointer  :: rainprod,evapprod
<  real(kind=RKIND),dimension(:,:),pointer  :: refl10cm
<  real(kind=RKIND),dimension(:)  ,pointer  :: max_hail_diameter_sfc, max_hail_diameter_column
---
>  real(kind=RKIND),dimension(:,:),pointer  :: rainprod,evapprod,refl10cm
685d679
<  real(kind=RKIND),dimension(:,:),pointer  :: qc_bl, cldfrac_bl
699d692
<  call mpas_pool_get_config(configs,'config_tempo_ml_nc_pbl',config_tempo_ml_nc_pbl)
712,714c705,708
<  call mpas_pool_get_dimension(state,'index_qv',index_qv)
<  call mpas_pool_get_dimension(state,'index_qc',index_qc)
<  call mpas_pool_get_dimension(state,'index_qr',index_qr)
---
>  call mpas_pool_get_dimension(state,'index_qv'  ,index_qv  )
>  call mpas_pool_get_dimension(state,'index_qc'  ,index_qc  )
>  call mpas_pool_get_dimension(state,'index_qr'  ,index_qr  )
> 
756d749
<        call mpas_pool_get_array(diag_physics,'refl10cm',refl10cm)
766c759
<           evapprod_p(i,k,j) = evapprod(k,i)
---
>           evapprod_p(i,k,j) = evapprod(k,k)
770d762
<           refl10cm_p(i,k,j) = refl10cm(k,i)
775,827d766
<        mp2_select: select case(trim(mp_scheme))
<           case("mp_thompson","mp_thompson_aerosols")
<              call mpas_pool_get_dimension(state,'index_ni',index_ni)
<              call mpas_pool_get_dimension(state,'index_nr',index_nr)
<              ni   => scalars(index_ni,:,:)
<              nr   => scalars(index_nr,:,:)
< 
<              call mpas_pool_get_array(diag_physics,'nt_c',nt_c)
<              call mpas_pool_get_array(diag_physics,'mu_c',mu_c)
<              do j = jts,jte
<              do i = its,ite
<                 muc_p(i,j) = mu_c(i)
<                 ntc_p(i,j) = nt_c(i)
<              enddo
<              do k = kts, kte
<              do i = its, ite
<                 ni_p(i,k,j) = ni(k,i)
<                 nr_p(i,k,j) = nr(k,i)
<              enddo
<              enddo
<              enddo
< 
<           mp3_select: select case(trim(mp_scheme))
<              case("mp_thompson_aerosols")
<                 call mpas_pool_get_dimension(state,'index_nc'  ,index_nc  )
<                 call mpas_pool_get_dimension(state,'index_nifa',index_nifa)
<                 call mpas_pool_get_dimension(state,'index_nwfa',index_nwfa)
<                 nc   => scalars(index_nc,:,:)
<                 nifa => scalars(index_nifa,:,:)
<                 nwfa => scalars(index_nwfa,:,:)
< 
<                 call mpas_pool_get_array(diag_physics,'nifa2d',nifa2d)
<                 call mpas_pool_get_array(diag_physics,'nwfa2d',nwfa2d)
<                 do j = jts,jte
<                 do i = its,ite
<                    nifa2d_p(i,j) = nifa2d(i)
<                    nwfa2d_p(i,j) = nwfa2d(i)
<                 enddo
<                 do k = kts, kte
<                 do i = its, ite
<                    nc_p(i,k,j) = nc(k,i)
<                    nifa_p(i,k,j) = nifa(k,i)
<                    nwfa_p(i,k,j) = nwfa(k,i)
<                 enddo
<                 enddo
<                 enddo
< 
<              case default
<           end select mp3_select
< 
<           case default
<        end select mp2_select
< 
851c790
<           evapprod_p(i,k,j) = evapprod(k,i)
---
>           evapprod_p(i,k,j) = evapprod(k,k)
860,861c799,800
<        mp2a_select: select case(trim(mp_scheme))
<           case("mp_tempo")
---
>        mp2_select: select case(trim(mp_scheme))
>           case("mp_thompson","mp_thompson_aerosols")
864,865d802
<              call mpas_pool_get_array(diag_physics,'max_hail_diameter_sfc' ,max_hail_diameter_sfc)
<              call mpas_pool_get_array(diag_physics,'max_hail_diameter_column' ,max_hail_diameter_column)
867a805,807
> 
>              call mpas_pool_get_array(diag_physics,'nt_c',nt_c)
>              call mpas_pool_get_array(diag_physics,'mu_c',mu_c)
870,871c810,817
<                 max_hail_diameter_sfc_p(i,j) = max_hail_diameter_sfc(i)
<                 max_hail_diameter_column_p(i,j) = max_hail_diameter_column(i)
---
>                 muc_p(i,j) = mu_c(i)
>                 ntc_p(i,j) = nt_c(i)
>              enddo
>              do k = kts, kte
>              do i = its, ite
>                 ni_p(i,k,j) = ni(k,i)
>                 nr_p(i,k,j) = nr(k,i)
>              enddo
874a821,826
>           case("mp_tempo")
>              call mpas_pool_get_dimension(state,'index_ni',index_ni)
>              call mpas_pool_get_dimension(state,'index_nr',index_nr)
>              ni   => scalars(index_ni,:,:)
>              nr   => scalars(index_nr,:,:)
> 
891,903d842
<              if(config_tempo_ml_nc_pbl) then
<                 call mpas_pool_get_array(diag_physics,'qc_bl',qc_bl)
<                 call mpas_pool_get_array(diag_physics,'cldfrac_bl',cldfrac_bl)
<                 do j = jts, jte
<                 do k = kts, kte
<                 do i = its, ite
<                    qcbl_p(i,k,j) = qc_bl(k,i)
<                    cldfrac_p(i,k,j) = cldfrac_bl(k,i)
<                 enddo
<                 enddo
<                 enddo
<              endif
< 
1005a945,972
>           mp3_select: select case(trim(mp_scheme))
>              case("mp_thompson_aerosols")
>                 call mpas_pool_get_dimension(state,'index_nc'  ,index_nc  )
>                 call mpas_pool_get_dimension(state,'index_nifa',index_nifa)
>                 call mpas_pool_get_dimension(state,'index_nwfa',index_nwfa)
>                 nc   => scalars(index_nc,:,:)
>                 nifa => scalars(index_nifa,:,:)
>                 nwfa => scalars(index_nwfa,:,:)
> 
>                 call mpas_pool_get_array(diag_physics,'nifa2d',nifa2d)
>                 call mpas_pool_get_array(diag_physics,'nwfa2d',nwfa2d)
>                 do j = jts,jte
>                 do i = its,ite
>                    nifa2d_p(i,j) = nifa2d(i)
>                    nwfa2d_p(i,j) = nwfa2d(i)
>                 enddo
>                 do k = kts, kte
>                 do i = its, ite
>                    nc_p(i,k,j) = nc(k,i)
>                    nifa_p(i,k,j) = nifa(k,i)
>                    nwfa_p(i,k,j) = nwfa(k,i)
>                 enddo
>                 enddo
>                 enddo
> 
>              case default
>           end select mp3_select
> 
1007c974
<        end select mp2a_select
---
>        end select mp2_select
1034a1002,1022
>     case("mp_tempo","mp_nssl2m")
>        call mpas_pool_get_array(tend_physics,'rthmpten',rthmpten)
>        call mpas_pool_get_array(tend_physics,'rqvmpten',rqvmpten)
>        call mpas_pool_get_array(tend_physics,'rqcmpten',rqcmpten)
>        call mpas_pool_get_array(tend_physics,'rqrmpten',rqrmpten)
>        call mpas_pool_get_array(tend_physics,'rqimpten',rqimpten)
>        call mpas_pool_get_array(tend_physics,'rqsmpten',rqsmpten)
>        call mpas_pool_get_array(tend_physics,'rqgmpten',rqgmpten)
> 
>        do k = kts,kte
>        do i = its,ite
>           rthmpten(k,i) = theta_m(k,i)/(1._RKIND+R_v/R_d*max(0._RKIND,qv(k,i)))
>           rqvmpten(k,i) = qv(k,i)
>           rqcmpten(k,i) = qc(k,i)
>           rqrmpten(k,i) = qr(k,i)
>           rqimpten(k,i) = qi(k,i)
>           rqsmpten(k,i) = qs(k,i)
>           rqgmpten(k,i) = qg(k,i)
>        enddo
>        enddo
> 
1046a1035,1045
>           case("mp_tempo","mp_nssl2m")
>              call mpas_pool_get_array(tend_physics,'rnimpten',rnimpten)
>              call mpas_pool_get_array(tend_physics,'rnrmpten',rnrmpten)
> 
>              do k = kts,kte
>              do i = its,ite
>                 rnimpten(k,i) = ni(k,i)
>                 rnrmpten(k,i) = nr(k,i)
>              enddo
>              enddo
> 
1061,1103c1060,1073
<                 case default
<              end select mp3_tend_select
< 
<           case default
<        end select mp2_tend_select
< 
<     case("mp_tempo","mp_nssl2m")
<        call mpas_pool_get_array(tend_physics,'rthmpten',rthmpten)
<        call mpas_pool_get_array(tend_physics,'rqvmpten',rqvmpten)
<        call mpas_pool_get_array(tend_physics,'rqcmpten',rqcmpten)
<        call mpas_pool_get_array(tend_physics,'rqrmpten',rqrmpten)
<        call mpas_pool_get_array(tend_physics,'rqimpten',rqimpten)
<        call mpas_pool_get_array(tend_physics,'rqsmpten',rqsmpten)
<        call mpas_pool_get_array(tend_physics,'rqgmpten',rqgmpten)
< 
<        do k = kts,kte
<        do i = its,ite
<           rthmpten(k,i) = theta_m(k,i)/(1._RKIND+R_v/R_d*max(0._RKIND,qv(k,i)))
<           rqvmpten(k,i) = qv(k,i)
<           rqcmpten(k,i) = qc(k,i)
<           rqrmpten(k,i) = qr(k,i)
<           rqimpten(k,i) = qi(k,i)
<           rqsmpten(k,i) = qs(k,i)
<           rqgmpten(k,i) = qg(k,i)
<        enddo
<        enddo
< 
<        call mpas_pool_get_array(tend_physics,'rnimpten',rnimpten)
<        call mpas_pool_get_array(tend_physics,'rnrmpten',rnrmpten)
< 
<        do k = kts,kte
<        do i = its,ite
<           rnimpten(k,i) = ni(k,i)
<           rnrmpten(k,i) = nr(k,i)
<        enddo
<        enddo
< 
<        mp2a_tend_select: select case(trim(mp_scheme))
<           case("mp_tempo")
<              if(config_tempo_aerosolaware) then
<                 call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
<                 call mpas_pool_get_array(tend_physics,'rnifampten',rnifampten)
<                 call mpas_pool_get_array(tend_physics,'rnwfampten',rnwfampten)
---
>                 case("mp_tempo")
>                    if(config_tempo_aerosolaware) then
>                       call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
>                       call mpas_pool_get_array(tend_physics,'rnifampten',rnifampten)
>                       call mpas_pool_get_array(tend_physics,'rnwfampten',rnwfampten)
> 
>                       do k = kts,kte
>                       do i = its,ite
>                          rncmpten(k,i) = nc(k,i)
>                          rnifampten(k,i) = nifa(k,i)
>                          rnwfampten(k,i) = nwfa(k,i)
>                       enddo
>                       enddo
>                    endif
1105,1112c1075,1076
<                 do k = kts,kte
<                 do i = its,ite
<                    rncmpten(k,i) = nc(k,i)
<                    rnifampten(k,i) = nifa(k,i)
<                    rnwfampten(k,i) = nwfa(k,i)
<                 enddo
<                 enddo
<              endif
---
>                 case("mp_nssl2m")
>                    call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
1114,1115c1078,1082
<            case("mp_nssl2m")
<              call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
---
>                    do k = kts,kte
>                    do i = its,ite
>                       rncmpten(k,i) = nc(k,i)
>                    enddo
>                    enddo
1117,1121c1084,1085
<              do k = kts,kte
<              do i = its,ite
<                 rncmpten(k,i) = nc(k,i)
<              enddo
<              enddo
---
>                 case default
>              end select mp3_tend_select
1124c1088
<        end select mp2a_tend_select
---
>        end select mp2_tend_select
1169,1172c1133,1134
<  real(kind=RKIND),dimension(:,:),pointer  :: qv,qc,qr,qi,qs,qg
<  real(kind=RKIND),dimension(:,:),pointer  :: qh
<  real(kind=RKIND),dimension(:,:),pointer  :: nc,ni,nr,nifa,nwfa
<  real(kind=RKIND),dimension(:,:),pointer  :: ns,ng,nh,nccn
---
>  real(kind=RKIND),dimension(:,:),pointer  :: qv,qc,qr,qi,qs,qg,qh
>  real(kind=RKIND),dimension(:,:),pointer  :: ni,nr,nc,ns,ng,nh,nccn,nwfa,nifa
1174,1176c1136
<  real(kind=RKIND),dimension(:,:),pointer  :: rainprod,evapprod
<  real(kind=RKIND),dimension(:,:),pointer  :: refl10cm
<  real(kind=RKIND),dimension(:)  ,pointer  :: max_hail_diameter_sfc, max_hail_diameter_column
---
>  real(kind=RKIND),dimension(:,:),pointer  :: rainprod,evapprod,refl10cm
1306,1352d1265
<        mp2_select: select case(trim(mp_scheme))
<           case("mp_thompson","mp_thompson_aerosols")
<              call mpas_pool_get_dimension(state,'index_ni',index_ni)
<              call mpas_pool_get_dimension(state,'index_nr',index_nr)
<              ni   => scalars(index_ni,:,:)
<              nr   => scalars(index_nr,:,:)
< 
<              do j = jts,jte
<              do k = kts,kte
<              do i = its,ite
<                 ni(k,i) = ni_p(i,k,j)
<                 nr(k,i) = nr_p(i,k,j)
<              enddo
<              enddo
<              enddo
< 
<              mp3_select: select case(trim(mp_scheme))
<                 case("mp_thompson_aerosols")
<                    call mpas_pool_get_dimension(state,'index_nc'  ,index_nc  )
<                    call mpas_pool_get_dimension(state,'index_nifa',index_nifa)
<                    call mpas_pool_get_dimension(state,'index_nwfa',index_nwfa)
<                    nc   => scalars(index_nc,:,:)
<                    nifa => scalars(index_nifa,:,:)
<                    nwfa => scalars(index_nwfa,:,:)
< 
<                    call mpas_pool_get_array(diag_physics,'nifa2d',nifa2d)
<                    call mpas_pool_get_array(diag_physics,'nwfa2d',nwfa2d)
<                    do j = jts,jte
<                    do i = its,ite
<                       nifa2d(i) = nifa2d_p(i,j)
<                       nwfa2d(i) = nwfa2d_p(i,j)
<                    enddo
<                    do k = kts, kte
<                    do i = its, ite
<                       nc(k,i)   = nc_p(i,k,j)
<                       nifa(k,i) = nifa_p(i,k,j)
<                       nwfa(k,i) = nwfa_p(i,k,j)
<                    enddo
<                    enddo
<                    enddo
< 
<                 case default
<              end select mp3_select
< 
<           case default
<        end select mp2_select
< 
1385,1386c1298,1299
<        mp2a_select: select case(trim(mp_scheme))
<           case("mp_tempo")
---
>        mp2_select: select case(trim(mp_scheme))
>           case("mp_thompson","mp_thompson_aerosols")
1401,1402c1314,1319
<              call mpas_pool_get_array(diag_physics,'max_hail_diameter_sfc' ,max_hail_diameter_sfc)
<              call mpas_pool_get_array(diag_physics,'max_hail_diameter_column' ,max_hail_diameter_column)
---
>           case("mp_tempo")
>              call mpas_pool_get_dimension(state,'index_ni',index_ni)
>              call mpas_pool_get_dimension(state,'index_nr',index_nr)
>              ni   => scalars(index_ni,:,:)
>              nr   => scalars(index_nr,:,:)
> 
1403a1321
>              do k = kts,kte
1405,1406c1323,1325
<                 max_hail_diameter_sfc(i) = max_hail_diameter_sfc_p(i,j)
<                 max_hail_diameter_column(i) = max_hail_diameter_column_p(i,j)
---
>                 ni(k,i) = ni_p(i,k,j)
>                 nr(k,i) = nr_p(i,k,j)
>              enddo
1510a1430,1457
>              mp3_select: select case(trim(mp_scheme))
>                 case("mp_thompson_aerosols")
>                    call mpas_pool_get_dimension(state,'index_nc'  ,index_nc  )
>                    call mpas_pool_get_dimension(state,'index_nifa',index_nifa)
>                    call mpas_pool_get_dimension(state,'index_nwfa',index_nwfa)
>                    nc   => scalars(index_nc,:,:)
>                    nifa => scalars(index_nifa,:,:)
>                    nwfa => scalars(index_nwfa,:,:)
> 
>                    call mpas_pool_get_array(diag_physics,'nifa2d',nifa2d)
>                    call mpas_pool_get_array(diag_physics,'nwfa2d',nwfa2d)
>                    do j = jts,jte
>                    do i = its,ite
>                       nifa2d(i) = nifa2d_p(i,j)
>                       nwfa2d(i) = nwfa2d_p(i,j)
>                    enddo
>                    do k = kts, kte
>                    do i = its, ite
>                       nc(k,i)   = nc_p(i,k,j)
>                       nifa(k,i) = nifa_p(i,k,j)
>                       nwfa(k,i) = nwfa_p(i,k,j)
>                    enddo
>                    enddo
>                    enddo
> 
>                 case default
>              end select mp3_select
> 
1512c1459
<        end select mp2a_select
---
>        end select mp2_select
1540,1571d1486
<        mp2_tend_select: select case(trim(mp_scheme))
<           case("mp_thompson","mp_thompson_aerosols")
<              call mpas_pool_get_array(tend_physics,'rnimpten',rnimpten)
<              call mpas_pool_get_array(tend_physics,'rnrmpten',rnrmpten)
< 
<              do k = kts,kte
<              do i = its,ite
<                 rnimpten(k,i) = (ni(k,i)-rnimpten(k,i))/dt_dyn
<                 rnrmpten(k,i) = (nr(k,i)-rnrmpten(k,i))/dt_dyn
<              enddo
<              enddo
< 
<              mp3_tend_select: select case(trim(mp_scheme))
<                 case("mp_thompson_aerosols")
<                    call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
<                    call mpas_pool_get_array(tend_physics,'rnifampten',rnifampten)
<                    call mpas_pool_get_array(tend_physics,'rnwfampten',rnwfampten)
< 
<                    do k = kts,kte
<                    do i = its,ite
<                       rncmpten(k,i)   = (nc(k,i)-rncmpten(k,i))/dt_dyn
<                       rnifampten(k,i) = (nifa(k,i)-rnifampten(k,i))/dt_dyn
<                       rnwfampten(k,i) = (nwfa(k,i)-rnwfampten(k,i))/dt_dyn
<                    enddo
<                    enddo
< 
<                 case default
<              end select mp3_tend_select
< 
<           case default
<        end select mp2_tend_select
< 
1593c1508,1519
<        mp2a_tend_select: select case(trim(mp_scheme))
---
>        mp2_tend_select: select case(trim(mp_scheme))
>           case("mp_thompson","mp_thompson_aerosols")
>              call mpas_pool_get_array(tend_physics,'rnimpten',rnimpten)
>              call mpas_pool_get_array(tend_physics,'rnrmpten',rnrmpten)
> 
>              do k = kts,kte
>              do i = its,ite
>                 rnimpten(k,i) = (ni(k,i)-rnimpten(k,i))/dt_dyn
>                 rnrmpten(k,i) = (nr(k,i)-rnrmpten(k,i))/dt_dyn
>              enddo
>              enddo
> 
1605,1608c1531,1535
<              if(config_tempo_aerosolaware) then
<                 call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
<                 call mpas_pool_get_array(tend_physics,'rnifampten',rnifampten)
<                 call mpas_pool_get_array(tend_physics,'rnwfampten',rnwfampten)
---
>              mp3_tend_select: select case(trim(mp_scheme))
>                 case("mp_thompson_aerosols")
>                    call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
>                    call mpas_pool_get_array(tend_physics,'rnifampten',rnifampten)
>                    call mpas_pool_get_array(tend_physics,'rnwfampten',rnwfampten)
1610,1617c1537,1561
<                 do k = kts,kte
<                 do i = its,ite
<                    rncmpten(k,i)   = (nc(k,i)-rncmpten(k,i))/dt_dyn
<                    rnifampten(k,i) = (nifa(k,i)-rnifampten(k,i))/dt_dyn
<                    rnwfampten(k,i) = (nwfa(k,i)-rnwfampten(k,i))/dt_dyn
<                 enddo
<                 enddo
<              endif
---
>                    do k = kts,kte
>                    do i = its,ite
>                       rncmpten(k,i)   = (nc(k,i)-rncmpten(k,i))/dt_dyn
>                       rnifampten(k,i) = (nifa(k,i)-rnifampten(k,i))/dt_dyn
>                       rnwfampten(k,i) = (nwfa(k,i)-rnwfampten(k,i))/dt_dyn
>                    enddo
>                    enddo
>                 
>                 case("mp_tempo")
>                    if(config_tempo_aerosolaware) then
>                       call mpas_pool_get_array(tend_physics,'rncmpten',rncmpten)
>                       call mpas_pool_get_array(tend_physics,'rnifampten',rnifampten)
>                       call mpas_pool_get_array(tend_physics,'rnwfampten',rnwfampten)
> 
>                       do k = kts,kte
>                       do i = its,ite
>                          rncmpten(k,i)   = (nc(k,i)-rncmpten(k,i))/dt_dyn
>                          rnifampten(k,i) = (nifa(k,i)-rnifampten(k,i))/dt_dyn
>                          rnwfampten(k,i) = (nwfa(k,i)-rnwfampten(k,i))/dt_dyn
>                       enddo
>                       enddo
>                    endif
> 
>                 case default
>              end select mp3_tend_select
1620c1564
<        end select mp2a_tend_select
---
>        end select mp2_tend_select
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_landuse.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_landuse.F
99d98
<                    config_do_DAcycling,&
139d137
<  call mpas_pool_get_config(configs,'config_do_DAcycling' ,config_do_DAcycling )
169,170c167
< 
<  if (config_lsm_scheme .eq. 'sf_ruc') then
---
>  if (config_lsm_scheme .eq. 'ruc') then
185d181
<  if((config_lsm_scheme .ne. 'sf_ruc')) then
271,273c267
<  endif ! not sf_ruc
< 
<  if(config_do_restart ) then
---
>  if(config_do_restart) then
278,283d271
<   if(config_do_DAcycling) then
<     call mpas_log_write('--- config_do_DAcycling =$l', logicArgs=(/config_do_restart/))
<     call mpas_log_write('--- skip the end of landuse_init_forMPAS')
<     return
<  endif
< 
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_lsm_noahmpinit.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_lsm_noahmpinit.F
13d12
<  use mpas_atmphys_constants,only: grav => gravity, t0 => svpt0
257d255
< 
260,262d257
<  real(kind=RKIND),parameter:: hlice = 3.335E5
<  real(kind=RKIND):: bexp,fk,smcmax,psisat
< 
399,434d393
< !--- initialization of the soil liquid water content:
<  do i = its,ite
<     if(ivgtyp(i) == mpas_noahmp%isice_table .and. xice(i) .le. 0._RKIND) then
<        !initialization over landice grid cells (frozen at init time):
<        do ns = 1,nsoil
<           smois(ns,i) = 1._RKIND
<           sh2o(ns,i)  = 0._RKIND
<           tslb(ns,i)  = min(tslb(ns,i),263.15) ! set landice temperature at -10C.
<        enddo
<     else
<        !initialization over all non-landice grid cells:
<        bexp   = mpas_noahmp%bexp_table(isltyp(i))
<        smcmax = mpas_noahmp%smcmax_table(isltyp(i))
<        psisat = mpas_noahmp%psisat_table(isltyp(i))
< 
<        do ns = 1,nsoil
<           if(smois(ns,i) > smcmax) smois(ns,i) = smcmax
<        enddo
<        if(bexp.gt.0. .and. smcmax.gt.0. .and. psisat.gt.0.) then
<           do ns = 1,nsoil
<              if(tslb(ns,i) .lt. 273.149) then ! initial soil ice.
<                 fk = ( ((hlice/(grav*(-psisat)))*((tslb(ns,i)-t0)/tslb(ns,i)))**(-1/bexp) )*smcmax
<                 fk = max(fk,0.02)
<                 sh2o(ns,i) = min(fk,smois(ns,i))
<              else
<                 sh2o(ns,i) = smois(ns,i)
<              endif
<           enddo
<        else
<           do ns = 1,nsoil
<              sh2o(ns,i) = smois(ns,i)
<           enddo
<        endif
<     endif
<  enddo
< 
464,466c423,425
<        sh2o(ns,i)  = mpas_noahmp%sh2o(i,ns)
<        smois(ns,i) = mpas_noahmp%smois(i,ns)
<        tslb(ns,i)  = mpas_noahmp%tslb(i,ns)
---
>        mpas_noahmp%sh2o(i,ns)  = sh2o(ns,i)
>        mpas_noahmp%smois(i,ns) = smois(ns,i)
>        mpas_noahmp%tslb(i,ns)  = tslb(ns,i)
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_lsm_rucinit.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_lsm_rucinit.F
22c22
< ! NOAA physics
---
> !wrf physics
91c91
<  logical,pointer:: input_sfc_albedo,restart,cycling
---
>  logical,pointer:: input_sfc_albedo,restart
125,126d124
<  call mpas_pool_get_config(configs,'config_do_DAcycling'  ,cycling         )
< 
176c174,175
< if(.not.restart .and. .not. cycling) then
---
> 
> if(.not.restart) then
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_sfc_diagnostics.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_sfc_diagnostics.F
22d21
< 
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_vars.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/mpas_atmphys_vars.F
307,308d306
<  real(kind=RKIND),dimension(:,:),allocatable:: &
<     max_hail_diameter_sfc_p, max_hail_diameter_column_p
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics: MYNN-EDMF
Binary files ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/index and /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/index differ
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/logs/HEAD /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/logs/HEAD
1c1
< 0000000000000000000000000000000000000000 a4baf7f3243d1db0dbc5f63473f895bdbdc05c30 Junjun Hu <Junjun.Hu@gaea65.ncrc.gov> 1751420665 -0400	clone: from https://github.com/NCAR/MMM-physics
---
> 0000000000000000000000000000000000000000 0ea59b1cd673006ee7a9a9958c533a6a0e354243 Junjun Hu <Junjun.Hu@gaea65.ncrc.gov> 1749689495 -0400	clone: from https://github.com/NCAR/MMM-physics
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/logs/refs/heads/main /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/logs/refs/heads/main
1c1
< 0000000000000000000000000000000000000000 a4baf7f3243d1db0dbc5f63473f895bdbdc05c30 Junjun Hu <Junjun.Hu@gaea65.ncrc.gov> 1751420665 -0400	clone: from https://github.com/NCAR/MMM-physics
---
> 0000000000000000000000000000000000000000 0ea59b1cd673006ee7a9a9958c533a6a0e354243 Junjun Hu <Junjun.Hu@gaea65.ncrc.gov> 1749689495 -0400	clone: from https://github.com/NCAR/MMM-physics
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/logs/refs/remotes/origin/HEAD /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/logs/refs/remotes/origin/HEAD
1c1
< 0000000000000000000000000000000000000000 a4baf7f3243d1db0dbc5f63473f895bdbdc05c30 Junjun Hu <Junjun.Hu@gaea65.ncrc.gov> 1751420665 -0400	clone: from https://github.com/NCAR/MMM-physics
---
> 0000000000000000000000000000000000000000 0ea59b1cd673006ee7a9a9958c533a6a0e354243 Junjun Hu <Junjun.Hu@gaea65.ncrc.gov> 1749689495 -0400	clone: from https://github.com/NCAR/MMM-physics
Only in ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/objects/pack: pack-8c18792ea6f864ae82240693d9328147d817c18e.idx
Only in ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/objects/pack: pack-8c18792ea6f864ae82240693d9328147d817c18e.pack
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/objects/pack: pack-972d7d432e31ac4744e8f202479aec13ad46f959.idx
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/objects/pack: pack-972d7d432e31ac4744e8f202479aec13ad46f959.pack
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/packed-refs /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/packed-refs
2c2
< a4baf7f3243d1db0dbc5f63473f895bdbdc05c30 refs/remotes/origin/main
---
> 0ea59b1cd673006ee7a9a9958c533a6a0e354243 refs/remotes/origin/main
7,8d6
< 3ec5ac84809c445a196f01d84c4d2d1640b79776 refs/tags/20250616-MPASv8.3
< ^a4baf7f3243d1db0dbc5f63473f895bdbdc05c30
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/refs/heads/main /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/.git/refs/heads/main
1c1
< a4baf7f3243d1db0dbc5f63473f895bdbdc05c30
---
> 0ea59b1cd673006ee7a9a9958c533a6a0e354243
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_mmm/Makefile.mpas /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_mmm/Makefile.mpas
52,55d51
< # Cancel the built-in implicit rule for Modula-2 files (.mod) to avoid having
< # make try to create .o files from Fortran .mod files
< %.o : %.mod
< 
Only in ../../../../../sorc/mpas/src/core_atmosphere/physics: physics_noaa
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_noahmp/drivers/mpas/NoahmpInitMainMod.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_noahmp/drivers/mpas/NoahmpInitMainMod.F90
53c53
<     do i = its, ite 
---
>     do i = its, its
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_wrf/Makefile /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf/Makefile
47a48,50
> 	module_ruc_land.o              \
> 	module_ruc_ice.o               \
> 	module_sf_sfcdiags_ruclsm.o    \
146c149
< 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I.. -I../physics_mmm -I../physics_noaa/UGWP -I../../../framework -I../../../external/esmf_time_f90
---
> 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I.. -I../physics_mmm -I../UGWP -I../../../framework -I../../../external/esmf_time_f90
148c151
< 	$(FC) $(CPPFLAGS) $(COREDEF) $(FFLAGS) -c $*.F $(CPPINCLUDES) $(FCINCLUDES) -I.. -I../physics_mmm -I../physics_noaa/UGWP -I../../../framework -I../../../external/esmf_time_f90
---
> 	$(FC) $(CPPFLAGS) $(COREDEF) $(FFLAGS) -c $*.F $(CPPINCLUDES) $(FCINCLUDES) -I.. -I../physics_mmm -I../UGWP -I../../../framework -I../../../external/esmf_time_f90
153c156
< 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I.. -I../physics_mmm -I../physics_noaa/UGWP -I../../../framework -I../../../external/esmf_time_f90
---
> 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I.. -I../physics_mmm -I../UGWP -I../../../framework -I../../../external/esmf_time_f90
155c158
< 	$(FC) $(CPPFLAGS) $(COREDEF) $(FFLAGS) -c $*.F90 $(CPPINCLUDES) $(FCINCLUDES) -I.. -I../physics_mmm -I../physics_noaa/UGWP -I../../../framework -I../../../external/esmf_time_f90
---
> 	$(FC) $(CPPFLAGS) $(COREDEF) $(FFLAGS) -c $*.F90 $(CPPINCLUDES) $(FCINCLUDES) -I.. -I../physics_mmm -I../UGWP -I../../../framework -I../../../external/esmf_time_f90
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_wrf/module_mynnsfclay_driver.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf/module_mynnsfclay_driver.F90
33c33
<                    restart,cycling,initflag,errmsg,errflg        &
---
>                    errmsg,errflg                                 &
197,198c197
<  logical,intent(in):: restart,cycling
<  integer,intent(in):: itimestep, initflag
---
>  integer,intent(in):: itimestep
279d277
<  logical:: restart_or_cycle
304,306c302
<  restart_or_cycle = .false.
<  if(restart .or. cycling)restart_or_cycle=.true.
<  
---
> 
320c316
<     call mynnsfclay_pre(its,ite,kte,initflag,dz8w,u3d,v3d,p3d,t3d,rho3d,qv3d,qc3d,f_spp,  &
---
>     call mynnsfclay_pre(its,ite,kte,itimestep,dz8w,u3d,v3d,p3d,t3d,rho3d,qv3d,qc3d,f_spp, &
406,407c402
<                  its      = its       , ite      = ite       , restart_or_cycle = restart_or_cycle        , &
<                  errmsg   = errmsg    , errflg   = errflg                                                   &
---
>                  its      = its       , ite      = ite       , errmsg  = errmsg   , errflg    = errflg      &
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_wrf/module_mynnsfclay.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf/module_mynnsfclay.F90
142,143c142
<                      iz0tlnd,its,ite,restart_or_cycle,   &
<                      errmsg,errflg                       &
---
>                      iz0tlnd,its,ite,errmsg,errflg       &
166c165
<  logical,intent(in):: spp_pbl,restart_or_cycle
---
>  logical,intent(in):: spp_pbl
366c365
<     !  (vsgd; for coeff 0.32, 13 km ~ 0.37 m/s; for 3 km == 0 m/s)
---
>     !  (vsgd; for 13 km ~ 0.37 m/s; for 3 km == 0 m/s)
374c373
<        vsgd = 0.20 * (max(dx(i)/5000.-1.,0.))**.33
---
>        vsgd = 0.25 * (max(dx(i)/5000.-1.,0.))**.33
379c378
<        vsgd = 0.20 * (max(dx(i)/5000.-1.,0.))**.33
---
>        vsgd = 0.32 * (max(dx(i)/5000.-1.,0.))**.33
389c388
<     if (.not. restart_or_cycle .and. itimestep == 1) then
---
>     if (itimestep == 1) then
603,604c602,603
<        if (.not. restart_or_cycle .or. (restart_or_cycle .and. itimestep > 1) ) then
<           !compute z/l first guess:
---
>        !compute z/l first guess:
>        if (itimestep .le. 1) then
688,689c687,688
<        if (.not. restart_or_cycle .or. (restart_or_cycle .and. itimestep > 1) ) then
<           !compute z/l first guess:
---
>        !compute z/l first guess:
>        if (itimestep .le. 1) then
diff -r ../../../../../sorc/mpas/src/core_atmosphere/physics/physics_wrf/module_mynnsfclay_pre.F90 /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf/module_mynnsfclay_pre.F90
62c62
<  subroutine mynnsfclay_pre(its,ite,kte,initflag,dz3d,u3d,v3d,p3d,t3d,rho3d,qv3d,qc3d,f_spp,pattern_spp,   &
---
>  subroutine mynnsfclay_pre(its,ite,kte,itimestep,dz3d,u3d,v3d,p3d,t3d,rho3d,qv3d,qc3d,f_spp,pattern_spp,   &
72c72
<  integer,intent(in):: initflag
---
>  integer,intent(in):: itimestep
152c152
<  if(initflag == 1) then
---
>  if(itimestep == 1) then
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf: module_ruc_ice.F90
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf: module_ruc_land.F90
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf: module_sf_ruclsm.F
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics/physics_wrf: module_sf_sfcdiags_ruclsm.F
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics: TEMPO
Only in /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/physics: UGWP
diff -r ../../../../../sorc/mpas/src/core_atmosphere/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/Registry.xml
2c2,3
< <registry model="mpas" core="atmosphere" core_abbrev="atm" version="8.2.3-3.12">
---
> <registry model="mpas" core="atmosphere" core_abbrev="atm" version="8.2.2-2.12">
> 
664,666d664
< 			<var name="max_hail_diameter_sfc"/>
< 			<var name="max_hail_diameter_sfc_acc"/>
< 			<var name="max_hail_diameter_column"/>
1034d1031
< 			<var name="dzs"/>
1130,1132d1126
< 			<var name="max_hail_diameter_sfc"/>
< 			<var name="max_hail_diameter_sfc_acc"/>
< 			<var name="max_hail_diameter_column"/>
1297,1298c1291
<                         immutable="false"
<                         runtime_format="separate_file"
---
>                         immutable="true"
1304d1296
<                         <var name="Time"/>
1307,1308d1298
<                         <var name="rho_zz"/>
<                         <var name="theta_m"/>
1318,1327d1307
<                         <var name="circulation"/>
<                         <var name="exner"/>
<                         <var name="exner_base"/>
<                         <var name="rtheta_base"/>
<                         <var name="ru"/>
<                         <var name="ru_p"/>
<                         <var name="rw"/>
<                         <var name="rw_p"/>
<                         <var name="rtheta_p"/>
<                         <var name="rho_p"/>
1330,1343d1309
<                         <var name="rainprod"/>
<                         <var name="evapprod"/>
<                         <var name="isltyp"/>
<                         <var name="soilf"/>
<                         <var name="ivgtyp"/>
<                         <var name="landusef"/>
<                         <var name="mminlu"/>
<                         <var name="landmask"/>
<                         <var name="shdmin"/>
<                         <var name="shdmax"/>
<                         <var name="snoalb"/>
<                         <var name="albedo12m"/>
<                         <var name="greenfrac"/>
<                         <var name="lai12m"/>
1348,1360d1313
<                         <var name="nwfa2d"/>
<                         <var name="nifa2d"/>
<                         <var name="nt_c"/>
<                         <var name="mu_c"/>
<                         <var name="tend_sfc_pressure"/>
<                         <var name="rt_diabatic_tend"/>
<                         <var name="nsteps_accum"/>
<                         <var name="ndays_accum"/>
<                         <var name="tlag"/>
<                         <var name="tday_accum"/>
<                         <var name="tyear_mean"/>
<                         <var name="tyear_accum"/>
<                         <var name="refl10cm"/>
1364,1561d1316
<                         <var name="i_rainnc"/>
<                         <var name="rainncv"/>
<                         <var name="snowncv"/>
<                         <var name="snownc"/>
<                         <var name="graupelncv"/>
<                         <var name="graupelnc"/>
<                         <var name="sr"/>
<                         <var name="i_rainc"/>
<                         <var name="cuprec"/>
<                         <var name="raincv"/>
<                         <var name="nca"/>
<                         <var name="cubot"/>
<                         <var name="cutop"/>
<                         <var name="w0avg"/>
<                         <var name="qcg"/>
<                         <var name="sh3d"/>
<                         <var name="sm3d"/>
<                         <var name="qke"/>
<                         <var name="qke_adv"/>
<                         <var name="cov"/>
<                         <var name="qsq"/>
<                         <var name="tsq"/>
<                         <var name="tke_pbl"/>
<                         <var name="wstar"/>
<                         <var name="delta"/>
<                         <var name="el_pbl"/>
<                         <var name="edmf_a"/>
<                         <var name="edmf_w"/>
<                         <var name="edmf_qt"/>
<                         <var name="edmf_qc"/>
<                         <var name="edmf_thl"/>
<                         <var name="edmf_ent"/>
<                         <var name="sub_thl"/>
<                         <var name="sub_qv"/>
<                         <var name="det_thl"/>
<                         <var name="det_qv"/>
<                         <var name="cldfrac_bl"/>
<                         <var name="qc_bl"/>
<                         <var name="qi_bl"/>
<                         <var name="ch"/>
<                         <var name="kpbl"/>
<                         <var name="hpbl"/>
<                         <var name="hfx"/>
<                         <var name="cldfrac_cu"/>
<                         <var name="refl10cm_cu"/>
<                         <var name="mol"/>
<                         <var name="qfx"/>
<                         <var name="qsfc"/>
<                         <var name="ustm"/>
<                         <var name="zol"/>
<                         <var name="br"/>
<                         <var name="cd"/>
<                         <var name="cda"/>
<                         <var name="chs"/>
<                         <var name="chs2"/>
<                         <var name="cqs2"/>
<                         <var name="cqs"/>
<                         <var name="ck"/>
<                         <var name="cka"/>
<                         <var name="cpm"/>
<                         <var name="flhc"/>
<                         <var name="flqc"/>
<                         <var name="gz1oz0"/>
<                         <var name="lh"/>
<                         <var name="psim"/>
<                         <var name="psih"/>
<                         <var name="qgh"/>
<                         <var name="regime"/>
<                         <var name="rmol"/>
<                         <var name="wspd"/>
<                         <var name="fh"/>
<                         <var name="fm"/>
<                         <var name="th2m"/>
<                         <var name="dusfcg"/>
<                         <var name="dvsfcg"/>
<                         <var name="dtaux3d"/>
<                         <var name="dtauy3d"/>
<                         <var name="rubldiff"/>
<                         <var name="rvbldiff"/>
<                         <var name="i_acswdnb"/>
<                         <var name="i_acswdnbc"/>
<                         <var name="i_acswdnt"/>
<                         <var name="i_acswdntc"/>
<                         <var name="i_acswupb"/>
<                         <var name="i_acswupbc"/>
<                         <var name="i_acswupt"/>
<                         <var name="i_acswuptc"/>
<                         <var name="acswdnb"/>
<                         <var name="acswdnbc"/>
<                         <var name="acswdnt"/>
<                         <var name="acswdntc"/>
<                         <var name="acswupb"/>
<                         <var name="acswupbc"/>
<                         <var name="acswupt"/>
<                         <var name="acswuptc"/>
<                         <var name="gsw"/>
<                         <var name="i_aclwdnb"/>
<                         <var name="i_aclwdnbc"/>
<                         <var name="i_aclwdnt"/>
<                         <var name="i_aclwdntc"/>
<                         <var name="i_aclwupb"/>
<                         <var name="i_aclwupbc"/>
<                         <var name="i_aclwupt"/>
<                         <var name="i_aclwuptc"/>
<                         <var name="aclwdnb"/>
<                         <var name="aclwdnbc"/>
<                         <var name="aclwdnt"/>
<                         <var name="aclwdntc"/>
<                         <var name="aclwupb"/>
<                         <var name="aclwupbc"/>
<                         <var name="aclwupt"/>
<                         <var name="aclwuptc"/>
<                         <var name="glw"/>
<                         <var name="o3clim"/>
<                         <var name="o3vmr"/>
<                         <var name="acsnom"/>
<                         <var name="acsnow"/>
<                         <var name="canwat"/>
<                         <var name="chklowq"/>
<                         <var name="grdflx"/>
<                         <var name="noahres"/>
<                         <var name="potevp"/>
<                         <var name="sfcrunoff"/>
<                         <var name="smstav"/>
<                         <var name="smstot"/>
<                         <var name="snopcx"/>
<                         <var name="snotime"/>
<                         <var name="sstsk"/>
<                         <var name="sstsk_dtc"/>
<                         <var name="sstsk_dtw"/>
<                         <var name="udrunoff"/>
<                         <var name="rhosnf"/>
<                         <var name="precipfr"/>
<                         <var name="qsg"/>
<                         <var name="qvg"/>
<                         <var name="dew"/>
<                         <var name="soilt1"/>
<                         <var name="tsnav"/>
<                         <var name="acrunoff"/>
<                         <var name="snowfallac"/>
<                         <var name="smfr3d"/>
<                         <var name="k22_shallow"/>
<                         <var name="kbcon_shallow"/>
<                         <var name="ktop_shallow"/>
<                         <var name="ktop_deep"/>
<                         <var name="xmb_total"/>
<                         <var name="xmb_shallow"/>
<                         <var name="qc_cu"/>
<                         <var name="qi_cu"/>
<                         <var name="rthmpten"/>
<                         <var name="rqvmpten"/>
<                         <var name="rqcmpten"/>
<                         <var name="rqrmpten"/>
<                         <var name="rqimpten"/>
<                         <var name="rqsmpten"/>
<                         <var name="rqgmpten"/>
<                         <var name="rncmpten"/>
<                         <var name="rnimpten"/>
<                         <var name="rnrmpten"/>
<                         <var name="rnifampten"/>
<                         <var name="rnwfampten"/>
<                         <var name="rthcuten"/>
<                         <var name="rqvcuten"/>
<                         <var name="rqccuten"/>
<                         <var name="rqicuten"/>
<                         <var name="rqrcuten"/>
<                         <var name="rqscuten"/>
<                         <var name="rqvdynten"/>
<                         <var name="rthdynten"/>
<                         <var name="rucuten"/>
<                         <var name="rvcuten"/>
<                         <var name="rublten"/>
<                         <var name="rvblten"/>
<                         <var name="rthblten"/>
<                         <var name="rqvblten"/>
<                         <var name="rqcblten"/>
<                         <var name="rqiblten"/>
<                         <var name="rqsblten"/>
<                         <var name="rncblten"/>
<                         <var name="rniblten"/>
<                         <var name="rnifablten"/>
<                         <var name="rnwfablten"/>
<                         <var name="rthratensw"/>
<                         <var name="rthratenlw"/>
<                         <var name="vcpool" packages="cu_grell_freitas_in"/>
<                         <var name="sub3d_rthcuten" packages="cu_grell_freitas_in"/>
<                         <var name="sub3d_rqvcuten" packages="cu_grell_freitas_in"/>
<                         <var name="sub3d_rucuten" packages="cu_grell_freitas_in"/>
<                         <var name="sub3d_rvcuten" packages="cu_grell_freitas_in"/>
<                         <var name="sigma_deep" packages="cu_grell_freitas_in"/>
<                         <var name="smcrel"/>
<                         <var name="t_oml"/>
<                         <var name="t_oml_initial"/>
<                         <var name="t_oml_200m_initial"/>
<                         <var name="h_oml"/>
<                         <var name="hu_oml"/>
<                         <var name="hv_oml"/>
<                         <var_struct name="diag_physics_noahmp"/>
2004c1759
<                              packages="mp_thompson_in;mp_thompson_aers_in;mp_nssl2m_in;mp_tempo_in"/>
---
>                              packages="mp_thompson_in;mp_nssl2m_in;mp_tempo_in"/>
2395c2150
<                              packages="mp_thompson_in;mp_thompson_aers_in;mp_nssl2m_in;mp_tempo_in"/>
---
>                              packages="mp_thompson_in;mp_nssl2m_in;mp_tempo_in"/>
2711,2725d2465
< 		<nml_option name="config_tempo_ml_nc_pbl" type="logical" default_value="false" in_defaults="false"
< 		     units="-"
<                      description="Logical flag to turn on/off ML prediction of boundary layer cloud number concentrations"
<                      possible_values=".true. or .false."/>
< 
< 		<nml_option name="config_tempo_ml_nc" type="logical" default_value="false" in_defaults="false"
< 		     units="-"
<                      description="Logical flag to turn on/off ML prediction of microphysics cloud number concentrations"
<                      possible_values=".true. or .false."/>
< 
< 		<nml_option name="config_tempo_ml_nr" type="logical" default_value="false" in_defaults="false"
< 		     units="-"
<                      description="Logical flag to turn on/off ML prediction of microphysics rain number concentrations"
<                      possible_values=".true. or .false."/>
< 
2766,2770d2505
<                 <nml_option name="config_knob_ugwp_tauamp" type="real" default_value="0.13e-3" in_defaults="false"
<                      units="-"
<                      description="non-stationary gravity wave drag absolute momentum flux at launch level"
<                      possible_values="Non-negative real values"/>
< 
2985,2996d2719
< 		<var name="max_hail_diameter_sfc" type="real" dimensions="nCells Time" units="mm"
<                      description="Maximum hail diameter at the surface"
<                      packages="mp_tempo_in"/>
< 
< 		<var name="max_hail_diameter_column" type="real" dimensions="nCells Time" units="mm"
<                      description="Maximum hail diameter in the vertical column"
<                      packages="mp_tempo_in"/>
< 
< 		<var name="max_hail_diameter_sfc_acc" type="real" dimensions="nCells Time" units="mm"
<                      description="Maximum hail diameter at the surface accumulated over diagnostic output"
<                      packages="mp_tempo_in"/>
< 
4389c4112
<                 <var name="shdmin" type="real" dimensions="nCells" units="percent"
---
>                 <var name="shdmin" type="real" dimensions="nCells" units="unitless"
4392c4115
<                 <var name="shdmax" type="real" dimensions="nCells" units="percent"
---
>                 <var name="shdmax" type="real" dimensions="nCells" units="unitless"
4401c4124
<                 <var name="albedo12m" type="real" dimensions="nMonths nCells" units="percent"
---
>                 <var name="albedo12m" type="real" dimensions="nMonths nCells" units="unitless"
4408,4409c4131,4132
<                 <var name="greenfrac" type="real" dimensions="nMonths nCells" units="percent"
<                      description="monthly-mean climatological greenness fraction"/>
---
>                 <var name="greenfrac" type="real" dimensions="nMonths nCells" units="unitless"
>                      description="monthly-mean climatological greeness fraction"/>
4438c4161
<                 <var name="vegfra" type="real" dimensions="nCells Time" units="percent"
---
>                 <var name="vegfra" type="real" dimensions="nCells Time" units="unitless"
diff -r ../../../../../sorc/mpas/src/core_atmosphere/utils/Makefile /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_atmosphere/utils/Makefile
24,26c24,26
< 	../physics/physics_noaa/TEMPO/module_mp_tempo.o \
< 	../physics/physics_noaa/TEMPO/module_mp_tempo_utils.o \
< 	../physics/physics_noaa/TEMPO/module_mp_tempo_params.o
---
> 	../physics/TEMPO/module_mp_tempo.o \
> 	../physics/TEMPO/module_mp_tempo_utils.o \
> 	../physics/TEMPO/module_mp_tempo_params.o
38c38
< 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I../../framework -I../../operators -I../physics -I../physics/physics_mmm -I../physics/physics_wrf -I../physics/physics_noaa/TEMPO -I../../external/esmf_time_f90
---
> 	$(FC) $(FFLAGS) -c $*.f90 $(FCINCLUDES) -I../../framework -I../../operators -I../physics -I../physics/physics_mmm -I../physics/physics_wrf -I../physics/TEMPO -I../../external/esmf_time_f90
40c40
< 	$(FC) $(CPPFLAGS) $(PHYSICS) $(FFLAGS) -c $*.F $(CPPINCLUDES) $(FCINCLUDES) -I../../framework -I../../operators -I../physics -I../physics/physics_mmm -I../physics/physics_wrf -I../physics/physics_noaa/TEMPO -I../../external/esmf_time_f90
---
> 	$(FC) $(CPPFLAGS) $(PHYSICS) $(FFLAGS) -c $*.F $(CPPINCLUDES) $(FCINCLUDES) -I../../framework -I../../operators -I../physics -I../physics/physics_mmm -I../physics/physics_wrf -I../physics/TEMPO -I../../external/esmf_time_f90
diff -r ../../../../../sorc/mpas/src/core_init_atmosphere/mpas_init_atm_cases.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_init_atmosphere/mpas_init_atm_cases.F
177c177
<             call init_atm_case_mtn_wave(domain % dminfo, mesh, nCells, nVertLevels, state, diag, block_ptr % configs)
---
>             call init_atm_case_mtn_wave(mesh, nCells, nVertLevels, state, diag, block_ptr % configs)
416c416
<                   call init_atm_thompson_aerosols_lbc(timeString, timeStart, block_ptr, mesh, diag, lbc_state)
---
>                   call init_atm_thompson_aerosols_lbc(timeString, timeStart, block_ptr, mesh, diag, state, lbc_state)
2076c2076
<    subroutine init_atm_case_mtn_wave(dminfo, mesh, nCells, nVertLevels, state, diag, configs)
---
>    subroutine init_atm_case_mtn_wave(mesh, nCells, nVertLevels, state, diag, configs)
2078,2079c2078
<    ! Setup mountain wave test case from Schär et al. (2001): A New Terrain-Following Vertical
<    ! Coordinate Formulation for Atmospheric Prediction Models
---
>    ! Setup baroclinic wave test case from Jablonowski and Williamson 2008 (QJRMS)
2084d2082
<       type (dm_info), intent(in) :: dminfo
2268,2269c2266
<       call mpas_dmpar_max_real(dminfo, maxval(xCell(:)), xc)
<       xc = xc * 0.5
---
>       xc = maxval (xCell(:))/2.
5108d5104
<                   deallocate(field % slab)
5549c5545
< call mpas_log_write('Interpolating SOILM000')
---
>                ndims = 2
5553c5549
<                call mpas_log_write('Interpolating SOILM000')
---
> call mpas_log_write('Interpolating SOILM000')
7614d7609
<                   deallocate(field % slab)
9305,9306c9300,9301
<       
<          !monthly climatological surface albedo and greenness fraction:
---
> 
>          !monthly climatological surface albedo and greeness fraction:
diff -r ../../../../../sorc/mpas/src/core_init_atmosphere/mpas_init_atm_thompson_aerosols.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_init_atmosphere/mpas_init_atm_thompson_aerosols.F
722c722
<  subroutine init_atm_thompson_aerosols_lbc(timestamp,timestart,block,mesh,diag,lbc_state)
---
>  subroutine init_atm_thompson_aerosols_lbc(timestamp,timestart,block,mesh,diag,state,lbc_state)
727a728
>  type(mpas_pool_type),intent(in):: state
diff -r ../../../../../sorc/mpas/src/core_init_atmosphere/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_init_atmosphere/Registry.xml
2c2
< <registry model="mpas" core="init_atmosphere" core_abbrev="init_atm" version="8.2.3-3.12">
---
> <registry model="mpas" core="init_atmosphere" core_abbrev="init_atm" version="8.2.2-2.12">
902,903c902,903
<                 <var name="greenfrac" type="real" dimensions="nMonths nCells" units="percent"
<                      description="monthly-mean climatological greenness fraction"/>
---
>                 <var name="greenfrac" type="real" dimensions="nMonths nCells" units="unitless"
>                      description="monthly-mean climatological greeness fraction"/>
905c905
<                 <var name="shdmin" type="real" dimensions="nCells" units="percent"
---
>                 <var name="shdmin" type="real" dimensions="nCells" units="unitless"
908c908
<                 <var name="shdmax" type="real" dimensions="nCells" units="percent"
---
>                 <var name="shdmax" type="real" dimensions="nCells" units="unitless"
911c911
<                 <var name="albedo12m" type="real" dimensions="nMonths nCells" units="percent"
---
>                 <var name="albedo12m" type="real" dimensions="nMonths nCells" units="unitless"
1488c1488
<                 <var name="vegfra" type="real" dimensions="nCells Time" units="percent"
---
>                 <var name="vegfra" type="real" dimensions="nCells Time" units="unitless"
diff -r ../../../../../sorc/mpas/src/core_landice/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_landice/Registry.xml
2c2
< <registry model="mpas" core="landice" core_abbrev="li" version="8.2.3">
---
> <registry model="mpas" core="landice" core_abbrev="li" version="8.2.2">
diff -r ../../../../../sorc/mpas/src/core_ocean/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_ocean/Registry.xml
2c2
< <registry model="mpas" core="ocean" core_abbrev="ocn" version="8.2.3">
---
> <registry model="mpas" core="ocean" core_abbrev="ocn" version="8.2.2">
diff -r ../../../../../sorc/mpas/src/core_seaice/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_seaice/Registry.xml
2c2
< <registry model="mpas" core="seaice" core_abbrev="seaice" version="8.2.3">
---
> <registry model="mpas" core="seaice" core_abbrev="seaice" version="8.2.2">
diff -r ../../../../../sorc/mpas/src/core_sw/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_sw/Registry.xml
2c2
< <registry model="mpas" core="sw" core_abbrev="sw" version="8.2.3">
---
> <registry model="mpas" core="sw" core_abbrev="sw" version="8.2.2">
diff -r ../../../../../sorc/mpas/src/core_test/mpas_test_core.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_test/mpas_test_core.F
231,242d230
<       !
<       ! Test functionality of adjustments to alarm reference time
<       !
<       call mpas_log_write('')
<       call mpas_log_write('Testing mpas_adjust_alarm_to_reference_time:')
<       call mpas_adjust_alarm_tests(domain, iErr)
<       if (iErr == 0) then
<          call mpas_log_write('* mpas_adjust_alarm_tests tests - all tests passed: SUCCESS')
<       else
<          call mpas_log_write('* mpas_adjust_alarm_tests tests - $i failed tests: FAILURE', intArgs=[iErr])
<       end if
<       call mpas_log_write('')
diff -r ../../../../../sorc/mpas/src/core_test/mpas_test_core_timekeeping_tests.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_test/mpas_test_core_timekeeping_tests.F
8,10d7
< 
< #define MPAS_ADJUST_ALARM_VERBOSE( M ) ! M
< 
25,26c22
<    public :: test_core_test_intervals, &
<              mpas_adjust_alarm_tests
---
>    public :: test_core_test_intervals
184,462d179
< 
<    !***********************************************************************
<    !
<    !  routine mpas_adjust_alarm_tests
<    !
<    !> \brief   Tests functionality of mpas_adjust_alarm_to_reference_time
<    !> \author  Michael Duda
<    !> \date    25 Feb 2025
<    !> \details
<    !>  This routine tests the functionality of the
<    !>  mpas_adjust_alarm_to_reference_time routine for combinations of the
<    !>  following possibilities:
<    !>
<    !>  - The current time is aligned with the new alarm time grid
<    !>  - The current time is not aligned with the new alarm time grid
<    !>
<    !>  - The reference time is before the current time on the clock
<    !>  - The reference time is the same as the current time on the clock
<    !>  - The reference time is after the current time on the clock
<    !>
<    !>  - The clock is running forwards
<    !>  - The clock is running backwards
<    !>
<    !>  Upon return, the ierr arugment is set to the number of failed tests.
<    !
<    !-----------------------------------------------------------------------
<    subroutine mpas_adjust_alarm_tests(domain, ierr)
< 
<       use mpas_derived_types, only : domain_type, MPAS_Clock_type, MPAS_Time_type, MPAS_TimeInterval_type
<       use mpas_kind_types, only : StrKIND
<       use mpas_log, only : mpas_log_write
<       use mpas_timekeeping, only : mpas_set_time, mpas_set_timeInterval, mpas_create_clock, &
<               mpas_add_clock_alarm, mpas_is_alarm_ringing, mpas_reset_clock_alarm
< 
<       implicit none
< 
<       type (domain_type), intent(inout) :: domain
<       integer, intent(out) :: ierr
< 
<       integer :: istep
<       integer :: ierr_local
<       character(len=StrKIND) :: test_mesg
<       type (MPAS_Clock_type) :: test_clock
<       type (MPAS_Time_type) :: test_startTime
<       type (MPAS_Time_type) :: test_stopTime
<       type (MPAS_Time_type) :: test_currTime
<       type (MPAS_Time_type) :: test_alarmTime
<       type (MPAS_Time_type) :: test_refTime
<       type (MPAS_TimeInterval_type) :: test_timeStep
<       type (MPAS_TimeInterval_type) :: test_alarmTimeInterval
<       MPAS_ADJUST_ALARM_VERBOSE( character(len=StrKIND) :: timeStamp )
< 
<       ierr = 0
< 
<       !
<       ! Create a clock with an initial time of 2000-01-01_00 and with a 1-hour 'tick' length
<       ! (The stopping time is set to 2100-01-01_00.)
<       !
<       call mpas_set_time(test_startTime, YYYY=2000, MM=01, DD=01, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_set_time(test_stopTime, YYYY=2100, MM=01, DD=01, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_set_timeInterval(test_timeStep, dt=3600.0_RKIND, ierr=ierr_local)
< 
<       call mpas_create_clock(test_clock, test_startTime, test_timeStep, test_stopTime, ierr=ierr_local)
< 
<       !
<       ! Add a recurring alarm to the clock with an initial reference time of 2000-01-01_00 and
<       ! a ringing interval of 1 day.
<       !
<       call mpas_set_time(test_alarmTime, YYYY=2000, MM=01, DD=01, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_set_timeInterval(test_alarmTimeInterval, dt=86400.0_RKIND, ierr=ierr_local)
< 
<       call mpas_add_clock_alarm(test_clock, 'foobar', test_alarmTime, test_alarmTimeInterval, ierr_local)
< 
< #ifdef MPAS_ADVANCE_TEST_CLOCK
<       do istep = 1, 24*365
<           if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<               call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
<               test_currTime = mpas_get_clock_time(test_clock, MPAS_NOW, iErr)
<               call mpas_get_time(test_currTime, dateTimeString=timeStamp)
<               call mpas_log_write('**ALARM** '//trim(timeStamp))
<           end if
<           call mpas_advance_clock(test_clock, ierr=ierr_local)
<       end do
< #endif
< 
<       MPAS_ADJUST_ALARM_VERBOSE( test_currTime = mpas_get_clock_time(test_clock, MPAS_NOW, iErr) )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_get_time(test_currTime, dateTimeString=timeStamp) )
< 
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Now it is '//trim(timeStamp)) )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('') )
< 
< 
<       write(test_mesg, '(a)') '  forward clock, ref_time < now, now is on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 1999-06-15_00') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=1999, MM=6, DD=15, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  forward clock, ref_time > now, now is on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 2010-02-01_00') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=2010, MM=2, DD=1, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  forward clock, ref_time = now, now is on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 2000-01-01_00') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=2000, MM=1, DD=1, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  forward clock, ref_time < now, now is NOT on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 1999-06-15_08') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=1999, MM=6, DD=15, H=8, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  forward clock, ref_time > now, now is NOT on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 2010-02-01_18') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=2010, MM=2, DD=1, H=18, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       !
<       ! Set clock to run backwards in time
<       !
<       call mpas_set_clock_direction(test_clock, MPAS_BACKWARD, ierr_local)
< 
<       write(test_mesg, '(a)') '  backward clock, ref_time < now, now is on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 1999-06-15_00') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=1999, MM=6, DD=15, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  backward clock, ref_time > now, now is on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 2010-02-01_00') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=2010, MM=2, DD=1, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  backward clock, ref_time = now, now is on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 2000-01-01_00') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=2000, MM=1, DD=1, H=0, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  backward clock, ref_time < now, now is NOT on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 1999-06-15_08') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=1999, MM=6, DD=15, H=8, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<       write(test_mesg, '(a)') '  backward clock, ref_time > now, now is NOT on new alarm time grid: '
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('=================================') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('Setting ref time to 2010-02-01_18') )
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('---------------------------------') )
<       call mpas_set_time(test_refTime, YYYY=2010, MM=2, DD=1, H=18, M=0, S=0, S_n=0, S_d=0, ierr=ierr_local)
<       call mpas_adjust_alarm_to_reference_time(test_clock, 'foobar', test_refTime, ierr_local)
<       MPAS_ADJUST_ALARM_VERBOSE( call mpas_print_alarm(test_clock, 'foobar', ierr_local) )
<       if (mpas_is_alarm_ringing(test_clock, 'foobar', ierr=ierr_local)) then
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is RINGING') )
<           test_mesg = trim(test_mesg)//' SUCCESS'
<       else
<           MPAS_ADJUST_ALARM_VERBOSE( call mpas_log_write('-> Alarm is NOT ringing') )
<           test_mesg = trim(test_mesg)//' FAILURE'
<           ierr = ierr + 1
<       end if
<       call mpas_log_write(trim(test_mesg))
<       call mpas_reset_clock_alarm(test_clock, 'foobar', ierr=ierr_local)
< 
<    end subroutine mpas_adjust_alarm_tests
diff -r ../../../../../sorc/mpas/src/core_test/Registry.xml /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/core_test/Registry.xml
2c2
< <registry model="mpas" core="test" core_abbrev="test" version="8.2.3">
---
> <registry model="mpas" core="test" core_abbrev="test" version="8.2.2">
diff -r ../../../../../sorc/mpas/src/framework/mpas_block_creator.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/framework/mpas_block_creator.F
718d717
<      call mpas_deallocate_field(cellLimitField)
diff -r ../../../../../sorc/mpas/src/framework/mpas_bootstrapping.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/framework/mpas_bootstrapping.F
817a818
>      allocate(indexToEdgeID % array(nReadEdges))
diff -r ../../../../../sorc/mpas/src/framework/mpas_io.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/framework/mpas_io.F
1536,1557d1535
< #ifdef MPAS_SMIOL_SUPPORT
<             !
<             ! For the SMIOL library, only the size of the outermost (decomposed) dimension
<             ! must match, and the sizes of any inner dimensions do not need to be checked.
<             ! Since the dimensionality of fields may vary, previously created decopositions
<             ! always store the size of the decomposed dimension at decomphandle % dims(1)
<             ! rather than at decomphandle % dims(ndims)
<             !
<             if (.not. field_cursor % fieldhandle % has_unlimited_dim) then
<                if (decomp_cursor % decomphandle % dims(1) /= &
<                    field_cursor % fieldhandle % dims(field_cursor % fieldhandle % ndims) % dimsize) then
<                   decomp_cursor => decomp_cursor % next
<                   cycle DECOMP_LOOP
<                end if
<             else
<                if (decomp_cursor % decomphandle % dims(1) /= &
<                    field_cursor % fieldhandle % dims(field_cursor % fieldhandle % ndims - 1) % dimsize) then
<                   decomp_cursor => decomp_cursor % next
<                   cycle DECOMP_LOOP
<                end if
<             end if
< #endif
1735,1739d1712
<       ! Save the size of the outermost (decomposed) dimension for the field for use in
<       ! subsequent calls to MPAS_io_set_var_indices when checking whether this
<       ! decomposition can be reused for other fields
<       new_decomp % decomphandle % dims(1) = field_cursor % fieldhandle % dims(ndims) % dimsize
< 
diff -r ../../../../../sorc/mpas/src/framework/mpas_timekeeping.F /gpfs/f6/bil-fire10-oar/world-shared/jjh/rrfsv2/code/RDASAPP/GSI_BEC/RDASApp/sorc/mpas/src/framework/mpas_timekeeping.F
1004d1003
<       type (MPAS_TimeInterval_type) :: zeroInterval
1009d1007
< 
1013,1014d1010
<       call mpas_set_timeInterval(zeroInterval, S=0)
< 
1030a1027
>                         alarmPtr % prevRingTime = now - searchRemainder
1034,1036c1031
<                         if (searchRemainder /= zeroInterval) then
<                             searchRemainder = alarmPtr % ringTimeInterval - searchRemainder
<                         end if
---
>                         alarmPtr % prevRingTime = now - (alarmPtr % ringTimeInterval - searchRemainder)
1038,1039c1033
<                      alarmPtr % prevRingTime = now - alarmPtr % ringTimeInterval - searchRemainder
<                   else ! MPAS_BACKWARD
---
>                   else ! MPAS_REVERSE
1041c1035
<                         searchInterval = referenceTime - now
---
>                         searchInterval = now - referenceTime
1042a1037
>                         alarmPtr % prevRingTime = now - searchRemainder
1044c1039
<                         searchInterval = now - referenceTime
---
>                         searchInterval = referenceTime - now
1046,1048c1041
<                         if (searchRemainder /= zeroInterval) then
<                             searchRemainder = alarmPtr % ringTimeInterval - searchRemainder
<                         end if
---
>                         alarmPtr % prevRingTime = now - (alarmPtr % ringTimeInterval - searchRemainder)
1050d1042
<                      alarmPtr % prevRingTime = now + alarmPtr % ringTimeInterval + searchRemainder
